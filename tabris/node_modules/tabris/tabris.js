/*!
 * Tabris.js 3.3.0
 * 
 * Copyright (c) 2014, 2017 EclipseSource Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * * Neither the name of Tabris.js nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
'use strict';

/**
 * Implementation based on https://github.com/then/promise
 *
 * Original work Copyright (c) 2014 Forbes Lindesay
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Events;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function asap(fn) {
  setTimeout(fn, 0);
}

// --- core.js ---

function noop() {}

// States:
//
// 0 - pending
// 1 - fulfilled with _value
// 2 - rejected with _value
// 3 - adopted the state of another promise, _value
//
// once the state is no longer pending (0) it is immutable

// to avoid using try/catch inside critical functions, we
// extract them to here.
var LAST_ERROR = null;
var IS_ERROR = {};

function getThen(obj) {
  try {
    return obj.then;
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}

function tryCallOne(fn, a) {
  try {
    return fn(a);
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}

function tryCallTwo(fn, a, b) {
  try {
    fn(a, b);
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}

// Promise may be used before tabris is initialized:
function getStackTraceStack() {
  return global.tabris ? global.tabris._stackTraceStack : [];
}

function setStackTraceStack(value) {
  if (global.tabris) {
    global.tabris._stackTraceStack = value;
  }
}

function Promise(fn) {
  var stackTraceStack = [new Error().stack].concat(getStackTraceStack());
  if (typeof this !== 'object') {
    throw new TypeError('Promises must be constructed via new');
  }
  if (typeof fn !== 'function') {
    throw new TypeError('not a function');
  }
  Object.defineProperties(this, {
    _deferredState: { value: 0, writable: true },
    _state: { value: 0, writable: true },
    _value: { value: null, writable: true },
    _stackTraceStack: { value: stackTraceStack, writable: false },
    _deferreds: { value: null, writable: true }
  });
  if (fn === noop) {
    return;
  }
  doResolve(fn, this);
}
Promise._onHandle = null;
Promise._onReject = null;
Promise._noop = noop;

Promise.prototype.then = function (onFulfilled, onRejected) {
  if (this.constructor !== Promise) {
    return safeThen(this, onFulfilled, onRejected);
  }
  var res = new Promise(noop);
  handle(this, new Handler(onFulfilled, onRejected, res));
  return res;
};

function safeThen(self, onFulfilled, onRejected) {
  return new self.constructor(function (resolve, reject) {
    var res = new Promise(noop);
    res.then(resolve, reject);
    handle(self, new Handler(onFulfilled, onRejected, res));
  });
}

function handle(self, deferred) {
  while (self._state === 3) {
    self = self._value;
  }
  if (Promise._onHandle) {
    Promise._onHandle(self);
  }
  if (self._state === 0) {
    if (self._deferredState === 0) {
      self._deferredState = 1;
      self._deferreds = deferred;
      return;
    }
    if (self._deferredState === 1) {
      self._deferredState = 2;
      self._deferreds = [self._deferreds, deferred];
      return;
    }
    self._deferreds.push(deferred);
    return;
  }
  handleResolved(self, deferred);
}

function handleResolved(self, deferred) {
  asap(function () {
    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      if (self._state === 1) {
        resolve(deferred.promise, self._value);
      } else {
        reject(deferred.promise, self._value);
      }
      return;
    }
    var oldStack = getStackTraceStack();
    setStackTraceStack(self._stackTraceStack);
    var ret = tryCallOne(cb, self._value);
    setStackTraceStack(oldStack);
    if (ret === IS_ERROR) {
      reject(deferred.promise, LAST_ERROR);
    } else {
      resolve(deferred.promise, ret);
    }
  });
}

function resolve(self, newValue) {
  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
  if (newValue === self) {
    return reject(self, new TypeError('A promise cannot be resolved with itself.'));
  }
  if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
    var then = getThen(newValue);
    if (then === IS_ERROR) {
      return reject(self, LAST_ERROR);
    }
    if (then === self.then && newValue instanceof Promise) {
      self._state = 3;
      self._value = newValue;
      finale(self);
      return;
    } else if (typeof then === 'function') {
      doResolve(then.bind(newValue), self);
      return;
    }
  }
  self._state = 1;
  self._value = newValue;
  finale(self);
}

function reject(self, newValue) {
  self._state = 2;
  self._value = newValue;
  if (Promise._onReject) {
    Promise._onReject(self, newValue);
  }
  finale(self);
}

function finale(self) {
  if (self._deferredState === 1) {
    handle(self, self._deferreds);
    self._deferreds = null;
  }
  if (self._deferredState === 2) {
    for (var i = 0; i < self._deferreds.length; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }
}

function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, promise) {
  var done = false;
  var res = tryCallTwo(fn, function (value) {
    if (done) {
      return;
    }
    done = true;
    resolve(promise, value);
  }, function (reason) {
    if (done) {
      return;
    }
    done = true;
    reject(promise, reason);
  });
  if (!done && res === IS_ERROR) {
    done = true;
    reject(promise, LAST_ERROR);
  }
}

// --- es6-extensions.js ---

//This file contains the ES6 extensions to the core Promises/A+ API

/* Static Functions */

function valuePromise(value) {
  var p = new Promise(Promise._noop);
  p._state = 1;
  p._value = value;
  return p;
}
Promise.resolve = function (value) {
  if (value instanceof Promise) {
    return value;
  }

  if (typeof value === 'object' || typeof value === 'function') {
    try {
      var then = value.then;
      if (typeof then === 'function') {
        return new Promise(then.bind(value));
      }
    } catch (ex) {
      return new Promise(function (resolve, reject) {
        return reject(ex);
      });
    }
  }
  return valuePromise(value);
};

Promise.all = function (arr) {
  var args = Array.prototype.slice.call(arr);
  return new Promise(function (resolve, reject) {
    if (args.length === 0) {
      return resolve([]);
    }
    var remaining = args.length;
    function res(i, val) {
      if (val && (typeof val === 'object' || typeof val === 'function')) {
        if (val instanceof Promise && val.then === Promise.prototype.then) {
          while (val._state === 3) {
            val = val._value;
          }
          if (val._state === 1) {
            return res(i, val._value);
          }
          if (val._state === 2) {
            reject(val._value);
          }
          val.then(function (val) {
            return res(i, val);
          }, reject);
          return;
        } else {
          var then = val.then;
          if (typeof then === 'function') {
            var p = new Promise(then.bind(val));
            p.then(function (val) {
              return res(i, val);
            }, reject);
            return;
          }
        }
      }
      args[i] = val;
      if (--remaining === 0) {
        resolve(args);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise.reject = function (value) {
  return new Promise(function (resolve, reject) {
    return reject(value);
  });
};

Promise.race = function (values) {
  return new Promise(function (resolve, reject) {
    return values.forEach(function (value) {
      return Promise.resolve(value).then(resolve, reject);
    });
  });
};

/* Prototype Methods */

Promise.prototype.catch = function (onRejected) {
  return this.then(null, onRejected);
};

/* Inspection Methods */

function isPending(promise) {
  return promise._state === 0;
}

function isRejected(promise) {
  return promise._state === 2;
}

function getPromiseResult(promise) {
  return promise._value;
}

global.Promise = Promise;

if (typeof window === 'undefined') {
  global.window = global;
}

if (!Object.assign) {
  Object.defineProperty(Object, 'assign', {
    enumerable: false,
    configurable: true,
    writable: true,
    value: assign
  });
}

/**
 * Original code from
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */
function assign(target) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert first argument to object');
  }
  var to = Object(target);
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    if (source === undefined || source === null) {
      continue;
    }
    var keys = Object.keys(Object(source));
    for (var key of keys) {
      var desc = Object.getOwnPropertyDescriptor(source, key);
      if (desc !== undefined && desc.enumerable) {
        to[key] = source[key];
      }
    }
  }
  return to;
}

var equals$1 = Symbol('equals');
var creationAllowed = Symbol('creationAllowed');
var bytes = Symbol('bytes');
var nativeObject = Symbol('nativeObject');
var toXML$1 = Symbol('toXML');
var notify = Symbol('notify');
var data = Symbol('data');
var listenersStore = Symbol('listenersStore');

function pick(object, keys) {
  var result = {};
  for (var key in object) {
    if (keys.includes(key)) {
      result[key] = object[key];
    }
  }
  return result;
}

function omit(object, keys) {
  var result = {};
  for (var key in object) {
    if (!keys.includes(key)) {
      result[key] = object[key];
    }
  }
  return result;
}

function isObject(value) {
  return value !== null && typeof value === 'object';
}

function capitalizeFirstChar(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

function normalizePath(path) {
  if (typeof path !== 'string') {
    throw new Error('must be a string');
  }
  if (path === '') {
    throw new Error('must not be empty');
  }
  var prefix = path.startsWith('/') ? '/' : '';
  var segments = [];
  var pathSegments = path.split('/');
  for (var i = 0; i < pathSegments.length; i++) {
    var segment = pathSegments[i];
    if (segment === '..') {
      var removed = segments.pop();
      if (!removed || removed === '.') {
        throw new Error('Path must not start with ".."');
      }
    } else if (segment !== '.' && segment !== '') {
      segments.push(segment);
    }
  }
  if (!segments.length) {
    return prefix || '.';
  }
  return prefix + segments.join('/');
}

function normalizePathUrl(url) {
  if (typeof url !== 'string') {
    throw new Error('must be a string');
  }
  var parts = /^([a-z-]+:(\/\/)?)?(.*)/.exec(url);
  var schema = parts[1] || '';
  var content = parts[3] || '';
  if (schema === 'data:') {
    return url;
  }
  return schema + normalizePath(content);
}

function dirname(path) {
  if (!path || path.slice(0, 1) !== '.') {
    return './';
  }
  return path.slice(0, path.lastIndexOf('/'));
}

/**
 * Check if a given value is a number and in closed range.
 * @param value Value to check.
 * @param range An array of min and max value of a closed range.
 * @param errorPrefix Prefix to prepend to messages of thrown errors.
 */
function checkNumber(value) {
  var range = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [-Infinity, Infinity];
  var errorPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

  var prefix = errorPrefix ? errorPrefix + ': ' : '';
  if (typeof value !== 'number' || isNaN(value) || !isFinite(value)) {
    throw new Error(prefix + 'Invalid number ' + value);
  }
  if (value < range[0] || value > range[1]) {
    throw new Error(prefix + 'Number ' + value + ' out of range');
  }
}

/**
 * Boolean values indicates whether the trap must return true to avoid
 * exceptions if code is executed in strict mode. (Which is never desired.)
 */
var traps = {
  getPrototypeOf: false,
  setPrototypeOf: true,
  isExtensible: false,
  preventExtensions: false,
  getOwnPropertyDescriptor: false,
  defineProperty: true,
  has: false,
  get: false,
  set: true,
  deleteProperty: true,
  ownKeys: false,
  apply: false,
  construct: false
};

/**
 * @param {() => object} getTarget
 */
function proxify(getTarget) {
  var handler = {};
  Object.keys(traps).forEach(function (trap) {
    return handler[trap] = function (_) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var result = Reflect[trap](getTarget(), ...args);
      return traps[trap] ? true : result;
    };
  });
  return new Proxy({}, handler);
}

function isReadable(value) {
  return value instanceof ArrayBuffer || ArrayBuffer.isView(value) || !!getBytes(value);
}

/**
 * @param {any} value
 * @return {ArrayBuffer}
 */
function read(value) {
  if (value instanceof ArrayBuffer) {
    return value.slice(0);
  }
  if (ArrayBuffer.isView(value)) {
    return value.buffer.slice(0);
  }
  if (getBytes(value)) {
    return getBytes(value); // no copy needed since blobs are pseudo-immutable
  }
  throw new Error(typeof value + ' is not an ArrayBuffer, Blob or typed');
}

/**
 * @param {any} blob
 * @returns {ArrayBuffer}
 */
function getBytes(blob) {
  return blob[bytes];
}

/**
 * @param {any} blob
 * @param {ArrayBuffer} bytes
 */
function setBytes(blob, bytes$$1) {
  return blob[bytes] = bytes$$1;
}

/**
 * @template {object} T
 * @template {keyof T} U
 * @param {object} target
 * @param {U[]} keys
 * @returns {Partial<Record<U, unknown>>}
 */
function allowOnlyKeys(target, keys) {
  if (typeof target !== 'object') {
    throw new Error(toValueString(target) + ' is not an object');
  }
  for (var key in target) {
    if (keys.indexOf( /** @type {U} */key) === -1) {
      throw new Error(toValueString(target) + ' contains unexpected entry "' + key + '"');
    }
  }
  return target;
}

/**
 * @template {any} T
 * @param {T} value
 * @param {any[]|undefined} allowed
 * @returns T
 */
function allowOnlyValues(value, allowed) {
  var valueName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'Value';

  if (allowed && allowed.indexOf(value) === -1) {
    var expected = '"' + allowed.slice(0, -1).join('", "') + '" or "' + allowed.slice(-1) + '"';
    throw new Error(valueName + ' must be ' + expected + '", got ' + toValueString(value));
  }
  return value;
}

/**
 * @param {object} object
 * @param {{cid: string}} nativeObject
 */
function setNativeObject(object, nativeObject$$1) {
  object[nativeObject] = nativeObject$$1;
}

/**
 * @param {object} object
 * @returns {{cid: string, isDisposed: () => boolean}}
 */
function getNativeObject(object) {
  return object instanceof Object ? object[nativeObject] : null;
}

/**
 * @param {Function} cb
 * @param {object=} target
 * @param {any[]=} args
 */
function createNativeCallback(cb, target, args) {
  var stackTraceStack = [new Error().stack].concat(tabris._stackTraceStack);
  return function () {
    var oldStack = tabris._stackTraceStack;
    tabris._stackTraceStack = stackTraceStack;
    cb.apply(target ? target : global, args ? args : arguments);
    tabris.flush();
    tabris._stackTraceStack = oldStack;
  };
}

function equals(a, b) {
  if (a === b) {
    return true;
  }
  if (a instanceof Object && b instanceof Object && a[equals$1] instanceof Function && b[equals$1] instanceof Function && a[equals$1] === b[equals$1]) {
    return a[equals$1](b);
  }
  if (a instanceof Object && a.constructor === Object && b instanceof Object && b.constructor === Object) {
    var keysA = Reflect.ownKeys(a).sort();
    var keysB = Reflect.ownKeys(b).sort();
    return keysA.length === keysB.length && keysA.every(function (keyA, index) {
      var keyB = keysB[index];
      return keyA === keyB && a[keyA] === b[keyB];
    });
  }
  if (a instanceof Array && a.constructor === Array && b instanceof Array && b.constructor === Array) {
    return a.length === b.length && a.every(function (itemA, index) {
      return itemA === b[index];
    });
  }
  return false;
}

var androidStackLineRegex = /^ +at +(.+) +\((.*):([0-9]+):([0-9]+)\)/;
var androidStackLineNoNameRegex = /^ +at +(.*):([0-9]+):([0-9]+)/;
var iosStackLineRegex = /^(.+)@(.*):([0-9]+):([0-9]+)/;
var iosStackLineNoNameRegex = /(.*):([0-9]+):([0-9]+)/;
var urlBaseRegEx = /^[a-z]+:\/\/[^/]+\//;

function getStackTrace(error$$1) {
  try {
    return getStackArray(error$$1).join('\n');
  } catch (ex) {
    var minimalError = ex && ex.constructor && ex.message ? ex.constructor.name + ': ' + ex.message : '';
    warn('Could not process stack trace (' + (minimalError || ex) + '), printing original.');
    return error$$1.stack;
  }
}

function patchError(fn) {
  fn.prototype.toString = function () {
    return formatError(this);
  };
}

function formatError(error$$1) {
  var stack = void 0;
  try {
    if (!(error$$1 instanceof Object)) {
      return '' + error$$1;
    }
    if (!(error$$1 instanceof Error)) {
      return error$$1.constructor.name + ': ' + error$$1.toString();
    } else {
      stack = getStackArray(error$$1).map(function (line) {
        return '  at ' + line;
      }).join('\n');
    }
  } catch (ex) {
    stack = error$$1.stack;
  }
  return error$$1.constructor.name + ': ' + error$$1.message + '\n' + stack;
}

function getCurrentLine(error$$1) {
  try {
    return getStackArray(error$$1)[0].trim();
  } catch (ex) {
    return '';
  }
}

function getStackArray(error$$1) {
  var stack = limitStack([error$$1.stack].concat(tabris._stackTraceStack).join('\n').split('\n').filter(filterStackLine));
  var formattedStack = stack.map(normalizeStackLine).filter(function (line) {
    return !!line;
  });
  if (!formattedStack.length) {
    throw new Error('Empty stacktrace');
  }
  return formattedStack;
}

/** @param {string[]} stack */
function limitStack(stack) {
  if (stack.length > 300) {
    var missing = stack.length - 300;
    return stack.slice(0, 150).concat(['[' + missing + ' more lines...]']).concat(stack.slice(-150));
  }
  return stack;
}

function filterStackLine(line) {
  if (tabris.device.platform === 'Android' && !androidStackLineNoNameRegex.test(line)) {
    return false;
  }
  return line.indexOf('tabris/tabris.min.js:') === -1 && line.indexOf('@[native code]') === -1 && line.indexOf('<anonymous>:') === -1;
}

/** @param {string} line */
function normalizeStackLine(line) {
  if (line.endsWith('more lines...]')) {
    return line;
  }
  var mapped = applySourceMap(parseLine(line));
  if (!mapped) {
    return null;
  }
  if (!mapped.fn) {
    return mapped.url + ':' + mapped.line + ':' + mapped.column;
  }
  return mapped.fn + ' (' + mapped.url + ':' + mapped.line + ':' + mapped.column + ')';
}

function parseLine(line) {
  var regex = tabris.device.platform === 'Android' ? androidStackLineRegex : iosStackLineRegex;
  var noNameRegex = tabris.device.platform === 'Android' ? androidStackLineNoNameRegex : iosStackLineNoNameRegex;
  var fullMatch = line.match(regex);
  var noNameMatch = line.match(noNameRegex);
  if (fullMatch && fullMatch.length === 5) {
    var [, fn, url, _line, column] = fullMatch;
    return {
      fn: normalizeFunctionName(fn),
      url: fixUrl(url),
      line: parseInt(_line, 10),
      column: parseInt(column, 10)
    };
  } else if (noNameMatch && noNameMatch.length === 4) {
    var [, _url, _line2, _column] = noNameMatch;
    return {
      fn: null,
      url: fixUrl(_url),
      line: parseInt(_line2, 10),
      column: parseInt(_column, 10)
    };
  }
  return null;
}

function normalizeFunctionName(fn) {
  var result = fn.split('.').pop();
  if (result === 'then' || result === '<anonymous>') {
    result = null;
  }
  return result;
}

function fixUrl(url) {
  var urlBase = url.match(urlBaseRegEx);
  if (urlBase) {
    return './' + url.slice(urlBase[0].length);
  }
  return url;
}

function applySourceMap(stackLineData) {
  if (!stackLineData) {
    return null;
  }
  var { fn: fn } = stackLineData;
  var { url: url, line: line, column: column } = stackLineData;
  var sourceMap = tabris.Module.getSourceMap(url);
  if (sourceMap) {
    if (!sourceMap.decodedMappings) {
      sourceMap.decodedMappings = decodeMappings(sourceMap.mappings);
    }
    var match = findMapping(sourceMap.decodedMappings, line, column);
    if (match && match.length >= 4) {
      // TODO: use name index (match[4] if present) to rename "fn"
      var [generatedColumn, orgFile, orgLine, orgColumn] = match;
      url = './' + normalizePath(dirname(url) + '/' + sourceMap.sources[orgFile]);
      line = orgLine + 1;
      column = column + (orgColumn - generatedColumn);
    } else {
      return null;
    }
  }
  return { fn: fn, url: url, line: line, column: column };
}

function findMapping(mappings, line, column) {
  var lineMappings = mappings ? mappings[line - 1] : null;
  if (!lineMappings || !lineMappings.length) {
    return null;
  }
  return lineMappings.find(function (mapping, index) {
    if (!mapping) {
      return false;
    }
    var next = lineMappings[index + 1];
    var startColumn = mapping[0] + 1;
    var endColumn = next ? next[0] + 1 : Infinity;
    if (index === 0 && column < startColumn) {
      return true;
    }
    return column >= startColumn && column < endColumn;
  });
}

/**
 * All code below
 * based on https://github.com/Rich-Harris/vlq/blob/b7093c21ec6c9bbfed454d2785909b53cec4bd98/src/vlq.ts
 * Copyright (c) 2017 Rich-Harris and MattiasBuelens
 * MIT licensed: https://github.com/Rich-Harris/vlq/blob/b7093c21ec6c9bbfed454d2785909b53cec4bd98/LICENSE
 */
var charToInteger = {};
'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split('').forEach(function (char, i) {
  charToInteger[char] = i;
});

function decodeMappings(mappings) {
  var sourceFileIndex = 0;
  var sourceCodeLine = 0;
  var sourceCodeColumn = 0;
  var nameIndex = 0;
  return mappings.split(';').map(function (line) {
    return line.split(',').map(decodeVLQ);
  }).map(function (line) {
    var generatedCodeColumn = 0;
    return line.map(function (segment) {
      if (segment.length === 0) {
        return null;
      }
      generatedCodeColumn += segment[0];
      var result = [generatedCodeColumn];
      if (segment.length === 1) {
        return result; // ???
      }
      sourceFileIndex += segment[1];
      sourceCodeLine += segment[2];
      sourceCodeColumn += segment[3];
      result.push(sourceFileIndex, sourceCodeLine, sourceCodeColumn);
      if (segment.length === 5) {
        nameIndex += segment[4];
        result.push(nameIndex);
      }
      return result;
    });
  });
}

function decodeVLQ(string) {
  var result = [];
  var shift = 0;
  var value = 0;
  for (var i = 0; i < string.length; i++) {
    var integer = charToInteger[string[i]];
    if (integer === undefined) {
      throw new Error('Invalid character (' + string[i] + ')');
    }
    var hasContinuationBit = integer & 32;
    integer &= 31;
    value += integer << shift;
    if (hasContinuationBit) {
      shift += 5;
    } else {
      var shouldNegate = value & 1;
      value >>= 1;
      result.push(shouldNegate ? -value : value);
      value = shift = 0;
    }
  }
  return result;
}

/*
 * Implementation based on Node.js https://github.com/nodejs/node/
 *
 * Original work Copyright Copyright Joyent, Inc. and other Node contributors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
 * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var numbersOnlyRE = /^\d+$/;

var objectHasOwnProperty = Object.prototype.hasOwnProperty;
var propertyIsEnumerable = Object.prototype.propertyIsEnumerable;
var regExpToString = RegExp.prototype.toString;
var dateToISOString = Date.prototype.toISOString;

var CIRCULAR_ERROR_MESSAGE = void 0;

// TODO: Add support for Map, Set, MapIterator, SetIterator, DataView

function tryStringify(arg) {
  try {
    return JSON.stringify(arg);
  } catch (err) {
    // Populate the circular error message lazily
    if (!CIRCULAR_ERROR_MESSAGE) {
      try {
        var a = {};a.a = a;JSON.stringify(a);
      } catch (err) {
        CIRCULAR_ERROR_MESSAGE = err.message;
      }
    }
    if (err.name === 'TypeError' && err.message === CIRCULAR_ERROR_MESSAGE) {
      return '[Circular]';
    }
    throw err;
  }
}

function format(f) {
  if (typeof f !== 'string') {
    var objects = new Array(arguments.length);
    for (var index = 0; index < arguments.length; index++) {
      objects[index] = inspect(arguments[index]);
    }
    return objects.join(' ');
  }
  if (arguments.length === 1) {
    return f;
  }
  var str = '';
  var a = 1;
  var lastPos = 0;
  for (var i = 0; i < f.length;) {
    if (f.charCodeAt(i) === 37 /*'%'*/ && i + 1 < f.length) {
      if (f.charCodeAt(i + 1) !== 37 /*'%'*/ && a >= arguments.length) {
        ++i;
        continue;
      }
      switch (f.charCodeAt(i + 1)) {
        case 100:
          // 'd'
          if (lastPos < i) {
            str += f.slice(lastPos, i);
          }
          str += Number(arguments[a++]);
          break;
        case 105:
          // 'i'
          if (lastPos < i) {
            str += f.slice(lastPos, i);
          }
          str += parseInt(arguments[a++]);
          break;
        case 102:
          // 'f'
          if (lastPos < i) {
            str += f.slice(lastPos, i);
          }
          str += parseFloat(arguments[a++]);
          break;
        case 106:
          // 'j'
          if (lastPos < i) {
            str += f.slice(lastPos, i);
          }
          str += tryStringify(arguments[a++]);
          break;
        case 115:
          // 's'
          if (lastPos < i) {
            str += f.slice(lastPos, i);
          }
          str += String(arguments[a++]);
          break;
        case 37:
          // '%'
          if (lastPos < i) {
            str += f.slice(lastPos, i);
          }
          str += '%';
          break;
        default:
          // any other character is not a correct placeholder
          if (lastPos < i) {
            str += f.slice(lastPos, i);
          }
          str += '%';
          lastPos = i = i + 1;
          continue;
      }
      lastPos = i = i + 2;
      continue;
    }
    ++i;
  }
  if (lastPos === 0) {
    str = f;
  } else if (lastPos < f.length) {
    str += f.slice(lastPos);
  }
  while (a < arguments.length) {
    var x = arguments[a++];
    if (x === null || typeof x !== 'object' && typeof x !== 'symbol') {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
}

function inspect(obj) {
  // default options
  var ctx = {
    seen: [],
    breakLength: 60,
    maxArrayLength: 20
  };
  return formatValue(ctx, obj, 2);
}

function arrayToHash(array) {
  var hash = Object.create(null);
  for (var i = 0; i < array.length; i++) {
    var val = array[i];
    hash[val] = true;
  }
  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);
  var symbolKeys = Object.getOwnPropertySymbols(value);
  var enumSymbolKeys = symbolKeys.filter(function (key) {
    return propertyIsEnumerable.call(value, key);
  });
  keys = keys.concat(enumSymbolKeys);

  // This could be a boxed primitive (new String(), etc.), check valueOf()
  // NOTE: Avoid calling `valueOf` on `Date` instance because it will return
  // a number which, when object has some additional user-stored `keys`,
  // will be printed out.
  var formatted = void 0;
  var raw = value;
  try {
    // the .valueOf() call can fail for a multitude of reasons
    if (!isDate(value)) {
      raw = value.valueOf();
    }
  } catch (e) {
    // ignore...
  }

  if (typeof raw === 'string') {
    // for boxed Strings, we have to remove the 0-n indexed entries,
    // since they just noisy up the output and are redundant
    keys = keys.filter(function (key) {
      if (typeof key === 'symbol') {
        return true;
      }
      return !(key >= 0 && key < raw.length);
    });
  }

  // On iOS, errors have these extra enumerable fields
  if (isError(value) && tabris.device.platform === 'iOS') {
    keys = keys.filter(function (key) {
      return !['line', 'column', 'sourceURL'].includes(key);
    });
  }

  var constructor = getConstructorOf(value);

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (typeof value === 'function') {
      var ctorName = constructor ? constructor.name : 'Function';
      return '[' + ctorName + (value.name ? ': ' + value.name : '') + ']';
    }
    if (isRegExp(value)) {
      return regExpToString.call(value);
    }
    if (isDate(value)) {
      if (Number.isNaN(value.getTime())) {
        return value.toString();
      } else {
        return dateToISOString.call(value);
      }
    }
    if (isError(value)) {
      return formatError(value);
    }
    // now check the `raw` value to handle boxed primitives
    if (typeof raw === 'string') {
      formatted = formatPrimitive(ctx, raw);
      return '[String: ' + formatted + ']';
    }
    if (typeof raw === 'symbol') {
      formatted = formatPrimitive(ctx, raw);
      return '[Symbol: ' + formatted + ']';
    }
    if (typeof raw === 'number') {
      formatted = formatPrimitive(ctx, raw);
      return '[Number: ' + formatted + ']';
    }
    if (typeof raw === 'boolean') {
      formatted = formatPrimitive(ctx, raw);
      return '[Boolean: ' + formatted + ']';
    }
  }

  var base = '';
  var empty = false;
  var formatter = formatObject;
  var braces = void 0;

  // We can't compare constructors for various objects using a comparison like
  // `constructor === Array` because the object could have come from a different
  // context and thus the constructor won't match. Instead we check the
  // constructor names (including those up the prototype chain where needed) to
  // determine object types.
  if (Array.isArray(value)) {
    // Unset the constructor to prevent "Array [...]" for ordinary arrays.
    if (constructor && constructor.name === 'Array') {
      constructor = null;
    }
    braces = ['[', ']'];
    empty = value.length === 0;
    formatter = formatArray;
  } else if (isArrayBuffer(value)) {
    braces = ['{', '}'];
    keys.unshift('byteLength');
    visibleKeys.byteLength = true;
  } else if (isTypedArray(value)) {
    braces = ['[', ']'];
    formatter = formatTypedArray;
  } else if (isPromise(value)) {
    braces = ['{', '}'];
    formatter = formatPromise;
  } else {
    try {
      if (value instanceof Object && value.toString !== Object.prototype.toString) {
        var result = value.toString();
        if (typeof result === 'string') {
          return result;
        }
      }
    } catch (ex) {}
    // try something else

    // Unset the constructor to prevent "Object {...}" for ordinary objects.
    if (constructor && constructor.name === 'Object') {
      constructor = null;
    }
    braces = ['{', '}'];
    empty = true; // No other data than keys.
  }

  empty = empty === true && keys.length === 0;

  // Make functions say that they are functions
  if (typeof value === 'function') {
    var _ctorName = constructor ? constructor.name : 'Function';
    base = ' [' + _ctorName + (value.name ? ': ' + value.name : '') + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + regExpToString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + dateToISOString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    return formatError(value);
  }

  // Make boxed primitive Strings look like such
  if (typeof raw === 'string') {
    formatted = formatPrimitive(ctx, raw);
    base = ' [String: ' + formatted + ']';
  }

  // Make boxed primitive Numbers look like such
  if (typeof raw === 'number') {
    formatted = formatPrimitive(ctx, raw);
    base = ' [Number: ' + formatted + ']';
  }

  // Make boxed primitive Booleans look like such
  if (typeof raw === 'boolean') {
    formatted = formatPrimitive(ctx, raw);
    base = ' [Boolean: ' + formatted + ']';
  }

  // Add constructor name if available
  if (base === '' && constructor) {
    braces[0] = constructor.name + ' ' + braces[0];
  }

  if (empty === true) {
    return '' + braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return regExpToString.call(value);
    } else if (Array.isArray(value)) {
      return '[Array]';
    } else {
      return '[Object]';
    }
  }

  ctx.seen.push(value);
  var output = formatter(ctx, value, recurseTimes, visibleKeys, keys);
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces, ctx.breakLength);
}

function formatNumber(ctx, value) {
  // Format -0 as '-0'. Strict equality won't distinguish 0 from -0.
  if (Object.is(value, -0)) {
    return '-0';
  }
  return '' + value;
}

function formatPrimitive(ctx, value) {
  if (value === undefined) {
    return 'undefined';
  }
  // For some reason typeof null is "object", so special case here.
  if (value === null) {
    return 'null';
  }
  var type = typeof value;
  if (type === 'string') {
    var simple = JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"');
    return '\'' + simple + '\'';
  }
  if (type === 'number') {
    return formatNumber(ctx, value);
  }
  if (type === 'boolean') {
    return '' + value;
  }
  // es6 symbol primitive
  if (type === 'symbol') {
    return value.toString();
  }
}

function formatObject(ctx, value, recurseTimes, visibleKeys, keys) {
  return keys.map(function (key) {
    return formatProperty(ctx, value, recurseTimes, visibleKeys, key, false);
  });
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  var visibleLength = 0;
  var index = 0;
  while (index < value.length && visibleLength < ctx.maxArrayLength) {
    var emptyItems = 0;
    while (index < value.length && !hasOwnProperty(value, String(index))) {
      emptyItems++;
      index++;
    }
    if (emptyItems > 0) {
      var ending = emptyItems > 1 ? 's' : '';
      var message = '<' + emptyItems + ' empty item' + ending + '>';
      output.push(message);
    } else {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(index), true));
      index++;
    }
    visibleLength++;
  }
  var remaining = value.length - index;
  if (remaining > 0) {
    output.push('... ' + remaining + ' more item' + (remaining > 1 ? 's' : ''));
  }
  for (var n = 0; n < keys.length; n++) {
    var key = keys[n];
    if (typeof key === 'symbol' || !numbersOnlyRE.test(key)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  }
  return output;
}

function formatTypedArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var maxLength = Math.min(Math.max(0, ctx.maxArrayLength), value.length);
  var remaining = value.length - maxLength;
  var output = new Array(maxLength);
  for (var i = 0; i < maxLength; ++i) {
    output[i] = formatNumber(ctx, value[i]);
  }
  if (remaining > 0) {
    output.push('... ' + remaining + ' more item' + (remaining > 1 ? 's' : ''));
  }
  for (var key of keys) {
    if (typeof key === 'symbol' || !numbersOnlyRE.test(key)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  }
  return output;
}

function formatPromise(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  if (isPending(value)) {
    output.push('<pending>');
  } else {
    var nextRecurseTimes = recurseTimes === null ? null : recurseTimes - 1;
    var result = getPromiseResult(value);
    var str = formatValue(ctx, result, nextRecurseTimes);
    if (isRejected(value)) {
      output.push('<rejected> ' + str);
    } else {
      output.push(str);
    }
  }
  for (var n = 0; n < keys.length; n++) {
    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, keys[n], false));
  }
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name = void 0,
      str = void 0;
  var desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = '[Getter/Setter]';
    } else {
      str = '[Getter]';
    }
  } else {
    if (desc.set) {
      str = '[Setter]';
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    if (typeof key === 'symbol') {
      name = '[' + key.toString() + ']';
    } else {
      name = '[' + key + ']';
    }
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (recurseTimes === null) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.replace(/\n/g, '\n  ');
        } else {
          str = str.replace(/^|\n/g, '\n   ');
        }
      }
    } else {
      str = '[Circular]';
    }
  }
  if (name === undefined) {
    if (array && numbersOnlyRE.test(key)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (/^"[a-zA-Z_][a-zA-Z_0-9]*"$/.test(name)) {
      name = name.substr(1, name.length - 2);
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/^"|"$/g, "'").replace(/\\\\/g, '\\');
    }
  }
  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces, breakLength) {
  var length = output.reduce(function (prev, cur) {
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);
  if (length > breakLength) {
    return braces[0] + (
    // If the opening "brace" is too large, like in the case of "Set {",
    // we need to force the first item to be on the next line or the
    // items will not line up correctly.
    base === '' && braces[0].length === 1 ? '' : base + '\n ') + (' ' + output.join(',\n  ') + ' ' + braces[1]);
  }

  return '' + braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

function hasOwnProperty(obj, prop) {
  return objectHasOwnProperty.call(obj, prop);
}

function isError(value) {
  return objectToString(value) === '[object Error]' || value instanceof Error;
}

function isDate(value) {
  return objectToString(value) === '[object Date]' || value instanceof Date;
}

function isPromise(value) {
  return objectToString(value) === '[object Promise]' || value instanceof Promise;
}

function isRegExp(value) {
  return objectToString(value) === '[object RegExp]' || value instanceof RegExp;
}

var typedArrayTypes = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array'];
var typedArrayNames = {};
for (var type of typedArrayTypes) {
  typedArrayNames['[object ' + type + ']'] = true;
}

function isTypedArray(value) {
  return typedArrayNames[objectToString(value)];
}

function isArrayBuffer(value) {
  return objectToString(value) === '[object ArrayBuffer]' || value instanceof ArrayBuffer;
}

function getConstructorOf(obj) {
  while (obj) {
    var descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');
    if (descriptor !== undefined && typeof descriptor.value === 'function' && descriptor.value.name !== '') {
      return descriptor.value;
    }
    obj = Object.getPrototypeOf(obj);
  }
  return null;
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

var toXML$$1 = toXML$1;

var Console = function () {
  function Console() {
    _classCallCheck(this, Console);

    this._registerPrintMethods(arguments[0]);
    Object.defineProperties(this, {
      _prefixSpaces: { enumerable: false, writable: true, value: 0 },
      _count: { enumerable: false, writable: false, value: {} }
    });
  }

  _createClass(Console, [{
    key: 'trace',
    value: function trace() {
      this.log(getStackTrace(new Error('StackTrace')));
    }
  }, {
    key: 'assert',
    value: function assert(expression) {
      if (!expression) {
        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        args[0] = 'Assertion failed' + (args.length === 0 ? '' : ': ' + args[0]);
        this.error(...args);
      }
    }
  }, {
    key: 'count',
    value: function count(label) {
      label = label ? label : 'default';
      if (!this._count[label]) {
        this._count[label] = 0;
      }
      this.log('%s: %s', label, ++this._count[label]);
    }
  }, {
    key: 'countReset',
    value: function countReset(label) {
      label = label ? label : 'default';
      this.log('%s: %s', label, this._count[label] = 0);
    }
  }, {
    key: 'dirxml',
    value: function dirxml(obj) {
      if (obj && obj[toXML$$1] instanceof Function) {
        this.log(obj[toXML$$1]());
      } else {
        this.log(obj);
      }
    }
  }, {
    key: 'group',
    value: function group() {
      this.log(...arguments);
      this._prefixSpaces += 2;
    }
  }, {
    key: 'groupEnd',
    value: function groupEnd() {
      if (this._prefixSpaces > 0) {
        this._prefixSpaces -= 2;
      }
    }
  }, {
    key: 'debug',
    value: function debug() {
      this._console.debug(...arguments);
    }
  }, {
    key: 'info',
    value: function info() {
      this._console.info(...arguments);
    }
  }, {
    key: 'log',
    value: function log() {
      this._console.log(...arguments);
    }
  }, {
    key: 'warn',
    value: function warn() {
      this._console.warn(...arguments);
    }
  }, {
    key: 'error',
    value: function error() {
      this._console.error(...arguments);
    }
  }, {
    key: '_registerPrintMethods',
    value: function _registerPrintMethods(nativeConsole) {
      var _this = this;

      Object.defineProperty(this, '_console', {
        enumerable: false, writable: false, value: {}
      });

      var _loop = function (level) {
        _this._console[level] = function () {
          var message = _this._prepareOutput(...arguments);
          tabris.trigger('log', { level: level, message: message });
          nativeConsole.print(level, message);
        };
      };

      for (var level of ['debug', 'info', 'log', 'warn', 'error']) {
        _loop(level);
      }
    }
  }, {
    key: '_prepareOutput',
    value: function _prepareOutput() {
      var output = format(...arguments);
      if (this._prefixSpaces > 0) {
        output = '' + ' '.repeat(this._prefixSpaces) + output;
      }
      return output;
    }
  }]);

  return Console;
}();

function createConsole(nativeConsole) {
  return new Console(nativeConsole);
}

var defaultConsole = global.console.print ? createConsole(global.console) : global.console;

if (!defaultConsole.debug) {
  // The native node console has no "debug" method
  defaultConsole.debug = function () {
    defaultConsole.log(...arguments);
  };
}

var log = function () {
  defaultConsole.log(...arguments);
};
var warn = function () {
  defaultConsole.warn(...arguments);
};
var error = function () {
  defaultConsole.error(...arguments);
};

var inHint = false;

var toValueString = function (value) {
  try {
    if (value instanceof Array || value && value._array instanceof Array) {
      var array = value instanceof Array ? value : value._array;
      var joined = '[' + array.map(toValueString).join(', ') + ']';
      if (joined.length <= 40) {
        return joined;
      }
    }
    if (typeof value === 'string') {
      var escaped = value.slice(0, 40).replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n');
      return value.length > 40 ? '"' + escaped + '..."' : '"' + escaped + '"';
    }
    if (value && value[toXML$$1]) {
      // Alternative to using instanceof to avoid circular dependency
      return value._disposedToStringValue || value.toString();
    }
    if (value && value instanceof Function) {
      return value.name;
    }
    if (value && value.constructor === Object) {
      var json = JSON.stringify(value);
      if (json.length <= 40) {
        return json;
      }
    }
    if (value instanceof Object && value.constructor instanceof Function) {
      return value.constructor.name;
    }
    return value + '';
  } catch (ex) {
    return '[unknown]';
  }
};

var hint = function (source, message) {
  if (inHint) {
    return; // prevent potential stack overflow
  }
  inHint = true;
  var line = '';
  var prefix = '';
  line = getCurrentLine(new Error());
  if (source && typeof source === 'string') {
    prefix = source + ': ';
  } else if (source) {
    prefix = toValueString(source) + ': ';
  }
  defaultConsole.warn(prefix + message + (line ? '\nSource: ' + line : ''));
  inHint = false;
};

function checkVersion(tabrisVersionString, clientVersionString) {
  if (!clientVersionString) {
    return;
  }
  var tabrisVersion = tabrisVersionString.split('.');
  var clientVersion = clientVersionString.split('.');
  if (tabrisVersion[0] !== clientVersion[0] || tabrisVersion[1] !== clientVersion[1]) {
    error('Version mismatch: JavaScript module "tabris" (version ' + tabrisVersionString + ') ' + ('is incompatible with the native tabris platform (version ' + clientVersionString + ').'));
  }
}

var EventObject = function () {
  function EventObject() {
    var _this2 = this;

    _classCallCheck(this, EventObject);

    Object.defineProperties(this, {
      type: { enumerable: true, get: function () {
          return _this2.$type;
        } },
      target: { enumerable: true, get: function () {
          return _this2.$target;
        } },
      timeStamp: { enumerable: true, value: Date.now() },
      $type: { enumerable: false, writable: true, value: '' },
      $target: { enumerable: false, writable: true, value: null },
      $defaultPrevented: { enumerable: false, writable: true, value: false }
    });
  }

  _createClass(EventObject, [{
    key: 'preventDefault',
    value: function preventDefault() {
      this.$defaultPrevented = true;
    }
  }, {
    key: 'toString',
    value: function toString() {
      var _this3 = this;

      var header = this.constructor.name + ' { ';
      var content = Object.keys(this).map(function (prop) {
        return prop + ': ' + (typeof _this3[prop] === 'string' ? JSON.stringify(_this3[prop]) : format(_this3[prop]));
      }).join(', ');
      var footer = ' }';
      return header + content + footer;
    }
  }, {
    key: '_initEvent',
    value: function _initEvent(type, target) {
      if (arguments.length < 2) {
        throw new Error('Not enough arguments to initEvent');
      }
      this.$type = type;
      this.$target = target;
    }
  }, {
    key: 'defaultPrevented',
    get: function () {
      return !!this.$defaultPrevented;
    }
  }]);

  return EventObject;
}();

Object.defineProperty(EventObject.prototype, 'type', { value: '' });
Object.defineProperty(EventObject.prototype, 'target', { value: null });
Object.defineProperty(EventObject.prototype, 'timeStamp', { value: 0 });

var Events = (_Events = {
  on: function (type, callback, context) {
    if (isObject(type)) {
      for (var key in type) {
        this.on(key, type[key]);
      }
      return this;
    }
    if (typeof type !== 'string') {
      throw new Error(toValueString(type) + ' is not a string');
    }
    if (!(callback instanceof Function)) {
      throw new Error(toValueString(callback) + ' is not a function');
    }
    if (context && !(context instanceof Object)) {
      throw new Error(toValueString(context) + ' is not an object');
    }
    if (this._isDisposed) {
      hint(this, 'Event registration warning: Can not listen for event "' + type + '" on disposed object');
    }
    var wasListening = this._isListening(type);
    if (!this._callbacks) {
      Object.defineProperty(this, '_callbacks', {
        enumerable: false, writable: false, configurable: true, value: []
      });
    }
    this._callbacks[type] = (this._callbacks[type] || []).concat();
    var alreadyAdded = this._callbacks[type].some(function (entry) {
      return (entry.fn === callback || '_callback' in callback && entry.fn._callback === callback._callback) && entry.ctx === context;
    });
    if (!alreadyAdded) {
      this._callbacks[type].push({ fn: callback, ctx: context });
    }
    if (!wasListening) {
      this._listen(type, true);
    }
    return this;
  },
  off: function (type, callback, context) {
    if (isObject(type)) {
      for (var key in type) {
        this.off(key, type[key]);
      }
      return this;
    }
    if (!type || !callback) {
      throw new Error('Not enough arguments');
    }
    if (this._callbacks) {
      if (type in this._callbacks) {
        var callbacks = this._callbacks[type].concat();
        for (var i = callbacks.length - 1; i >= 0; i--) {
          if ((callbacks[i].fn === callback || callbacks[i].fn._callback === callback) && callbacks[i].ctx === context) {
            callbacks.splice(i, 1);
          }
        }
        if (callbacks.length === 0) {
          delete this._callbacks[type];
          if (Object.keys(this._callbacks).length === 0) {
            delete this._callbacks;
          }
        } else {
          this._callbacks[type] = callbacks;
        }
      }
    }
    if (!this._isListening(type)) {
      this._listen(type, false);
    }
    return this;
  },
  once: function (type, callback, context) {
    if (isObject(type)) {
      for (var key in type) {
        this.once(key, type[key]);
      }
      return this;
    }
    var self = this;
    var wrappedCallback = function () {
      if (!self._isDisposed) {
        self.off(type, wrappedCallback, context);
      }
      callback.apply(this, arguments);
    };
    wrappedCallback._callback = callback;
    return this.on(type, wrappedCallback, context);
  },
  trigger: function (type) {
    var eventData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    return this[notify](type, eventData, false);
  },
  triggerAsync: function (type) {
    var eventData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    return this[notify](type, eventData, true);
  }
}, _defineProperty(_Events, notify, function (type, eventData, async) {
  var _this4 = this;

  var returnValues = [];
  if (!this._isDisposed) {
    if (this._callbacks && type in this._callbacks) {
      (function () {
        var uninitialized = eventData instanceof EventObject && !eventData.type;
        var dispatchObject = uninitialized ? eventData : new EventObject();
        var target = _this4.$eventTarget || _this4;
        if (eventData && eventData !== dispatchObject) {
          var copyData = omit(eventData, ['type', 'target', 'timeStamp']);
          Object.assign(dispatchObject, copyData);
        }
        if (dispatchObject._initEvent instanceof Function) {
          dispatchObject._initEvent(type, target);
        }
        for (var callback of _this4._callbacks[type]) {
          var value = callback.fn.call(callback.ctx || _this4, dispatchObject);
          if (value instanceof Promise) {
            value.catch(function (ex) {
              return console.error('Listener for ' + target.constructor.name + ' event "' + type + '" rejected with ' + (ex.stack || ex));
            });
          }
          returnValues.push(value);
        }
      })();
    }
  } else {
    hint(this, 'Trigger warning: Can not dispatch event "' + type + '" on disposed object');
  }
  return async ? Promise.all(returnValues).then(function () {
    return _this4;
  }) : this;
}), _defineProperty(_Events, '_isListening', function (type) {
  return !!this._callbacks && (!type || type in this._callbacks);
}), _defineProperty(_Events, '_listen', function (type, isListening) {}), _Events);

var DELEGATE_FIELDS = ['promise', 'addListener', 'removeListener', 'once', 'trigger', 'triggerAsync'];

var Listeners = function () {
  _createClass(Listeners, null, [{
    key: 'getListenerStore',
    value: function getListenerStore(target) {
      // NOTE: we do not use an instanceof NativeObject check here since
      // importing NativeObject causes circular dependency issues
      if (target.on instanceof Function) {
        return target;
      }
      if (!target[listenersStore]) {
        target[listenersStore] = Object.assign({ $eventTarget: target }, Events);
      }
      return target[listenersStore];
    }
  }]);

  function Listeners(target, type) {
    _classCallCheck(this, Listeners);

    if (arguments.length < 1) {
      throw new Error('Missing target instance');
    }
    if (!(target instanceof Object)) {
      throw new Error('Target ' + toValueString(target) + ' is not an object');
    }
    if (arguments.length < 2 || !type) {
      throw new Error('Missing event type string');
    }
    if (typeof type !== 'string') {
      throw new Error('Event type ' + toValueString(type) + ' is not a string');
    }
    if (/^on[A-Z]/.test(type)) {
      throw new Error('Invalid event type string, did you mean "' + (type[2].toLowerCase() + type.slice(3)) + '"?');
    }
    this.store = Listeners.getListenerStore(target);
    var delegate = this.addListener.bind(this);
    delegate.target = this.target = target;
    delegate.type = this.type = type;
    delegate.original = this.original;
    for (var key of DELEGATE_FIELDS) {
      delegate[key] = this[key] = this[key].bind(this);
    }
    return delegate;
  }

  _createClass(Listeners, [{
    key: 'trigger',
    value: function trigger(eventData) {
      this.store.trigger(this.type, eventData);
      return this.target;
    }
  }, {
    key: 'triggerAsync',
    value: function triggerAsync(eventData) {
      var _this5 = this;

      return this.store.triggerAsync(this.type, eventData).then(function () {
        return _this5.target;
      });
    }
  }, {
    key: 'promise',
    value: function promise() {
      var _this6 = this;

      return new Promise(function (resolve) {
        return _this6.once(resolve);
      });
    }
  }, {
    key: 'once',
    value: function once(listener) {
      this.store.once(this.type, listener);
      return this.target;
    }
  }, {
    key: 'addListener',
    value: function addListener(listener) {
      this.store.on(this.type, listener);
      return this.target;
    }
  }, {
    key: 'removeListener',
    value: function removeListener(listener) {
      this.store.off(this.type, listener);
      return this.target;
    }
  }, {
    key: 'original',
    get: function () {
      return this;
    }
  }]);

  return Listeners;
}();

var ChangeListeners = function (_Listeners) {
  _inherits(ChangeListeners, _Listeners);

  function ChangeListeners(target, property) {
    _classCallCheck(this, ChangeListeners);

    propertyCheck(target, property);
    return _possibleConstructorReturn(this, (ChangeListeners.__proto__ || Object.getPrototypeOf(ChangeListeners)).call(this, target, property + 'Changed'));
  }

  _createClass(ChangeListeners, [{
    key: 'trigger',
    value: function trigger(eventData) {
      if (!('value' in eventData)) {
        throw new Error('Can not trigger change event without "value" property in event data');
      }
      _get(ChangeListeners.prototype.__proto__ || Object.getPrototypeOf(ChangeListeners.prototype), 'trigger', this).call(this, eventData);
    }
  }]);

  return ChangeListeners;
}(Listeners);

function propertyCheck(target, property) {
  if (!(property in target)) {
    throw new Error('Target has no property "' + property + '"');
  }
}

var MARKUP = {
  br: {},
  b: { children: 'object' },
  span: { children: 'object' },
  big: { children: 'object' },
  i: { children: 'object' },
  small: { children: 'object' },
  strong: { children: 'object' },
  ins: { children: 'object' },
  del: { children: 'object' },
  a: { href: 'string', children: 'object' }
};

function createJsxProcessor() {
  return new JsxProcessor();
}

var JsxProcessor = function () {
  function JsxProcessor() {
    _classCallCheck(this, JsxProcessor);
  }

  _createClass(JsxProcessor, [{
    key: 'createElement',
    value: function createElement(Type, attributes) {
      if (!(Type instanceof Function) && typeof Type !== 'string') {
        throw new Error('JSX: Unsupported type ' + toValueString(Type));
      }

      for (var _len3 = arguments.length, children = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
        children[_key3 - 2] = arguments[_key3];
      }

      if (attributes && attributes.children && children && children.length) {
        throw new Error('JSX: Children for type ' + Type.name + ' given twice.');
      }
      // Children may be part of attributes or given as varargs or both.
      // For JSX factories/functional components they should always be part of attributes
      var finalChildren = (children && children.length ? children : null) || (attributes && attributes.children && attributes.children.length ? attributes.children : null);
      var finalAttributes = Object.assign({}, attributes || {});
      if (finalChildren && finalChildren.length) {
        finalAttributes.children = finalChildren;
      } else {
        delete finalAttributes.children;
      }
      if (typeof Type === 'string') {
        return this.createIntrinsicElement(Type, finalAttributes);
      } else if (Type.prototype && Type.prototype[JSX.jsxFactory]) {
        return this.createCustomComponent(Type, finalAttributes);
      } else {
        return this.createFunctionalComponent(Type, finalAttributes);
      }
    }
  }, {
    key: 'createCustomComponent',
    value: function createCustomComponent(Type, attributes) {
      return Type.prototype[JSX.jsxFactory].call(this, Type, attributes);
    }
  }, {
    key: 'createFunctionalComponent',
    value: function createFunctionalComponent(Type, attributes) {
      try {
        var result = Type.call(this, attributes);
        Type[JSX.jsxType] = true;
        if (result instanceof Object) {
          result[JSX.jsxType] = Type;
        }
        return result;
      } catch (ex) {
        throw new Error('JSX: "' + ex.message + '" ' + getCurrentLine(ex));
      }
    }
  }, {
    key: 'createIntrinsicElement',
    value: function createIntrinsicElement(el, attributes) {
      if (el in MARKUP) {
        Object.keys(attributes || {}).forEach(function (attribute) {
          var attrType = typeof attributes[attribute];
          if (attrType !== MARKUP[el][attribute]) {
            if (attribute === 'children') {
              throw new Error('Element ' + el + ' can not have children');
            } else {
              throw new Error('Element ' + el + ' does not a support attribute ' + attribute + ' of type ' + attrType);
            }
          }
        });
        var text = joinTextContent(attributes.children, true);
        var tagOpen = [el].concat(Object.keys(attributes || {}).filter(function (attr) {
          return attr !== 'children';
        }).map(function (attribute) {
          return attribute + '=\'' + attributes[attribute] + '\'';
        })).join(' ');
        if (text) {
          return '<' + tagOpen + '>' + text + '</' + el + '>';
        }
        return '<' + tagOpen + '/>';
      }
      throw new Error('JSX: Unsupported type ' + el);
    }
  }, {
    key: 'createNativeObject',
    value: function createNativeObject(Type, attributes) {
      if (attributes && 'children' in attributes) {
        throw new Error('JSX: ' + Type.name + ' can not have children');
      }
      var result = new Type(this.withoutListeners(attributes || {}));
      this.registerListeners(result, attributes);
      return result;
    }
  }, {
    key: 'getChildren',
    value: function getChildren(attributes) {
      if (!attributes || !('children' in attributes)) {
        return null;
      }
      return normalizeChildren(attributes.children);
    }
  }, {
    key: 'withoutChildren',
    value: function withoutChildren(attributes) {
      return omit(attributes, ['children']);
    }
  }, {
    key: 'withoutListeners',
    value: function withoutListeners(attributes) {
      return omit(attributes, Object.keys(attributes).filter(this.isEventAttribute));
    }
  }, {
    key: 'registerListeners',
    value: function registerListeners(obj, attributes) {
      Listeners.getListenerStore(obj).on(this.getListeners(attributes));
    }
  }, {
    key: 'withContentText',
    value: function withContentText(attributes, content, property, markupEnabled) {
      if (attributes && attributes[property] && content && content.length) {
        throw new Error('JSX: ' + property + ' given twice');
      }
      var text = attributes && attributes[property] ? attributes[property].toString() : joinTextContent(content || [], markupEnabled);
      return Object.assign(attributes || {}, text ? _defineProperty({}, property, text) : {});
    }
  }, {
    key: 'withContentChildren',
    value: function withContentChildren(attributes, content, property) {
      if (attributes && attributes[property] && content && content.length) {
        throw new Error('JSX: ' + property + ' given twice');
      }
      var children = attributes && attributes[property] ? attributes[property] : content || [];
      return Object.assign(attributes || {}, children ? _defineProperty({}, property, children) : {});
    }

    /**
     * @param {object} attributes
     * @param {{[attr: string]: string}} shorthandsMapping
     * @param {((value1: any, value2: string) => any)} merge
     * @returns {object}
     */

  }, {
    key: 'withShorthands',
    value: function withShorthands(attributes, shorthandsMapping, merge) {
      var shorthandsKeys = Object.keys(shorthandsMapping);
      var shorthands = shorthandsKeys.filter(function (value) {
        return value in attributes;
      });
      if (!shorthands.length) {
        return attributes;
      }
      var attrCopy = omit(attributes, shorthandsKeys);
      shorthands.forEach(function (shorthand) {
        var prop = shorthandsMapping[shorthand];
        if (prop in attrCopy) {
          attrCopy[prop] = merge(attrCopy[prop], shorthand);
        } else {
          attrCopy[prop] = shorthand;
        }
      });
      return attrCopy;
    }
  }, {
    key: 'getListeners',
    value: function getListeners(attributes) {
      var listeners = {};
      for (var attribute in attributes) {
        if (this.isEventAttribute(attribute)) {
          var event = attribute[2].toLocaleLowerCase() + attribute.slice(3);
          listeners[event] = attributes[attribute];
        }
      }
      return listeners;
    }
  }, {
    key: 'isEventAttribute',
    value: function isEventAttribute(attribute) {
      return attribute.startsWith('on') && attribute.charCodeAt(2) <= 90;
    }
  }]);

  return JsxProcessor;
}();

/**
 * Converts any value to a flat array.
 */


function normalizeChildren(children) {
  if (children instanceof Array) {
    var result = [];
    for (var child of children) {
      if (child && child.toArray) {
        result = result.concat(normalizeChildren(child.toArray()));
      } else if (child instanceof Array) {
        result = result.concat(normalizeChildren(child));
      } else {
        result.push(child);
      }
    }
    return result;
  }
  return [children];
}

/**
 * @param {string[]} textArray
 * @param {boolean} markupEnabled
 */
function joinTextContent(textArray, markupEnabled) {
  if (!textArray) {
    return null;
  }
  if (markupEnabled) {
    return textArray.map(function (str) {
      return str + '';
    }).join('').replace(/\s+/g, ' ').replace(/\s*<br\s*\/>\s*/g, '<br/>');
  }
  return textArray.join('');
}

var JSX = {

  /** @type {unique Symbol} */
  jsxFactory: Symbol('jsxFactory'),

  /** @type {unique Symbol} */
  jsxType: Symbol('jsxType'),

  /** @param {JsxProcessor} jsxProcessor */
  install: function (jsxProcessor) {
    this.processor = jsxProcessor;
  },
  createElement: function () {
    return this.processor.createElement.apply(this.processor, arguments);
  }
};

function select(array, selector, deep, widgetCollection) {
  if (!array || array.length === 0) {
    return [];
  }
  if (selector === '*' && !deep) {
    return array.concat();
  }
  var filter = getFilter(selector, widgetCollection);
  if (deep) {
    return deepSelect([], array, filter);
  }
  return array.filter(filter);
}

function createSelectorArray(selector, host) {
  if (!selector) {
    return ['*'];
  }
  if (selector instanceof Function) {
    return [selector];
  }
  var result = selector.split('>').map(function (str) {
    return str.trim();
  });
  var rootIndex = result.indexOf(':host');
  if (rootIndex !== -1) {
    result[rootIndex] = host;
  }
  return result;
}

function getSelectorSpecificity(selectorArray) {
  return selectorArray.filter(isIdSelector).length * 100 + selectorArray.filter(isClassSelector).length * 10 + selectorArray.filter(isTypeSelector).length;
}

function isTypeSelector(selector) {
  return selector !== '*' && !isIdSelector(selector) && !isClassSelector(selector);
}

function isClassSelector(selector) {
  return selector[0] === '.' || selector[0] === ':';
}

function isIdSelector(selector) {
  return selector[0] === '#';
}

function deepSelect(result, iterable, filter) {
  for (var widget of iterable) {
    if (filter(widget)) {
      result.push(widget);
    }
    var children = widget.children ? widget.children() : null;
    if (children instanceof WidgetCollection && children.length) {
      deepSelect(result, children, filter);
    }
  }
  return result;
}

function getFilter(selector, widgetCollection) {
  var matches = {};
  var filter = isFilter(selector) ? selector : createMatcher(selector, widgetCollection);
  return function (widget, index) {
    if (matches[widget.cid]) {
      return false;
    }
    if (filter(widget, index, widgetCollection)) {
      matches[widget.cid] = true;
      return true;
    }
    return false;
  };
}

function createMatcher(selectorArg, widgetCollection) {
  var selector = selectorArg;
  if (selector instanceof Array) {
    if (selector.length === 1) {
      selector = selector[0];
    } else {
      return createChildMatcher(selector, widgetCollection);
    }
  }
  if (selector instanceof Function && selector[JSX.jsxType]) {
    return function (widget) {
      return widget[JSX.jsxType] === selector;
    };
  }
  if (selector instanceof Function) {
    return function (widget) {
      return widget instanceof selector;
    };
  }
  if (selector instanceof NativeObject) {
    return function (widget) {
      return widget === selector;
    };
  }
  if (selector.indexOf('>') !== -1) {
    return createChildMatcher(createSelectorArray(selector, widgetCollection.host), widgetCollection);
  }
  if (selector.charAt(0) === '#') {
    var expectedId = selector.slice(1);
    return function (widget) {
      return expectedId === widget.id;
    };
  }
  if (selector.charAt(0) === '.') {
    var expectedClass = selector.slice(1);
    return function (widget) {
      return widget.classList.indexOf(expectedClass) !== -1;
    };
  }
  if (selector === '*') {
    return function () {
      return true;
    };
  }
  return function (widget) {
    return selector === widget.constructor.name || selector === (widget[JSX.jsxType] ? widget[JSX.jsxType].name : false);
  };
}

function createChildMatcher(selectors, widgetCollection) {
  var matchers = selectors.map(function (selector) {
    return createMatcher(selector, widgetCollection);
  }).reverse();
  return function (widget) {
    var current = widget;
    for (var i = 0; i < matchers.length; i++) {
      if (!current || !matchers[i](current)) {
        return false;
      }
      current = current.parent();
    }
    return true;
  };
}

function isFilter(selector) {
  return selector instanceof Function && !isWidgetConstructor(selector) && !selector[JSX.jsxType];
}

function isWidgetConstructor(fn) {
  var proto = fn.prototype;
  while (proto) {
    // Use NativeObject since importing Widget would causes circulary module dependency issues
    if (proto === NativeObject.prototype) {
      return true;
    }
    proto = Object.getPrototypeOf(proto);
  }
  return false;
}

/** @typedef {import('./Widget').default} Widget */
/** @typedef {Widget[]|WidgetCollection} Widgets */
/** @typedef {string|Function} Selector */

var WidgetCollection = function () {

  /**
   * @param {Widgets=} collection
   * @param {{selector?: Selector, deep?: boolean, origin?: Widget|WidgetCollection}} internals
   */
  function WidgetCollection(collection) {
    var { selector: selector, deep: deep, origin: origin } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, WidgetCollection);

    if (selector && !origin) {
      throw new Error('WidgetCollection can not be constructed with an selector but no origin');
    }
    var arr = collection instanceof WidgetCollection ? collection.toArray() : collection;
    Object.defineProperty(this, '_host', { enumerable: false, writable: false, value: getHost(origin) });
    /** @type {Widget[]} */
    var _array = select(arr, selector || '*', deep, origin instanceof WidgetCollection ? origin : this);
    Object.defineProperty(this, '_array', { enumerable: false, writable: false, value: _array });
    for (var i = 0; i < _array.length; i++) {
      this[i] = _array[i];
    }
  }

  _createClass(WidgetCollection, [{
    key: 'first',
    value: function first(selector) {
      if (selector) {
        return this.filter(selector).first();
      }
      return this._array[0];
    }
  }, {
    key: 'last',
    value: function last(selector) {
      if (selector) {
        return this.filter(selector).last();
      }
      return this._array[this._array.length - 1];
    }
  }, {
    key: 'only',
    value: function only(selector) {
      if (selector) {
        return this.filter(selector).only();
      }
      if (this._array.length !== 1) {
        throw new Error('Expected exactly one match, but found ' + this.length);
      }
      return this._array[0];
    }
  }, {
    key: 'toArray',
    value: function toArray() {
      return this._array.concat();
    }
  }, {
    key: 'forEach',
    value: function forEach(callback) {
      var _this8 = this;

      this._array.forEach(function (value, index) {
        return callback(value, index, _this8);
      });
    }
  }, {
    key: 'map',
    value: function map(callback) {
      var _this9 = this;

      return this._array.map(function (value, index) {
        return callback(value, index, _this9);
      });
    }
  }, {
    key: 'indexOf',
    value: function indexOf(needle) {
      return this._array.indexOf(needle);
    }
  }, {
    key: 'slice',
    value: function slice() {
      return new WidgetCollection(this._array.slice.apply(this._array, arguments), { origin: this });
    }
  }, {
    key: 'concat',
    value: function concat() {
      var added = Array.prototype.map.call(arguments, function (part) {
        return part instanceof WidgetCollection ? part.toArray() : part;
      });
      return new WidgetCollection(this._array.concat.apply(this._array, added), { origin: this });
    }
  }, {
    key: 'includes',
    value: function includes(needle) {
      return this._array.indexOf(needle) !== -1;
    }
  }, {
    key: 'filter',
    value: function filter(selector) {
      return new WidgetCollection(this._array, { selector: selector, origin: this });
    }
  }, {
    key: 'parent',
    value: function parent() {
      var result = [];
      for (var widget of this._array) {
        var parent = widget.parent();
        if (parent && result.indexOf(parent) === -1) {
          result.push(parent);
        }
      }
      if (result.length) {
        return new WidgetCollection(result, { origin: this });
      }
    }
  }, {
    key: 'children',
    value: function children(selector) {
      var result = [];
      for (var widget of this._array) {
        if (widget.children instanceof Function) {
          result.push.apply(result, widget.children());
        }
      }
      return new WidgetCollection(result, { selector: selector, origin: this });
    }
  }, {
    key: 'appendTo',
    value: function appendTo(parent) {
      parent.append(this);
    }
  }, {
    key: 'set',
    value: function set() {
      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      this._array.forEach(function (widget) {
        return widget.set(...args);
      });
      return this;
    }
  }, {
    key: 'on',
    value: function on() {
      for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      this._array.forEach(function (widget) {
        return widget.on(...args);
      });
      return this;
    }
  }, {
    key: 'off',
    value: function off() {
      for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      this._array.forEach(function (widget) {
        return widget.off(...args);
      });
      return this;
    }
  }, {
    key: 'once',
    value: function once() {
      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      this._array.forEach(function (widget) {
        return widget.once(...args);
      });
      return this;
    }
  }, {
    key: 'trigger',
    value: function trigger() {
      for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }

      this._array.forEach(function (widget) {
        return widget.trigger(...args);
      });
      return this;
    }
  }, {
    key: 'animate',
    value: function animate() {
      for (var _len9 = arguments.length, args = Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }

      this._array.forEach(function (widget) {
        return widget.animate(...args);
      });
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      this._array.forEach(function (widget) {
        return widget.dispose();
      });
    }
  }, {
    key: 'detach',
    value: function detach() {
      this._array.forEach(function (widget) {
        return widget.detach();
      });
    }
  }, {
    key: 'toString',
    value: function toString() {
      if (this._array.length < 4) {
        return 'WidgetCollection { ' + this._array.join(', ') + ' }';
      }
      return 'WidgetCollection {\n' + this._array.map(function (entry) {
        return '  ' + entry;
      }).join(',\n') + '\n}';
    }
  }, {
    key: Symbol.iterator,
    value: function () {
      var _this10 = this;

      var index = 0;
      return {
        next: function () {
          return index < _this10.length ? { value: _this10[index++], done: false } : { done: true };
        }
      };
    }
  }, {
    key: 'length',
    get: function () {
      return this._array.length;
    }
  }, {
    key: 'host',
    get: function () {
      return this._host;
    }
  }]);

  return WidgetCollection;
}();

WidgetCollection.prototype[JSX.jsxFactory] = createElement;

/** @this {import("./JsxProcessor").default} */
function createElement(Type, attributes) {
  if (Object.keys(this.withoutChildren(attributes)).length) {
    throw new Error('JSX: WidgetCollection can not have attributes');
  }
  return new Type(this.getChildren(attributes) || []);
}

function getHost(origin) {
  if (origin instanceof WidgetCollection) {
    return origin.host;
  }
  return origin || null;
}

function colorArrayToString(array) {
  var r = array[0];
  var g = array[1];
  var b = array[2];
  var a = array.length === 3 ? 1 : Math.round(array[3] * 100 / 255) / 100;
  return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + a + ')';
}

function colorStringToArray(str) {
  if (str === 'transparent') {
    return [0, 0, 0, 0];
  }
  // #xxxxxx and #xxxxxxxx
  if (/^#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})?$/.test(str)) {
    return [parseInt(RegExp.$1, 16), parseInt(RegExp.$2, 16), parseInt(RegExp.$3, 16), RegExp.$4 === '' ? 255 : parseInt(RegExp.$4, 16)];
  }
  // #xxx and #xxxx
  if (/^#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])?$/.test(str)) {
    return [parseInt(RegExp.$1, 16) * 17, parseInt(RegExp.$2, 16) * 17, parseInt(RegExp.$3, 16) * 17, RegExp.$4 === '' ? 255 : parseInt(RegExp.$4, 16) * 17];
  }
  // #rgb(r, g, b)
  if (/^rgb\s*\(\s*([+-]?[0-9]+)\s*,\s*([+-]?[0-9]+)\s*,\s*([+-]?[0-9]+)\s*\)$/.test(str)) {
    return [Math.max(0, Math.min(255, parseInt(RegExp.$1))), Math.max(0, Math.min(255, parseInt(RegExp.$2))), Math.max(0, Math.min(255, parseInt(RegExp.$3))), 255];
  }
  // rgba(r, g, b, a)
  if (/^rgba\s*\(\s*([+-]?[0-9]+)\s*,\s*([+-]?[0-9]+)\s*,\s*([+-]?[0-9]+)\s*,\s*([+-]?([0-9]*\.)?[0-9]+)\s*\)$/.test(str)) {
    return [Math.max(0, Math.min(255, parseInt(RegExp.$1))), Math.max(0, Math.min(255, parseInt(RegExp.$2))), Math.max(0, Math.min(255, parseInt(RegExp.$3))), Math.round(Math.max(0, Math.min(1, parseFloat(RegExp.$4))) * 255)];
  }
  // named colors
  if (str in NAMES) {
    var rgb = NAMES[str];
    return [rgb[0], rgb[1], rgb[2], 255];
  }
  throw new Error(toValueString(str) + ' is not a valid color');
}

/*
 * Basic color keywords as defined in CSS 3
 * See http://www.w3.org/TR/css3-color/#html4
 */
var NAMES = {
  black: [0, 0, 0],
  silver: [192, 192, 192],
  gray: [128, 128, 128],
  white: [255, 255, 255],
  maroon: [128, 0, 0],
  red: [255, 0, 0],
  purple: [128, 0, 128],
  fuchsia: [255, 0, 255],
  green: [0, 128, 0],
  lime: [0, 255, 0],
  olive: [128, 128, 0],
  yellow: [255, 255, 0],
  navy: [0, 0, 128],
  blue: [0, 0, 255],
  teal: [0, 128, 128],
  aqua: [0, 255, 255],
  transparent: [0, 0, 0, 0]
};

var Color = function () {
  _createClass(Color, null, [{
    key: 'isColorValue',
    value: function isColorValue(value) {
      return value == null || value === 'initial' || Color.isValidColorValue(value);
    }
  }, {
    key: 'isValidColorValue',
    value: function isValidColorValue(value) {
      try {
        Color.from(value);
        return true;
      } catch (ex) {
        return false;
      }
    }
  }, {
    key: 'from',
    value: function from(value) {
      if (value instanceof Color) {
        return value;
      }
      if (value instanceof Array) {
        return arrayToColorInstance(value);
      }
      if (value instanceof Object) {
        return colorLikeObjectToColorInstance(value);
      }
      if (typeof value === 'string') {
        return arrayToColorInstance(colorStringToArray(value));
      }
      throw new Error('Not a valid ColorValue: ' + toValueString(value));
    }
  }]);

  function Color(red, green, blue) {
    var alpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 255;

    _classCallCheck(this, Color);

    if (arguments.length > 4) {
      throw new Error('Too many arguments');
    }
    if (arguments.length < 3) {
      throw new Error('Not enough arguments');
    }
    setChannel(this, 'red', red);
    setChannel(this, 'green', green);
    setChannel(this, 'blue', blue);
    setChannel(this, 'alpha', alpha);
  }

  _createClass(Color, [{
    key: 'toString',
    value: function toString() {
      if (this.alpha === 255) {
        return 'rgb(' + this.red + ', ' + this.green + ', ' + this.blue + ')';
      }
      return 'rgba(' + this.red + ', ' + this.green + ', ' + this.blue + ', ' + Math.round(this.alpha * 100 / 255) / 100 + ')';
    }
  }, {
    key: 'toArray',
    value: function toArray() {
      return [this.red, this.green, this.blue, this.alpha];
    }
  }, {
    key: 'equals',
    value: function equals(value) {
      if (!(value instanceof Color)) {
        return false;
      }
      return value.red === this.red && value.green === this.green && value.blue === this.blue && value.alpha === this.alpha;
    }
  }]);

  return Color;
}();

Color.prototype[equals$1] = Color.prototype.equals;

Object.keys(NAMES).forEach(function (name) {
  var value = void 0; // create lazy to avoid circular dependency issues
  Object.defineProperty(Color, name, {
    get: function () {
      if (!value) {
        value = Color.from(NAMES[name]);
      }
      return value;
    }
  });
});

function setChannel(color, channel, value) {
  checkNumber(value, [0, 255], 'Invalid color value ' + toValueString(channel));
  Object.defineProperty(color, channel, { enumerable: true, value: Math.round(value) });
}

function colorLikeObjectToColorInstance(value) {
  checkProperty(value, 'red');
  checkProperty(value, 'green');
  checkProperty(value, 'blue');
  if ('alpha' in value) {
    return new Color(value.red, value.green, value.blue, value.alpha);
  }
  return new Color(value.red, value.green, value.blue);
}

function arrayToColorInstance(value) {
  if (value.length < 3) {
    throw new Error('Color array too short');
  }
  if (value.length > 4) {
    throw new Error('Color array too long');
  }
  return new Color(value[0], value[1], value[2], value.length === 4 ? value[3] : 255);
}

function checkProperty(object, prop) {
  if (!(prop in object)) {
    throw new Error('Color-like object missing ' + prop + ' value');
  }
}

var Image = function () {
  _createClass(Image, null, [{
    key: 'isImageValue',


    /**
     * @param {any} value
     */
    value: function isImageValue(value) {
      return value == null || value === 'initial' || Image.isValidImageValue(value);
    }

    /**
     * @param {any} value
     */

  }, {
    key: 'isValidImageValue',
    value: function isValidImageValue(value) {
      try {
        Image.from(value);
        return true;
      } catch (ex) {
        return false;
      }
    }

    /**
     * @param {any} value
     */

  }, {
    key: 'from',
    value: function from(value) {
      if (value instanceof Image) {
        if (getNativeObject(value.src) && getNativeObject(value.src).isDisposed()) {
          throw new Error('ImageBitmap is closed');
        }
        return value;
      }
      if (typeof value === 'string' || getNativeObject(value) || getBytes(value)) {
        return new Image({ src: value });
      }
      if (value instanceof Object) {
        if (hasInconsistentDimensions(value)) {
          hint(this === Image ? 'Image.from' : this, 'image "scale" is ignored when "width" and/or "height" are set to a number');
          return new Image(Object.assign({}, value, { scale: 'auto' }));
        }
        return new Image(value);
      }
      throw new Error(toValueString(value) + ' is not a valid ImageValue');
    }

    /**
     * @param {ImageLikeObject} imageLike
     */

  }]);

  function Image(imageLike) {
    _classCallCheck(this, Image);

    if (arguments.length < 1) {
      throw new Error('Not enough arguments');
    }
    checkConsistentDimensions(imageLike);
    setSrc(this, imageLike);
    setDimension(this, 'width', hasExplicit(imageLike, 'width') ? imageLike.width : 'auto');
    setDimension(this, 'height', hasExplicit(imageLike, 'height') ? imageLike.height : 'auto');
    setScale(this, imageLike);
  }

  _createClass(Image, [{
    key: 'equals',
    value: function equals(value) {
      if (!(value instanceof Image)) {
        return false;
      }
      return value.src === this.src && value.scale === this.scale && value.width === this.width && value.height === this.height;
    }
  }]);

  return Image;
}();

Image.prototype[equals$1] = Image.prototype.equals;

/** @type {number|Auto} */
var initDimension = 0;
/** @type {string|object} */
var initSrc = '';
Object.defineProperty(Image.prototype, 'src', { value: initSrc });
Object.defineProperty(Image.prototype, 'width', { value: initDimension });
Object.defineProperty(Image.prototype, 'height', { value: initDimension });
Object.defineProperty(Image.prototype, 'scale', { value: initDimension });

/**
 * @param {Image} image
 * @param {ImageLikeObject} imageLike
 */

function setScale(image, imageLike) {
  var scale = hasExplicit(imageLike, 'scale') ? imageLike.scale : 'auto';
  if (imageLike.scale == null && !hasExplicit(imageLike, 'width') && !hasExplicit(imageLike, 'height') && typeof imageLike.src === 'string') {
    var autoScaleMatch = /@([0-9]\.?[0-9]*)x/.exec(imageLike.src.split('/').pop());
    if (autoScaleMatch && autoScaleMatch[1]) {
      scale = parseFloat(autoScaleMatch[1]);
    }
  }
  setDimension(image, 'scale', scale);
}

/**
 * @param {ImageLikeObject} imageLike
 * @param {keyof ImageLikeObject} property
 */
function hasExplicit(imageLike, property) {
  return property in imageLike && imageLike[property] !== 'auto' && imageLike[property] != null;
}

/**
 * @param {Image} image
 * @param {ImageLikeObject} imageLike
 */
function setSrc(image, imageLike) {
  checkSrc(imageLike);
  if (getNativeObject(imageLike.src) || getBytes(imageLike.src)) {
    Object.defineProperty(image, 'src', { enumerable: true, value: imageLike.src });
  } else {
    var path = void 0;
    try {
      path = normalizePathUrl(imageLike.src);
    } catch (err) {
      throw new Error('Invalid image "src": ' + err.message);
    }
    Object.defineProperty(image, 'src', { enumerable: true, value: path });
  }
}

/**
 * @param {ImageLikeObject} imageLike
 */
function checkSrc(imageLike) {
  if (!('src' in imageLike)) {
    throw new Error('Image "src" missing');
  }
  if (getNativeObject(imageLike.src)) {
    if (getNativeObject(imageLike.src).isDisposed()) {
      throw new Error('ImageBitmap is closed');
    }
  } else if (typeof imageLike.src === 'string') {
    if (!imageLike.src.length) {
      throw new Error('Image "src" must not be empty');
    }
  } else if (getBytes(imageLike.src)) {
    if (!imageLike.src.size) {
      throw new Error('Image "src" must not be empty');
    }
  } else {
    throw new Error('Image "src" ' + toValueString(imageLike.src) + ' must be a string, ImageBitmap or Blob');
  }
}

/**
 * @param {ImageLikeObject} imageLike
 */
function checkConsistentDimensions(imageLike) {
  if (hasInconsistentDimensions(imageLike)) {
    throw new Error('Image "scale" cannot be used with "width" and "height"');
  }
}

/**
 * @param {ImageLikeObject} imageLike
 */
function hasInconsistentDimensions(imageLike) {
  return hasExplicit(imageLike, 'scale') && (hasExplicit(imageLike, 'width') || hasExplicit(imageLike, 'height'));
}

/**
 * @param {Image} image
 * @param {keyof Image} property
 * @param {number|'auto'} value
 */
function setDimension(image, property, value) {
  if (value !== 'auto') {
    checkNumber(value, [0, Infinity], 'Image "' + property + '" is not a dimension');
  }
  Object.defineProperty(image, property, { enumerable: true, value: value });
}

var FONT_STYLES = ['italic', 'normal'];
var FONT_WEIGHTS = ['black', 'bold', 'medium', 'thin', 'light', 'normal'];

function fontStringToObject(str) {
  var result = { family: [], size: 0, style: 'normal', weight: 'normal' };
  var parts = str.split(/(?:\s|^)\d+px(?:\s|$)/);
  checkTruthy(parts.length === 2, 'Invalid font syntax');
  var [sizePrefix, sizeSuffix] = parts;
  result.size = parseInt(/(?:\s|^)(\d+)px(?:\s|$)/.exec(str)[1], 10);
  parseSizePrefix(result, sizePrefix);
  parseFamily(result, sizeSuffix);
  return result;
}

function fontObjectToString(font) {
  return [font.style === 'normal' ? '' : font.style, font.weight === 'normal' ? '' : font.weight, font.size + 'px', font.family.join(', ')].filter(function (str) {
    return !!str;
  }).join(' ').trim();
}

function validateFamily(name) {
  var valid = /(?:^\s*[^"']+\s*$)|(?:^\s*"[^"']+"\s*$)|(?:^\s*'[^"']+'\s*$)/.exec(name);
  checkTruthy(valid, 'Invalid font family: ' + name);
}

function validateStyle(style) {
  checkTruthy(isStyle(style), 'Invalid font style ' + style);
}

function validateWeight(weight) {
  checkTruthy(isWeight(weight), 'Invalid font weight ' + weight);
}

function normalizeFamily(value) {
  return (/^\s*["']?([^"']*)/.exec(value)[1].trim()
  );
}

function normalizeWeight(value) {
  return value.trim();
}

function normalizeStyle(value) {
  return value.trim();
}

function parseSizePrefix(fontObj, prefix) {
  var prefixes = prefix.trim().split(/\s+/);
  checkTruthy(prefixes.length <= 2, 'Too many font size prefixes');
  var { style: style, weight: weight } = parseSizePrefixes(prefixes);
  fontObj.style = style;
  fontObj.weight = weight;
}

function parseSizePrefixes(prefixes) {
  // [styleOrWeight]
  // [style, weight]
  if (prefixes.length === 1) {
    var prefix = prefixes[0];
    if (isStyle(prefix)) {
      return { weight: 'normal', style: normalizeStyle(prefix) };
    } else if (isWeight(prefix)) {
      return { weight: normalizeWeight(prefix), style: 'normal' };
    } else if (prefix === 'normal' || prefix === '') {
      return { style: 'normal', weight: 'normal' };
    }
    throw new Error('Invalid font style or weight ' + prefix);
  } else if (prefixes.length === 2) {
    validateStyle(prefixes[0]);
    validateWeight(prefixes[1]);
    return { style: normalizeStyle(prefixes[0]), weight: normalizeWeight(prefixes[1]) };
  }
}

function isStyle(value) {
  return typeof value === 'string' && FONT_STYLES.includes(value.trim());
}

function isWeight(value) {
  return typeof value === 'string' && FONT_WEIGHTS.includes(value.trim());
}

function parseFamily(fontArr, family) {
  // NOTE: Currently family is optional to allow for default fonts, but this is
  //       not CSS font syntax. See https://github.com/eclipsesource/tabris-js/issues/24
  (family ? family.split(',') : []).forEach(function (name) {
    validateFamily(name);
    fontArr.family.push(normalizeFamily(name));
  });
}

function checkTruthy(value, message) {
  if (!value) {
    throw new Error(message);
  }
}

var Font = function () {
  _createClass(Font, null, [{
    key: 'isFontValue',
    value: function isFontValue(value) {
      return value == null || value === 'initial' || Font.isValidFontValue(value);
    }
  }, {
    key: 'isValidFontValue',
    value: function isValidFontValue(value) {
      try {
        Font.from(value);
        return true;
      } catch (ex) {
        return false;
      }
    }
  }, {
    key: 'from',
    value: function from(value) {
      if (value instanceof Font) {
        return value;
      }
      if (value instanceof Object) {
        return fontLikeObjectToFontInstance(value);
      }
      if (typeof value === 'string') {
        return fontLikeObjectToFontInstance(fontStringToObject(value));
      }
      throw new Error(toValueString(value) + ' is not a valid FontValue');
    }
  }, {
    key: 'sansSerif',
    get: function () {
      return 'sans-serif';
    }
  }, {
    key: 'serif',
    get: function () {
      return 'serif';
    }
  }, {
    key: 'monospace',
    get: function () {
      return 'monospace';
    }
  }, {
    key: 'condensed',
    get: function () {
      return 'condensed';
    }
  }]);

  function Font(size) {
    var family = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var weight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'normal';
    var style = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'normal';

    _classCallCheck(this, Font);

    if (arguments.length < 1) {
      throw new Error('Not enough arguments');
    }
    setSize(this, size);
    setFamily(this, family);
    setWeight(this, weight);
    setStyle(this, style);
  }

  _createClass(Font, [{
    key: 'toString',
    value: function toString() {
      return fontObjectToString(this);
    }
  }, {
    key: 'equals',
    value: function equals(value) {
      var _this11 = this;

      if (!(value instanceof Font)) {
        return false;
      }
      return value.size === this.size && value.weight === this.weight && value.style === this.style && value.family.length === this.family.length && value.family.every(function (family, index) {
        return _this11.family[index] === family;
      });
    }
  }]);

  return Font;
}();

Font.prototype[equals$1] = Font.prototype.equals;

function setFamily(font, family) {
  family.forEach(validateFamily);
  var value = Object.freeze(family.map(normalizeFamily));
  Object.defineProperty(font, 'family', { enumerable: true, value: value });
}

function setSize(font, value) {
  checkNumber(value, [0, Infinity], 'Invalid font size');
  Object.defineProperty(font, 'size', { enumerable: true, value: value });
}

function setWeight(font, value) {
  validateWeight(value);
  Object.defineProperty(font, 'weight', { enumerable: true, value: normalizeWeight(value) });
}

function setStyle(font, value) {
  validateStyle(value);
  Object.defineProperty(font, 'style', { enumerable: true, value: normalizeStyle(value) });
}

function fontLikeObjectToFontInstance(value) {
  checkProperty$1(value, 'size');
  return new Font(value.size, value.family || [], value.weight || 'normal', value.style || 'normal');
}

function checkProperty$1(object, prop) {
  if (!(prop in object)) {
    throw new Error('Font-like object missing ' + prop + ' value');
  }
}

var Percent = function () {
  _createClass(Percent, null, [{
    key: 'isValidPercentValue',
    value: function isValidPercentValue(value) {
      try {
        Percent.from(value);
        return true;
      } catch (ex) {
        return false;
      }
    }
  }, {
    key: 'from',
    value: function from(value) {
      if (value instanceof Percent) {
        return value;
      }
      if (value instanceof Object) {
        return percentLikeObjectToPercentInstance(value);
      }
      if (typeof value === 'string') {
        checkPercentString(value);
        return new Percent(percentNumberFromString(value));
      }
      throw new Error(toValueString(value) + ' is not a valid PercentValue');
    }
  }]);

  function Percent(percent) {
    _classCallCheck(this, Percent);

    if (arguments.length < 1) {
      throw new Error('Not enough arguments');
    }
    checkNumber(percent, [-Infinity, Infinity], 'Invalid Percent');
    Object.defineProperty(this, 'percent', { enumerable: true, value: percent });
  }

  _createClass(Percent, [{
    key: 'toString',
    value: function toString() {
      return this.percent + '%';
    }
  }, {
    key: 'valueOf',
    value: function valueOf() {
      return this.percent;
    }
  }]);

  return Percent;
}();

function percentLikeObjectToPercentInstance(value) {
  checkProperty$3(value, 'percent');
  return new Percent(value.percent);
}

function checkPercentString(value) {
  if (!/%$/.test(value) || isNaN(percentNumberFromString(value))) {
    throw new Error('Invalid percent string ' + value + ': It must be a number followed by "%".');
  }
  checkNumber(percentNumberFromString(value), [-Infinity, Infinity], 'Invalid percent string ' + value);
}

function percentNumberFromString(value) {
  return parseInt(value.replace(/%$/, ''));
}

function checkProperty$3(object, prop) {
  if (!(prop in object)) {
    throw new Error('Percent-like object missing ' + prop + ' value');
  }
}

var SIDES = ['left', 'top', 'right', 'bottom'];

var LinearGradient = function () {
  _createClass(LinearGradient, null, [{
    key: 'isLinearGradientValue',


    /**
     * @param {any} value
     * @returns {boolean}
     */
    value: function isLinearGradientValue(value) {
      return value == null || value === 'initial' || LinearGradient.isValidLinearGradientValue(value);
    }

    /**
     * @param {any} value
     * @returns {boolean}
     */

  }, {
    key: 'isValidLinearGradientValue',
    value: function isValidLinearGradientValue(value) {
      try {
        LinearGradient.from(value);
        return true;
      } catch (ex) {
        return false;
      }
    }

    /**
     * @param {any} value
     * @returns {LinearGradient}
     */

  }, {
    key: 'from',
    value: function from(value) {
      if (value instanceof LinearGradient) {
        return value;
      }
      if (value instanceof Object) {
        return gradientLikeObjectToGradientInstance(value);
      }
      if (typeof value === 'string') {
        return gradientLikeObjectToGradientInstance(gradientStringToObject(value));
      }
      throw new Error(toValueString(value) + ' is not a valid LinearGradient');
    }

    /**
     * @param {Array<Color|[Color, Percent]>} colorStops
     * @param {number=} direction
     */

  }]);

  function LinearGradient(colorStops, direction) {
    _classCallCheck(this, LinearGradient);

    if (arguments.length < 1) {
      throw new Error('Not enough arguments');
    }
    var directionDegrees = 180;
    if (arguments.length > 1) {
      checkNumber(direction, [-Infinity, Infinity], 'Invalid direction angle');
      directionDegrees = direction;
    }
    checkColorStops(colorStops);
    Object.defineProperty(this, 'colorStops', { enumerable: true, value: Object.freeze(colorStops) });
    Object.defineProperty(this, 'direction', { enumerable: true, value: directionDegrees });
  }

  _createClass(LinearGradient, [{
    key: 'toString',
    value: function toString() {
      var directionPart = this.direction ? this.direction + 'deg, ' : '';
      var colorStopsPart = this.colorStops.join(', ');
      return 'linear-gradient(' + directionPart + colorStopsPart + ')';
    }
  }, {
    key: 'equals',
    value: function equals(value) {
      var _this12 = this;

      if (!(value instanceof LinearGradient)) {
        return false;
      }
      return value.direction === this.direction && value.colorStops.length === this.colorStops.length && value.colorStops.every(function (stop, index) {
        return equalColorStops(stop, _this12.colorStops[index]);
      });
    }
  }]);

  return LinearGradient;
}();

Object.defineProperty(LinearGradient.prototype, 'direction', { value: 0 });
Object.defineProperty(LinearGradient.prototype, 'colorStops', { value: /** @type {Array<Color|[Color, Percent]>} */[] });

function equalColorStops(a, b) {
  if (a instanceof Color && b instanceof Color) {
    return a.equals(b);
  }
  if (a instanceof Array && b instanceof Array) {
    return a[0].equals(b[0]) && a[1].percent === b[1].percent;
  }
  return false;
}

function gradientStringToObject(css) {
  var gradient = css.trim();
  var result = { colorStops: [] };
  if (gradient.indexOf('linear-gradient') !== 0) {
    throw new Error('Argument ' + toValueString(css) + ' is not a valid linear gradient definition');
  }
  gradient = gradient.substring(15).trim();
  if (gradient.indexOf('(') !== 0 && gradient.lastIndexOf(')') !== gradient.length - 1) {
    throw new Error('Argument ' + toValueString(css) + ' is not a valid linear gradient definition');
  }
  gradient = gradient.substring(1, gradient.length - 1).trim();
  gradient = encodeRGBColors(gradient);
  var gradientParts = gradient.split(',');
  // starting point
  var startingPoint = gradientParts[0].trim();
  var colorStopPartIndex = 1;
  if (startingPoint.indexOf('to') === 0) {
    startingPoint = startingPoint.substring(3).trim();
    checkSide(startingPoint);
    result.direction = directionToDegrees(startingPoint);
  } else if (startingPoint.indexOf('deg') === startingPoint.length - 3) {
    result.direction = parseInt(startingPoint.substring(0, startingPoint.length - 3), 10);
  } else {
    colorStopPartIndex = 0;
  }
  // color stop
  for (var i = colorStopPartIndex; i < gradientParts.length; i++) {
    var colorStopParts = gradientParts[i].trim().split(' ');
    if (colorStopParts.length === 1 && colorStopParts[0] !== '') {
      var color = decodeRGBColor(colorStopParts[0]);
      result.colorStops.push(color);
    } else if (colorStopParts.length === 2) {
      var _color = decodeRGBColor(colorStopParts[0]);
      var offset = colorStopParts[1];
      result.colorStops.push([_color, offset]);
    } else {
      throw new Error('Invalid color stop value ' + toValueString(colorStopParts));
    }
  }
  return result;
}

function encodeRGBColors(gradient) {
  var result = '';
  var escaping = false;
  for (var i = 0; i < gradient.length; i++) {
    if (result.endsWith('rgb')) {
      escaping = true;
    }
    if (escaping && result.endsWith(')')) {
      escaping = false;
    }
    var currentChar = gradient.charAt(i);
    if (escaping) {
      if (currentChar === ',') {
        result += '&#44';
      } else if (currentChar !== ' ') {
        result += currentChar;
      }
    } else {
      result += currentChar;
    }
  }
  return result;
}

function decodeRGBColor(color) {
  return color.replace(/&#44/g, ',');
}

function gradientLikeObjectToGradientInstance(value) {
  checkProperty$2(value, 'colorStops');
  if ('direction' in value) {
    var { direction: direction } = value;
    if (typeof direction === 'string') {
      checkSide(direction);
      direction = directionToDegrees(direction);
    }
    return new LinearGradient(value.colorStops.map(translateGradientLikeColorStop), direction);
  }
  return new LinearGradient(value.colorStops.map(translateGradientLikeColorStop));
}

function translateGradientLikeColorStop(stop) {
  if (Color.isValidColorValue(stop)) {
    return Color.from(stop);
  }
  if (stop instanceof Array) {
    if (stop.length !== 2) {
      throwInvalidGradientLikeColorStop(stop);
    }
    return [Color.from(stop[0]), Percent.from(stop[1])];
  }
  throwInvalidGradientLikeColorStop(stop);
}

function checkProperty$2(object, prop) {
  if (!(prop in object)) {
    throw new Error('LinearGradient-like object missing ' + prop + ' value');
  }
}

function directionToDegrees(direction) {
  return { left: 270, top: 0, right: 90, bottom: 180 }[direction];
}

function checkColorStops(colorStops) {
  if (!(colorStops instanceof Array)) {
    throw new Error('colorStops must be an array');
  }
  if (colorStops.length <= 0) {
    throw new Error('colorStops must not be empty');
  }
  colorStops.forEach(checkColorStop);
}

function checkColorStop(colorStop) {
  if (!(colorStop instanceof Array) && !(colorStop instanceof Color)) {
    throwInvalidColorStop(colorStop);
  }
  if (colorStop instanceof Array) {
    if (colorStop.length !== 2 || !(colorStop[0] instanceof Color) || !(colorStop[1] instanceof Percent)) {
      throwInvalidColorStop(colorStop);
    }
  }
}

function throwInvalidColorStop(colorStop) {
  throw new Error(toValueString(colorStop) + ' is not a valid color stop. It must be either [Color, Percent] or Color.');
}

function throwInvalidGradientLikeColorStop(colorStop) {
  throw new Error(toValueString(colorStop) + ' is not a valid color stop. It must be either [ColorValue, Percent] or ColorValue.');
}

function checkSide(value) {
  if (value.indexOf(' ') > -1) {
    throw new Error('Invalid direction "' + value + '". Corners are not supported.');
  }
  if (!SIDES.includes(value)) {
    throw new Error('Invalid direction side "' + value + '". Must be a side (e.g. "left") or a corner (e.g. "left top").');
  }
}

var numberRegex = /^[+-]?([0-9]+|[0-9]*\.[0-9]+)$/;
var transformDefaults = {
  rotation: 0,
  scaleX: 1,
  scaleY: 1,
  translationX: 0,
  translationY: 0,
  translationZ: 0
};

/**
 * @template T
 * @typedef {{
  *   convert?: (value: unknown, context?: NativeObject) => T,
  *   encode?: (value: T, context?: NativeObject) => any,
  *   decode?: (value: any, context?: NativeObject) => T
  * }} PropertyType
  */

/**
 * Note: Primitive types and aliases thereof start lower vase,
 * object types other upper case.
 */

var PropertyTypes = function PropertyTypes() {
  _classCallCheck(this, PropertyTypes);

  var self = this;

  /** @type {PropertyType<any>} */
  this.any = {};

  /** @type {PropertyType<boolean>} */
  this.boolean = {
    convert: function (bool) {
      return !!bool;
    },
    decode: function (value) {
      return value === undefined ? false : value;
    }
  };

  /** @type {PropertyType<string>} */
  this.string = {
    convert: function (str) {
      return str == null ? '' : '' + str;
    },
    decode: function (value) {
      return value === undefined ? '' : value;
    }
  };

  /** @type {PropertyType<number>} */
  this.number = {
    convert: convertToNumber,
    decode: function (value) {
      return value === undefined ? 0 : value;
    }
  };

  /** @type {PropertyType<number>} */
  this.natural = {
    convert: function (value) {
      return Math.max(0, Math.round(convertToNumber(value)));
    },
    decode: function (value) {
      return value === undefined ? 0 : value;
    }
  };

  /** @type {PropertyType<number>} */
  this.integer = {
    convert: function (value) {
      return Math.round(convertToNumber(value));
    },
    decode: function (value) {
      return value === undefined ? 0 : value;
    }
  };

  /** @type {PropertyType<number>} */
  this.fraction = {
    convert: function (value) {
      return Math.max(0, Math.min(1, convertToNumber(value)));
    }
  };

  /** @type {PropertyType<number>} */
  this.dimension = {
    convert: function (value) {
      return Math.max(0, convertToNumber(value));
    },
    decode: function (value) {
      return value === undefined ? 0 : value;
    }
  };

  /** @type {PropertyType<LinearGradient|Color|Image|'initial'>} */
  this.Shader = {
    convert: function (value) {
      if (!value || value === 'initial') {
        return 'initial';
      }
      if (isIntendedLinearGradientValue(value)) {
        return LinearGradient.from(value);
      } else if (Color.isValidColorValue(value)) {
        return Color.from(value);
      } else if (Image.isValidImageValue(value)) {
        return Image.from.call(this, value);
      }
      throw new Error(toValueString(value) + ' must be a valid ImageValue, LinearGradientValue or ColorValue.');
    },
    encode: function (value) {
      if (value === 'initial') {
        return null;
      }
      if (value instanceof LinearGradient) {
        var { colorStops: colorStops, direction: direction } = value;
        return {
          type: 'linearGradient',
          colors: colorStops.map(function (stop) {
            return stop instanceof Color ? [stop.toArray(), null] : [stop[0].toArray(), stop[1].valueOf() / 100];
          }),
          angle: direction
        };
      } else if (value instanceof Color) {
        return { type: 'color', color: value.toArray() };
      } else if (value instanceof Image) {
        return { type: 'image', image: self.ImageValue.encode(value) };
      }
      throw new Error(toValueString(value) + ' must be a LinearGradient or Color instance.');
    }
  }, this.ColorValue = {
    convert: function (value) {
      return !value || value === 'initial' ? 'initial' : Color.from(value);
    },
    encode: function (value) {
      return value === 'initial' ? undefined : value.toArray();
    },
    decode: function (value) {
      return !value ? 'initial' : Color.from(value);
    }
  };

  /** @type {PropertyType<Font|'initial'>} */
  this.FontValue = {
    convert: function (value) {
      return !value || value === 'initial' ? 'initial' : Font.from(value);
    },
    encode: function (value) {
      return value === 'initial' ? undefined : value;
    }
  };

  /** @type {PropertyType<Image|null>} */
  this.ImageValue = {
    convert: function (value) {
      return !value || value === 'initial' ? null : Image.from(value);
    },
    encode: function (value) {
      if (!value) {
        return null;
      }
      var image = Image.from.call(this, value);
      var width = image.width === 'auto' ? null : image.width;
      var height = image.height === 'auto' ? null : image.height;
      var scale = image.scale === 'auto' ? null : image.scale;
      var src = image.src;
      if (typeof src === 'string') {
        return {
          type: 'uri',
          src: src, width: width, height: height, scale: scale
        };
      }
      if (getBytes(src)) {
        return {
          type: 'encodedImage',
          src: getBytes(src),
          width: width, height: height, scale: scale
        };
      }
      return {
        type: 'imageBitmap',
        src: getNativeObject(src).cid,
        width: width, height: height, scale: scale
      };
    }
  }, this.BoxDimensions = {
    convert: function (value) {
      try {
        if (!value) {
          return Object.freeze({ left: 0, right: 0, top: 0, bottom: 0 });
        }
        if (typeof value === 'number') {
          var normal = self.dimension.convert(value);
          return { left: normal, right: normal, top: normal, bottom: normal };
        }
        if (value instanceof Array || typeof value === 'string') {
          var arr = (typeof value === 'string' ? value.trim().split(/\s+/) : value).map(convertToNumber);
          if (arr.length === 0 || arr.length > 4) {
            throw new Error('Array must have between 1 and 4 entries');
          }
          return Object.freeze({
            top: arr[0],
            right: arr.length > 1 ? arr[1] : arr[0],
            bottom: arr.length > 2 ? arr[2] : arr[0],
            left: arr.length > 3 ? arr[3] : arr.length > 1 ? arr[1] : arr[0]
          });
        }
        if (typeof value === 'object') {
          var partial = allowOnlyKeys(value, ['left', 'top', 'right', 'bottom']);
          return Object.freeze({
            left: 'left' in partial ? convertToNumber(partial.left) : 0,
            top: 'top' in partial ? convertToNumber(partial.top) : 0,
            right: 'right' in partial ? convertToNumber(partial.right) : 0,
            bottom: 'bottom' in partial ? convertToNumber(partial.bottom) : 0
          });
        }
        throw new Error('Expected number, string or object');
      } catch (ex) {
        throw new Error(toValueString(value) + ' is not a valid BoxDimensions value: ' + ex.message);
      }
    }
  }, this.Bounds = {
    decode: /** @param {any} value*/function (value) {
      return value === undefined ? { left: 0, top: 0, width: 0, height: 0 } : { left: value[0], top: value[1], width: value[2], height: value[3] };
    }
  };

  /** @type {PropertyType<NativeObject|WidgetCollection>} */
  this.Widget = {
    convert: function (value) {
      if (!value) {
        return null;
      }
      if (value instanceof WidgetCollection) {
        return value.first() || null;
      }
      // Can't import Widget due to circular dependency, check animate method instead
      if (value instanceof NativeObject && Object.getPrototypeOf(value).animate instanceof Function) {
        return value;
      }
      throw new Error('Not a valid widget: ' + toValueString(value));
    },

    encode: function (value) {
      return value instanceof NativeObject ? value.cid : null;
    },
    decode: function (value) {
      return tabris._nativeObjectRegistry.find(value);
    }
  };

  /** @type {PropertyType<Partial<typeof transformDefaults>>} */
  this.Transformation = {
    convert: function (value) {
      var partial = allowOnlyKeys(value, Object.keys(transformDefaults));
      return Object.freeze({
        rotation: 'rotation' in partial ? convertToNumber(partial.rotation) : 0,
        scaleX: 'scaleX' in partial ? convertToNumber(partial.scaleX) : 1,
        scaleY: 'scaleY' in partial ? convertToNumber(partial.scaleY) : 1,
        translationX: 'translationX' in partial ? convertToNumber(partial.translationX) : 0,
        translationY: 'translationY' in partial ? convertToNumber(partial.translationY) : 0,
        translationZ: 'translationZ' in partial ? convertToNumber(partial.translationZ) : 0
      });
    }
  };

  /** @type {PropertyType<Date>} */
  this.Date = {
    convert: function (value) {
      if (!(value instanceof Date)) {
        throw new Error(toValueString(value) + ' is not of type Date');
      }
      return value;
    },
    encode: function (value) {
      return value.getTime();
    }
  };

  /**
   * @param {any} value
   */
  function convertToNumber(value) {
    if (value === false || value == null || value === '') {
      return 0;
    }
    if (typeof value === 'string') {
      var fixedString = value.trim().replace('px', '');
      if (numberRegex.test(fixedString)) {
        return parseFloat(fixedString);
      }
    }
    if (typeof value !== 'number') {
      throw new Error(toValueString(value) + ' is not a number');
    }
    if (!isFinite(value)) {
      throw new Error(toValueString(value) + ' is not a valid number');
    }
    return value;
  }

  /**
   * @param {any} value
   */
  function isIntendedLinearGradientValue(value) {
    if (value instanceof LinearGradient) {
      return true;
    }
    if (value instanceof Object) {
      return 'colorStops' in value;
    }
    if (typeof value === 'string') {
      return (/^linear-gradient/.test(value)
      );
    }
  }
};

var types = Object.freeze(new PropertyTypes());

var EventsClass = /** @type {any} */function EventsClass() {};
Object.assign(EventsClass.prototype, Events);

/**
 * Add indexer to NativeObject since defineProperties sabotages intellisense
 * @typedef NativeObjectBase
 * @type {{new(): typeof Events & {[key: string]: any}}}
 */
/**
 * @abstract
 */

var NativeObject = function (_EventsClass) {
  _inherits(NativeObject, _EventsClass);

  _createClass(NativeObject, null, [{
    key: 'defineProperties',


    /**
     * @template {NativeObject} T
     * @param {T} target
     * @param {PropertyDefinitions<T>} definitions
     */
    value: function defineProperties(target, definitions) {
      for (var name in definitions) {
        NativeObject.defineProperty(target, name, definitions[name]);
      }
    }

    /**
     * @param {object} target
     * @param {string} name
     * @param {Partial<PropertyDefinition>} property
     */

  }, {
    key: 'defineProperty',
    value: function defineProperty(target, name, property) {
      var def = normalizeProperty(property);
      Object.defineProperty(target, '$prop_' + name, {
        enumerable: false,
        writable: false,
        value: def
      });
      Object.defineProperty(target, name, {
        set: function (value) {
          this.$setProperty(name, value);
        },
        get: function () {
          return this.$getProperty(name);
        }
      });
      if (!def.const) {
        this.defineChangeEvent(target, name);
      }
    }

    /**
     * @param {NativeObject} target
     * @param {EventDefinitions} definitions
     */

  }, {
    key: 'defineEvents',
    value: function defineEvents(target, definitions) {
      for (var name in definitions) {
        NativeObject.defineEvent(target, name, definitions[name]);
      }
    }

    /**
     * @param {NativeObject} target
     * @param {string} name
     * @param {EventDefinition|true} definition
     */

  }, {
    key: 'defineEvent',
    value: function defineEvent(target, name, definition) {
      var property = 'on' + name.charAt(0).toUpperCase() + name.slice(1);
      var $property = '$' + property;
      var $eventProperty = '$event_' + name;
      if (target[$eventProperty]) {
        throw new Error('Event already defined');
      }
      var def = target[$eventProperty] = normalizeEvent(name, definition);
      if (def.changes) {
        this.synthesizeChangeEvents(target, name, def);
      }
      Object.defineProperty(target, property, {
        get: function () {
          if (!this[$property]) {
            this[$property] = new Listeners(this, name);
          }
          return this[$property];
        }
      });
    }

    /**
     * @param {NativeObject} target
     * @param {string[]} properties
     */

  }, {
    key: 'defineChangeEvents',
    value: function defineChangeEvents(target, properties) {
      var _this14 = this;

      properties.forEach(function (property) {
        return _this14.defineChangeEvent(target, property);
      });
    }
  }, {
    key: 'defineChangeEvent',
    value: function defineChangeEvent(target, property) {
      var listenersProperty = 'on' + property.charAt(0).toUpperCase() + property.slice(1) + 'Changed';
      var $listenersProperty = '$' + property + 'Changed';
      Object.defineProperty(target, listenersProperty, {
        get: function () {
          if (!this[$listenersProperty]) {
            this[$listenersProperty] = new ChangeListeners(this, property);
          }
          return this[$listenersProperty];
        }
      });
    }
  }, {
    key: 'synthesizeChangeEvents',
    value: function synthesizeChangeEvents(target, sourceEvent, sourceDef) {
      var changeListener = function (ev) {
        this.$trigger(sourceDef.changes + 'Changed', { value: sourceDef.changeValue(ev) });
      };
      var $changeEventProperty = '$event_' + sourceDef.changes + 'Changed';
      /** @type {EventDefinition} */
      var changeEventDef = target[$changeEventProperty] = target[$changeEventProperty] || { listen: [] };
      changeEventDef.listen.push(function (target, listening) {
        target._onoff(sourceEvent, listening, changeListener);
      });
    }
  }, {
    key: 'extend',
    value: function extend(nativeType) {
      var superType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NativeObject;

      return function (_superType) {
        _inherits(_class, _superType);

        function _class() {
          _classCallCheck(this, _class);

          return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
          key: '_nativeType',
          get: function () {
            return nativeType;
          }
        }]);

        return _class;
      }(superType);
    }

    /**
     * @param {object|boolean=} param
     */

  }]);

  function NativeObject(param) {
    _classCallCheck(this, NativeObject);

    var _this13 = _possibleConstructorReturn(this, (NativeObject.__proto__ || Object.getPrototypeOf(NativeObject)).call(this));

    Object.defineProperty(_this13, '$props', {
      enumerable: false,
      writable: true,
      value: /** @type {{[property: string]: unknown}} */{}
    });
    _this13._nativeCreate(param);
    return _this13;
  }

  _createClass(NativeObject, [{
    key: 'set',
    value: function set() {
      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

      if (arguments.length === 0) {
        throw new Error('Not enough arguments');
      }
      if (arguments.length > 1) {
        throw new Error('Too many arguments');
      }
      this._reorderProperties(Object.keys(properties || {})).forEach(function (name) {
        setExistingProperty.call(this, name, properties[name]);
      }, this);
      return this;
    }

    /**
     * @param {string} name
     */

  }, {
    key: '$getProperty',
    value: function $getProperty(name) {
      if (this._isDisposed) {
        hint(this, 'Cannot get property "' + name + '" on disposed object');
        return;
      }
      var def = this._getPropertyDefinition(name);
      if (def.nocache) {
        var _value = this._nativeGet(name);
        return def.type.decode ? def.type.decode.call(null, _value, this) : _value;
      }
      var storedValue = this._getStoredProperty(name);
      if (storedValue !== undefined) {
        return storedValue;
      }
      if (def.default !== undefined) {
        return def.default;
      }
      var value = this._nativeGet(name);
      var decodedValue = def.type.decode ? def.type.decode.call(this, value) : value;
      this._storeProperty(name, decodedValue);
      return decodedValue;
    }

    /**
     * @param {string} name
     * @param {unknown} value
     */

  }, {
    key: '$setProperty',
    value: function $setProperty(name, value) {
      if (this._isDisposed) {
        hint(this, 'Cannot set property "' + name + '" on disposed object');
        return;
      }
      var def = this._getPropertyDefinition(name);
      if (def.readonly) {
        hint(this, 'Can not set read-only property "' + name + '"');
        return;
      } else if (def.const && this._wasSet(name)) {
        hint(this, 'Can not set const property "' + name + '"');
        return;
      }
      var convertedValue = value;
      try {
        convertedValue = this._convertValue(def, value, convertedValue);
      } catch (ex) {
        this._printPropertyWarning(name, ex);
        return;
      }
      var encodedValue = def.type.encode.call(null, convertedValue, this);
      if (def.nocache) {
        this._beforePropertyChange(name, convertedValue);
        this._nativeSet(name, encodedValue);
        if (!def.const) {
          this._triggerChangeEvent(name, convertedValue);
        }
      } else if (!equals(this._getStoredProperty(name), convertedValue) || !this._wasSet(name)) {
        this._beforePropertyChange(name, convertedValue);
        this._nativeSet(name, encodedValue); //TODO should not happen if changing from unset to default
        this._storeProperty(name, convertedValue, def.const);
      }
    }

    /**
     * @param {PropertyDefinition} def
     * @param {any} value
     * @param {any} convertedValue
     */

  }, {
    key: '_convertValue',
    value: function _convertValue(def, value, convertedValue) {
      if (!def.nullable || value !== null) {
        // TODO: ensure convert has no write-access to the NativeObject instance via proxy
        convertedValue = allowOnlyValues(def.type.convert.call(null, value, this), def.choice);
      }
      return convertedValue;
    }

    /**
     * @param {string} name
     * @param {Error} ex
     */

  }, {
    key: '_printPropertyWarning',
    value: function _printPropertyWarning(name, ex) {
      hint(this, 'Ignored unsupported value for property "' + name + '": ' + ex.message);
    }

    /**
     * @param {string} name
     * @param {unknown} newValue
     * @param {boolean=} noChangeEvent
     * @returns {boolean}
     */

  }, {
    key: '_storeProperty',
    value: function _storeProperty(name, newValue) {
      var noChangeEvent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (newValue === this._getStoredProperty(name) && this._wasSet(name)) {
        return false;
      }
      if (newValue === undefined) {
        return false;
      } else {
        this.$props[name] = newValue;
      }
      if (!noChangeEvent) {
        this._triggerChangeEvent(name, newValue);
      }
      return true;
    }

    /**
     * @param {string} name
     */

  }, {
    key: '_getStoredProperty',
    value: function _getStoredProperty(name) {
      var result = this.$props ? this.$props[name] : undefined;
      if (result === undefined) {
        result = this._getPropertyDefinition(name).default;
      }
      return result;
    }
  }, {
    key: '_wasSet',
    value: function _wasSet(name) {
      return name in (this.$props || {});
    }

    /**
     * @param {string} propertyName
     * @returns {PropertyDefinition}
     */

  }, {
    key: '_getPropertyDefinition',
    value: function _getPropertyDefinition(propertyName) {
      return this['$prop_' + propertyName] || {};
    }
  }, {
    key: '_decodeProperty',
    value: function _decodeProperty(typeDef, value) {
      return typeDef && typeDef.decode ? typeDef.decode.call(null, value, this) : value;
    }
  }, {
    key: '$getPropertyGetter',
    value: function $getPropertyGetter(name) {
      var prop = this['$prop_' + name];
      return prop ? prop.get : undefined;
    }
  }, {
    key: '_triggerChangeEvent',
    value: function _triggerChangeEvent(propertyName, value) {
      this.$trigger(propertyName + 'Changed', { value: value });
    }

    /**
     * @abstract
     * @type {string}
     * */

  }, {
    key: '_nativeCreate',
    value: function _nativeCreate(param) {
      this._register();
      tabris._nativeBridge.create(this.cid, this._nativeType);
      if (param instanceof Object) {
        this.set(param);
      }
    }
  }, {
    key: '_register',
    value: function _register() {
      if (typeof tabris === 'undefined' || !tabris._nativeBridge) {
        throw new Error('tabris.js not started');
      }
      var cid = tabris._nativeObjectRegistry.register(this);
      Object.defineProperty(this, 'cid', { value: cid });
    }

    /**
     * @param {string[]} properties
     */

  }, {
    key: '_reorderProperties',
    value: function _reorderProperties(properties) {
      return properties;
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      this._dispose();
    }
  }, {
    key: '_dispose',
    value: function _dispose(skipNative) {
      var _this16 = this;

      if (!this._isDisposed && !this._inDispose) {
        Object.defineProperties(this, {
          _inDispose: { enumerable: false, writable: false, value: true },
          _disposedToStringValue: { enumerable: false, writable: false, value: this.toString() }
        });
        this.toString = function () {
          return _this16._disposedToStringValue + ' (disposed)';
        };
        this._trigger('dispose');
        this._release();
        if (!skipNative) {
          tabris._nativeBridge.destroy(this.cid);
        }
        tabris._nativeObjectRegistry.remove(this.cid);
        this.$props = null;
        Object.defineProperty(this, '_isDisposed', { enumerable: false, writable: false, value: true });
      }
    }
  }, {
    key: '_release',
    value: function _release() {}

    /**
     * Called when a property is about to be changed, past conversion and all
     * other pre-checks. May have side-effects. Exceptions will not be catched.
     * @param {string} name
     * @param {any} value
     */
    // @ts-ignore
    // eslint-disable-next-line no-unused-vars

  }, {
    key: '_beforePropertyChange',
    value: function _beforePropertyChange(name, value) {}
  }, {
    key: 'isDisposed',
    value: function isDisposed() {
      return !!this._isDisposed;
    }
  }, {
    key: '_listen',
    value: function _listen(name, listening) {
      var _this17 = this;

      var eventDef = this['$event_' + name];
      if (eventDef) {
        eventDef.listen.forEach(function (listen) {
          return listen(_this17, listening);
        });
      }
    }
  }, {
    key: '_nativeListen',
    value: function _nativeListen(event, state) {
      this._checkDisposed();
      tabris._nativeBridge.listen(this.cid, event, state);
    }
  }, {
    key: '_trigger',
    value: function _trigger(name) {
      var eventData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      return this.$trigger(name, eventData);
    }
  }, {
    key: '$trigger',
    value: function $trigger(name) {
      var eventData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var event = new EventObject();
      for (var key in eventData) {
        if (!(key in event)) {
          Object.defineProperty(event, key, { enumerable: true, value: eventData[key] });
        }
      }
      this.trigger(name, event);
      return !!event.defaultPrevented;
    }
  }, {
    key: '_onoff',
    value: function _onoff(name, listening, listener) {
      listening ? this.on(name, listener) : this.off(name, listener);
    }
  }, {
    key: '_checkDisposed',
    value: function _checkDisposed() {
      if (this._isDisposed) {
        throw new Error('Object is disposed');
      }
    }
  }, {
    key: '_nativeSet',
    value: function _nativeSet(name, value) {
      this._checkDisposed();
      tabris._nativeBridge.set(this.cid, name, value === undefined ? null : value);
    }
  }, {
    key: '_nativeGet',
    value: function _nativeGet(name) {
      this._checkDisposed();
      return tabris._nativeBridge.get(this.cid, name);
    }
  }, {
    key: '_nativeCall',
    value: function _nativeCall(method, parameters) {
      this._checkDisposed();
      return tabris._nativeBridge.call(this.cid, method, parameters);
    }
  }, {
    key: 'toString',
    value: function toString() {
      return this.constructor.name;
    }
  }, {
    key: toXML$$1,
    value: function () {
      if (this._isDisposed) {
        return '<' + this._getXMLElementName() + ' cid=\'' + this.cid + '\' disposed=\'true\'/>';
      }
      var content = this._getXMLContent();
      if (!content.length) {
        return this._getXMLHeader(false);
      }
      return this._getXMLHeader(true) + '\n' + content.join('\n') + '\n' + this._getXMLFooter(true);
    }
  }, {
    key: '_getXMLHeader',
    value: function _getXMLHeader(hasChild) {
      var attributes = this._getXMLAttributes().map(function (entry) {
        return entry[0] + '=\'' + ('' + entry[1]).replace(/'/g, '\\\'').replace(/\n/g, '\\n') + '\'';
      }).join(' ');
      return '<' + this._getXMLElementName() + ' ' + attributes + (!hasChild ? '/' : '') + '>';
    }
  }, {
    key: '_getXMLFooter',
    value: function _getXMLFooter(hasChild) {
      return hasChild ? '</' + this._getXMLElementName() + '>' : '';
    }
  }, {
    key: '_getXMLElementName',
    value: function _getXMLElementName() {
      return this.constructor.name;
    }
  }, {
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      return [['cid', this.cid]];
    }
  }, {
    key: '_getXMLContent',
    value: function _getXMLContent() {
      return [];
    }
  }, {
    key: '_nativeType',
    get: function () {
      throw new Error('Can not create instance of abstract class ' + this.constructor.name);
    }
  }]);

  return NativeObject;
}( /** @type {NativeObjectBase} */EventsClass);

NativeObject.defineEvents(NativeObject.prototype, {
  dispose: true
});

function setExistingProperty(name, value) {
  if (!(name in this)) {
    hint(this, 'There is no setter for property "' + name + '"');
  }
  this[name] = value;
}

/**
 * @param {Partial<PropertyDefinition>}  config
 * @returns {PropertyDefinition}
 */
function normalizeProperty(config) {
  var def = {
    type: normalizeType(config.type || {}),
    default: config.default,
    nullable: !!config.nullable,
    const: !!config.const,
    nocache: !!config.nocache,
    readonly: !!config.readonly,
    choice: config.choice
  };
  if (def.readonly && def.default !== undefined) {
    throw new Error('Can not combine "nocache" with "readonly"');
  }
  if (def.readonly && def.nullable) {
    throw new Error('Can not combine "nullable" with "readonly"');
  }
  if (def.readonly && def.choice) {
    throw new Error('Can not combine "choice" with "readonly"');
  }
  if (def.choice && def.choice.length < 2) {
    throw new Error('"choice" needs at least two entries');
  }
  if (def.default === undefined && !def.nocache && !def.readonly) {
    throw new Error('"default" must be given unless "nocache" or "readonly" is true.');
  }
  allowOnlyKeys(config, Object.keys(def));
  return def;
}

/**
 * @param {string} name
 * @param {EventDefinition|true} definition
 * @returns {EventDefinition}
 */
function normalizeEvent(name, definition) {
  var result = { listen: [] };
  if (definition === true) {
    return result;
  }
  Object.assign(result, definition);
  if (definition.native) {
    result.listen.push(function (target, listening) {
      target._nativeListen(name, listening);
    });
  }
  if (result.changes) {
    var changeValue = result.changeValue;
    if (typeof changeValue === 'string') {
      result.changeValue = function (ev) {
        return ev[changeValue];
      };
    } else if (!changeValue) {
      result.changeValue = function (ev) {
        return ev[result.changes];
      };
    }
  }
  return result;
}

/**
 * @param {string|TypeDef<any, any, any>} config
 * @returns {TypeDef<any, any, any>}
 */
function normalizeType(config) {
  if (config instanceof Function && config.prototype instanceof NativeObject) {
    return {
      convert: function (value) {
        if (!(value instanceof config)) {
          throw new Error('Not an instance of ' + config.name);
        }
        return value;
      },
      encode: function (value) {
        return value ? value.cid : null;
      },
      decode: function (value) {
        return value ? tabris._nativeObjectRegistry.find(value) : null;
      }
    };
  }
  var def = typeof config === 'string' ? types[config] : config;
  allowOnlyKeys(def, ['convert', 'encode', 'decode']);
  return {
    convert: def.convert || function (v) {
      return v;
    },
    encode: def.encode || function (v) {
      return v;
    },
    decode: def.decode || function (v) {
      return v;
    }
  };
}

var NativeBridge = function () {
  function NativeBridge(bridge) {
    _classCallCheck(this, NativeBridge);

    Object.defineProperties(this, {
      $bridge: { enumerable: false, writable: false, value: bridge },
      $operations: { enumerable: false, writable: true, value: [] },
      $currentOperation: { enumerable: false, writable: true, value: { id: null } },
      $propertyCache: { enumerable: false, writable: true, value: {} }
    });
  }

  _createClass(NativeBridge, [{
    key: 'create',
    value: function create(id, type) {
      var properties = {};
      this.$operations.push(['create', id, type, properties]);
      this.$currentOperation = { id: id, properties: properties };
    }
  }, {
    key: 'set',
    value: function set(id, name, value) {
      if (this.$currentOperation.id === id) {
        this.$currentOperation.properties[name] = value;
      } else {
        var properties = {};
        properties[name] = value;
        this.$operations.push(['set', id, properties]);
        this.$currentOperation = { id: id, properties: properties };
      }
      this.cacheValue(id, name, value);
    }
  }, {
    key: 'listen',
    value: function listen(id, event, _listen2) {
      this.$operations.push(['listen', id, event, _listen2]);
      this.$currentOperation = { id: null };
    }
  }, {
    key: 'destroy',
    value: function destroy(id) {
      this.$operations.push(['destroy', id]);
      this.$currentOperation = { id: null };
    }
  }, {
    key: 'get',
    value: function get(id, name) {
      if (this.$propertyCache[id] && name in this.$propertyCache[id]) {
        return this.$propertyCache[id][name];
      }
      this.flush();
      var result = this.$bridge.get(id, name);
      this.cacheValue(id, name, result);
      return result;
    }
  }, {
    key: 'call',
    value: function call(id, method, parameters) {
      this.flush();
      return this.$bridge.call(id, method, parameters);
    }
  }, {
    key: 'flush',
    value: function flush() {
      tabris.trigger('layout');
      var operations = this.$operations;
      this.$operations = [];
      this.$currentOperation = { id: null };
      var length = operations.length;
      // Using apply() on the native bridge does not work with Rhino. It seems that the parameter
      // count must be known in order to find the associated native method.
      for (var i = 0; i < length; i++) {
        var op = operations[i];
        switch (op[0]) {
          case 'create':
            this.$bridge.create(op[1], op[2], op[3]);
            break;
          case 'set':
            this.$bridge.set(op[1], op[2]);
            break;
          case 'listen':
            this.$bridge.listen(op[1], op[2], op[3]);
            break;
          case 'destroy':
            this.$bridge.destroy(op[1]);
        }
      }
    }
  }, {
    key: 'clearCache',
    value: function clearCache() {
      this.$propertyCache = {};
    }
  }, {
    key: 'cacheValue',
    value: function cacheValue(id, property, value) {
      if (!this.$propertyCache[id]) {
        this.$propertyCache[id] = {};
      }
      this.$propertyCache[id][property] = value;
    }
  }]);

  return NativeBridge;
}();

var NativeObjectRegistry = function () {
  function NativeObjectRegistry() {
    _classCallCheck(this, NativeObjectRegistry);

    Object.defineProperties(this, {
      $idSequence: { enumerable: false, writable: true, value: 1 },
      $objects: { enumerable: false, writable: false, value: {} }
    });
  }

  _createClass(NativeObjectRegistry, [{
    key: 'register',
    value: function register(nativeObject) {
      var cid = this.$generateId();
      if (cid in this.$objects) {
        throw new Error('cid already in use: ' + cid);
      }
      this.$objects[cid] = nativeObject;
      return cid;
    }
  }, {
    key: 'remove',
    value: function remove(cid) {
      delete this.$objects[cid];
    }
  }, {
    key: 'find',
    value: function find(cid) {
      return this.$objects[cid] || null;
    }
  }, {
    key: '$generateId',
    value: function $generateId() {
      return '$' + this.$idSequence++;
    }
  }]);

  return NativeObjectRegistry;
}();

var Tabris = function (_NativeObject) {
  _inherits(Tabris, _NativeObject);

  function Tabris() {
    _classCallCheck(this, Tabris);

    var _this18 = _possibleConstructorReturn(this, (Tabris.__proto__ || Object.getPrototypeOf(Tabris)).call(this));

    Object.defineProperties(_this18, {
      _started: { enumerable: false, writable: true, value: false },
      _init: { enumerable: false, writable: true, value: _this18._init.bind(_this18) },
      _notify: { enumerable: false, writable: true, value: _this18._notify.bind(_this18) },
      _stackTraceStack: { enumerable: false, writable: true, value: [] },
      _nativeObjectRegistry: { enumerable: false, writable: true, value: null },
      _client: { enumerable: false, writable: true, value: null },
      _nativeBridge: { enumerable: false, writable: true, value: null },
      _entryPoint: { enumerable: false, writable: true, value: null }
    });
    _this18.$publishProxies();
    return _this18;
  }

  _createClass(Tabris, [{
    key: 'flush',
    value: function flush() {
      this.trigger('flush');
      this._nativeBridge.clearCache();
      this._nativeBridge.flush();
    }
  }, {
    key: '_nativeCreate',


    /** @override */
    value: function _nativeCreate() {}
  }, {
    key: '_register',
    value: function _register() {
      this._nativeObjectRegistry = new NativeObjectRegistry();
      var cid = this._nativeObjectRegistry.register(this);
      Object.defineProperty(this, 'cid', { value: cid });
    }
  }, {
    key: '_init',
    value: function _init(client, options) {
      this._client = client;
      this._nativeBridge = new NativeBridge(client);
      this._register();
      this._nativeBridge.create(this.cid, this._nativeType);
      this.trigger('start', options || { headless: false });
      this._started = true;
    }
  }, {
    key: '_setEntryPoint',
    value: function _setEntryPoint(entryPoint) {
      this._entryPoint = entryPoint;
    }
  }, {
    key: '_notify',
    value: function _notify(cid, event, param) {
      var returnValue = void 0;
      try {
        var _nativeObject = this._nativeObjectRegistry.find(cid);
        if (_nativeObject) {
          try {
            var eventDef = _nativeObject['$event_' + event];
            if (eventDef && eventDef.changes) {
              this._nativeBridge.cacheValue(cid, eventDef.changes, eventDef.changeValue(param));
            }
            returnValue = _nativeObject._trigger(event, param);
          } catch (err) {
            error(err);
          }
        }
        this.flush();
      } catch (err) {
        error(err);
      }
      return returnValue;
    }
  }, {
    key: '$publishProxies',
    value: function $publishProxies() {
      var _this19 = this;

      ['contentView', 'drawer', 'navigationBar', 'statusBar', 'permission', 'printer', 'device', 'app', 'localStorage', 'secureStorage', 'crypto', 'fs', 'pkcs5', 'sizeMeasurement'].forEach(function (name) {
        var value = proxify(function () {
          return _this19['$' + name];
        });
        Object.defineProperty(_this19, name, { value: value });
      });
    }
  }, {
    key: 'version',
    get: function () {
      return '3.3.0';
    }
  }, {
    key: 'started',
    get: function () {
      return !!this._started;
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Tabris';
    }
  }]);

  return Tabris;
}(NativeObject);

NativeObject.defineEvents(Tabris.prototype, {
  start: {},
  flush: {},
  layout: {},
  log: {}
});

var SUPPORTED_ENCODINGS = ['ascii', 'utf-8'];

var TextEncoder = function (_NativeObject2) {
  _inherits(TextEncoder, _NativeObject2);

  function TextEncoder() {
    _classCallCheck(this, TextEncoder);

    return _possibleConstructorReturn(this, (TextEncoder.__proto__ || Object.getPrototypeOf(TextEncoder)).apply(this, arguments));
  }

  _createClass(TextEncoder, [{
    key: 'encode',
    value: function encode(text, encoding) {
      this._nativeListen('result', true);
      this._nativeListen('error', true);
      this._nativeCall('encode', { text: text, encoding: encoding });
    }
  }, {
    key: 'encodeSync',
    value: function encodeSync(text, encoding) {
      return this._nativeCall('encodeSync', { text: text, encoding: encoding });
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.TextEncoder';
    }

    /**
     * @return {TextEncoder}
     */

  }], [{
    key: 'getInstance',
    value: function getInstance() {
      if (!this._instance) {
        Object.defineProperty(this, '_instance', {
          enumerable: false,
          writable: false,
          value: new TextEncoder()
        });
      }
      return this._instance;
    }
  }, {
    key: 'encode',
    value: function encode(text, encoding) {
      return new Promise(function (resolve, reject) {
        encoding = encoding || 'utf-8';
        paramCheck(text, encoding);
        new TextEncoder().on('result', function (_ref3) {
          var { target: target, data: data } = _ref3;

          resolve(data);
          target.dispose();
        }).on('error', function (_ref4) {
          var { target: target } = _ref4;

          reject(new Error('Could not encode ' + encoding));
          target.dispose();
        }).encode(text, encoding);
      });
    }
  }, {
    key: 'encodeSync',
    value: function encodeSync(text, encoding) {
      encoding = encoding || 'utf-8';
      paramCheck(text, encoding);
      return TextEncoder.getInstance().encodeSync(text, encoding);
    }
  }]);

  return TextEncoder;
}(NativeObject);

TextEncoder._instance = null;

function paramCheck(text, encoding) {
  if (typeof text !== 'string') {
    throw new Error('Invalid text, must be a string');
  }
  if (!SUPPORTED_ENCODINGS.includes(encoding)) {
    throw new Error('Unsupported encoding: ' + toValueString(encoding));
  }
}

var SUPPORTED_ENCODINGS$1 = ['ascii', 'utf-8'];

var TextDecoder = function (_NativeObject3) {
  _inherits(TextDecoder, _NativeObject3);

  function TextDecoder() {
    _classCallCheck(this, TextDecoder);

    var _this21 = _possibleConstructorReturn(this, (TextDecoder.__proto__ || Object.getPrototypeOf(TextDecoder)).call(this));

    _this21._nativeListen('result', true);
    _this21._nativeListen('error', true);
    return _this21;
  }

  _createClass(TextDecoder, [{
    key: 'decode',
    value: function decode(buffer, encoding) {
      this._nativeCall('decode', { data: buffer, encoding: encoding });
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.TextDecoder';
    }
  }], [{
    key: 'decode',
    value: function decode(buffer, encoding) {
      return new Promise(function (resolve, reject) {
        if (ArrayBuffer.isView(buffer)) {
          buffer = buffer.buffer;
        }
        if (!(buffer instanceof ArrayBuffer)) {
          throw new Error('Invalid buffer type');
        }
        encoding = encoding || 'utf-8';
        if (!SUPPORTED_ENCODINGS$1.includes(encoding)) {
          throw new Error('Unsupported encoding: ' + toValueString(encoding));
        }
        new TextDecoder().on('result', function (_ref5) {
          var { target: target, string: string } = _ref5;

          resolve(string);
          target.dispose();
        }).on('error', function (_ref6) {
          var { target: target } = _ref6;

          reject(new Error('Could not decode ' + encoding));
          target.dispose();
        }).decode(buffer, encoding);
      });
    }
  }]);

  return TextDecoder;
}(NativeObject);

var Blob = function () {

  /**
   * @param {Array=} blobParts
   * @param {Object=} options
   */
  function Blob() {
    var blobParts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Blob);

    if (Object.getPrototypeOf(blobParts) !== Array.prototype) {
      throw new TypeError('Argument 1 of Blob.constructor can\'t be converted to a sequence.');
    }
    if (Object.getPrototypeOf(options) !== Object.prototype) {
      throw new TypeError('Argument 2 of Blob.constructor can\'t be converted to a dictionary.');
    }
    setBytes(this, join(blobParts));
    Object.defineProperty(this, 'type', { value: 'type' in options ? options.type + '' : '' });
  }

  _createClass(Blob, [{
    key: 'arrayBuffer',
    value: function arrayBuffer() {
      return Promise.resolve(getBytes(this).slice(0));
    }
  }, {
    key: 'text',
    value: function text() {
      return TextDecoder.decode(getBytes(this));
    }
  }, {
    key: 'size',
    get: function () {
      return getBytes(this).byteLength;
    }
  }]);

  return Blob;
}();

Object.defineProperty(Blob.prototype, 'type', { value: '' });

/** @param {Array} parts*/
function join(parts) {
  var size = 0;
  /** @type {Uint8Array[]} */
  var chunks = [];
  for (var i = 0; i < parts.length; i++) {
    chunks[i] = partToChunk(parts[i]);
    size += chunks[i].byteLength;
  }
  var result = new Uint8Array(size);
  var offset = 0;
  for (var _i = 0; _i < chunks.length; _i++) {
    result.set(chunks[_i], offset);
    offset += chunks[_i].byteLength;
  }
  return result.buffer;
}

/**
 * @param {any} part
 * @return {Uint8Array}
*/
function partToChunk(part) {
  if (part instanceof ArrayBuffer) {
    return new Uint8Array(part);
  }
  if (ArrayBuffer.isView(part)) {
    return new Uint8Array(part.buffer);
  }
  if (part instanceof Blob) {
    return new Uint8Array(getBytes(part));
  }
  return new Uint8Array(TextEncoder.encodeSync(part + ''));
}

Blob.prototype[Symbol.toStringTag] = 'Blob';

var Camera = function (_NativeObject4) {
  _inherits(Camera, _NativeObject4);

  function Camera(properties) {
    _classCallCheck(this, Camera);

    if (!properties || !properties.cameraId) {
      throw new Error('Camera requires cameraId');
    }
    return _possibleConstructorReturn(this, (Camera.__proto__ || Object.getPrototypeOf(Camera)).call(this, properties));
  }

  _createClass(Camera, [{
    key: 'captureImage',
    value: function captureImage() {
      var _this23 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new Promise(function (resolve, reject) {
        if (!_this23.active) {
          reject(new Error('Camera has to be active to capture an image'));
        } else {
          _this23._nativeCall('captureImage', {
            options: options,
            onResult: function (result) {
              var blob = new Blob([], { type: 'image/jpg' });
              setBytes(blob, result.image);
              return resolve({
                image: blob,
                width: result.width,
                height: result.height
              });
            },
            onError: function (error) {
              return reject(new Error(error));
            }
          });
        }
      });
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Camera';
    }
  }]);

  return Camera;
}(NativeObject);

NativeObject.defineProperties(Camera.prototype, {
  cameraId: { type: types.string, const: true, default: '' },
  active: { type: types.boolean, default: false },
  captureResolution: {
    type: {
      convert: function (value) {
        return Object.freeze(allowOnlyKeys( /** @type {{width: number, height: number}} */value, ['width', 'height']));
      }
    },
    default: null,
    nullable: true
  },
  position: { type: types.string, const: true, readonly: true },
  availableCaptureResolutions: {
    type: {
      decode: function (value) {
        return value.sort(function (a, b) {
          return a.width * a.height - b.width * b.height;
        });
      }
    },
    const: true,
    readonly: true
  }
});

var Device = function (_NativeObject5) {
  _inherits(Device, _NativeObject5);

  function Device() {
    _classCallCheck(this, Device);

    return _possibleConstructorReturn(this, (Device.__proto__ || Object.getPrototypeOf(Device)).apply(this, arguments));
  }

  _createClass(Device, [{
    key: '_nativeCreate',


    /** @override */
    value: function _nativeCreate(param) {
      if (param !== true) {
        throw new Error('Device can not be created');
      }
      _get(Device.prototype.__proto__ || Object.getPrototypeOf(Device.prototype), '_nativeCreate', this).call(this);
    }
  }, {
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'orientationChanged') {
        this._nativeListen(name, listening);
      } else {
        _get(Device.prototype.__proto__ || Object.getPrototypeOf(Device.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_trigger',
    value: function _trigger(name, event) {
      if (name === 'orientationChanged') {
        this._triggerChangeEvent('orientation', event.orientation);
      } else {
        _get(Device.prototype.__proto__ || Object.getPrototypeOf(Device.prototype), '_trigger', this).call(this, name, event);
      }
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      throw new Error('Cannot dispose device object');
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Device';
    }
  }]);

  return Device;
}(NativeObject);

NativeObject.defineProperties(Device.prototype, {
  model: { readonly: true, const: true },
  vendor: { readonly: true, const: true },
  platform: { readonly: true, const: true },
  version: { readonly: true, const: true },
  name: { readonly: true, const: true },
  language: { readonly: true, const: true },
  orientation: { readonly: true, nocache: true },
  screenWidth: { readonly: true, const: true },
  screenHeight: { readonly: true, const: true },
  scaleFactor: { readonly: true, const: true },
  cameras: {
    type: {
      decode: function (value) {
        return Object.freeze(value.map(function (cameraId) {
          return new Camera({ cameraId: cameraId });
        }));
      }
    },
    readonly: true,
    const: true
  }
});

function create() {
  return new Device(true);
}

function publishDeviceProperties(device, target) {
  target.devicePixelRatio = device.scaleFactor;
  target.device = createDevice(device);
  target.screen = createScreen(device);
  target.navigator = createNavigator(device);
}

function createDevice(device) {
  var dev = {};
  ['model', 'vendor', 'platform', 'version', 'name'].forEach(function (name) {
    defineReadOnlyProperty(dev, name, function () {
      return device[name];
    });
  });
  return dev;
}

function createScreen(device) {
  var screen = {};
  defineReadOnlyProperty(screen, 'width', function () {
    return device.screenWidth;
  });
  defineReadOnlyProperty(screen, 'height', function () {
    return device.screenHeight;
  });
  return screen;
}

function createNavigator(device) {
  var navigator = {};
  defineReadOnlyProperty(navigator, 'userAgent', function () {
    return 'tabris-js';
  });
  defineReadOnlyProperty(navigator, 'language', function () {
    return device.language;
  });
  return navigator;
}

function defineReadOnlyProperty(target, name, getter) {
  Object.defineProperty(target, name, {
    get: getter,
    set: function () {}
  });
}

var Printer = function (_NativeObject6) {
  _inherits(Printer, _NativeObject6);

  function Printer() {
    _classCallCheck(this, Printer);

    return _possibleConstructorReturn(this, (Printer.__proto__ || Object.getPrototypeOf(Printer)).apply(this, arguments));
  }

  _createClass(Printer, [{
    key: '_nativeCreate',


    /** @override */
    value: function _nativeCreate(param) {
      if (param !== true) {
        throw new Error('Printer can not be created');
      }
      _get(Printer.prototype.__proto__ || Object.getPrototypeOf(Printer.prototype), '_nativeCreate', this).call(this);
    }
  }, {
    key: 'print',
    value: function print(data, options) {
      var _arguments = arguments,
          _this26 = this;

      return new Promise(function (resolve, reject) {
        if (_arguments.length < 1) {
          throw new Error('Not enough arguments to print');
        }
        if (!isDataValid(data)) {
          throw new Error('data is not an ArrayBuffer or typed array');
        }
        _this26._nativeCall('print', {
          data: data instanceof ArrayBuffer ? data : data.buffer,
          options: options,
          onResult: function (result) {
            return resolve({ result: result });
          },
          onError: function (error) {
            return reject(new Error(error));
          }
        });
      });
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      throw new Error('Cannot dispose printer object');
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Printer';
    }
  }]);

  return Printer;
}(NativeObject);

function isDataValid(value) {
  return value instanceof ArrayBuffer || value instanceof Int8Array || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int16Array || value instanceof Uint16Array || value instanceof Int32Array || value instanceof Uint32Array || value instanceof Float32Array || value instanceof Float64Array;
}

function create$1() {
  return new Printer(true);
}

var Permission = function (_NativeObject7) {
  _inherits(Permission, _NativeObject7);

  function Permission() {
    _classCallCheck(this, Permission);

    return _possibleConstructorReturn(this, (Permission.__proto__ || Object.getPrototypeOf(Permission)).apply(this, arguments));
  }

  _createClass(Permission, [{
    key: '_nativeCreate',


    /** @override */
    value: function _nativeCreate(param) {
      if (param !== true) {
        throw new Error('Permission can not be created');
      }
      _get(Permission.prototype.__proto__ || Object.getPrototypeOf(Permission.prototype), '_nativeCreate', this).call(this);
    }
  }, {
    key: 'getAuthorizationStatus',
    value: function getAuthorizationStatus() {
      for (var _len10 = arguments.length, permissions = Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        permissions[_key10] = arguments[_key10];
      }

      Permission.validatePermissions(permissions, 'get authorization status');
      var result = this._nativeCall('getAuthorizationStatus', { permissions: permissions });
      if (!result || result.error) {
        throw new Error(!result ? 'No result returned for getAuthorizationStatus()' : result.error);
      } else {
        return result.status;
      }
    }
  }, {
    key: 'isAuthorized',
    value: function isAuthorized() {
      for (var _len11 = arguments.length, permissions = Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
        permissions[_key11] = arguments[_key11];
      }

      Permission.validatePermissions(permissions, 'check if permission is authorized');
      return this.getAuthorizationStatus(...permissions) === 'granted';
    }
  }, {
    key: 'isAuthorizationPossible',
    value: function isAuthorizationPossible() {
      for (var _len12 = arguments.length, permissions = Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
        permissions[_key12] = arguments[_key12];
      }

      Permission.validatePermissions(permissions, 'check if authorization is possible');
      var status = this.getAuthorizationStatus(...permissions);
      return status === 'undetermined' || status === 'declined';
    }
  }, {
    key: 'requestAuthorization',
    value: function requestAuthorization() {
      var _this28 = this;

      for (var _len13 = arguments.length, permissions = Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
        permissions[_key13] = arguments[_key13];
      }

      return new Promise(function (resolve, reject) {
        Permission.validatePermissions(permissions, 'request permission authorization');
        _this28._nativeCall('requestAuthorization', {
          permissions: permissions,
          onResult: function (result) {
            if (!result || result.error) {
              reject(new Error(!result ? 'Authorization could not be requested' : result.error));
            } else {
              resolve(result.status);
            }
          }
        });
      });
    }
  }, {
    key: 'withAuthorization',
    value: function withAuthorization(permission, onAuthorized, onUnauthorized, onError) {
      if (Array.isArray(permission)) {
        if (!permission.every(function (entry) {
          return typeof entry === 'string';
        })) {
          throw new Error('Permissions need to be of type string');
        }
      } else if (typeof permission === 'string') {
        permission = [permission];
      } else {
        throw new Error('Permission needs to be of type string or an array of strings');
      }
      this.requestAuthorization(...permission).then(function (status) {
        if (status === 'granted' && typeof onAuthorized === 'function') {
          onAuthorized(status);
        } else if (typeof onUnauthorized === 'function') {
          onUnauthorized(status);
        }
      }).catch(function (e) {
        if (typeof onError === 'function') {
          onError(e);
        }
      });
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      throw new Error('Cannot dispose permission object');
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Permission';
    }
  }], [{
    key: 'validatePermissions',
    value: function validatePermissions(permissions, action) {
      if (permissions.length === 0) {
        throw new Error('Not enough arguments to ' + action);
      }
      if (!permissions.every(function (entry) {
        return typeof entry === 'string';
      })) {
        throw new Error('Permissions need to be of type string');
      }
    }
  }]);

  return Permission;
}(NativeObject);

function create$2() {
  return new Permission(true);
}

var CERTIFICATE_ALGORITHMS = ['RSA2048', 'RSA4096', 'ECDSA256'];

var App = function (_NativeObject8) {
  _inherits(App, _NativeObject8);

  function App() {
    _classCallCheck(this, App);

    return _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).apply(this, arguments));
  }

  _createClass(App, [{
    key: '_nativeCreate',


    /** @override */
    value: function _nativeCreate(param) {
      if (param !== true) {
        throw new Error('App can not be created');
      }
      _get(App.prototype.__proto__ || Object.getPrototypeOf(App.prototype), '_nativeCreate', this).call(this);
    }

    /**
     * @override
     * @param {string} name
     */

  }, {
    key: '_beforePropertyChange',
    value: function _beforePropertyChange(name) {
      if (name === 'pinnedCertificates') {
        this.on('certificatesReceived', this._validateCertificate, this);
      }
    }
  }, {
    key: 'launch',
    value: function launch(url) {
      var _arguments2 = arguments,
          _this30 = this;

      return new Promise(function (resolve, reject) {
        if (_arguments2.length < 1) {
          throw new Error('Not enough arguments to launch');
        }
        if (typeof url !== 'string') {
          throw new Error('Invalid url: ' + toValueString(url) + ' is not a string');
        }
        _this30._nativeCall('launch', {
          url: url,
          onError: function (err) {
            return reject(new Error(err));
          },
          onSuccess: function () {
            return resolve();
          }
        });
      });
    }
  }, {
    key: 'getResourceLocation',
    value: function getResourceLocation(path) {
      if (!this._resourceBaseUrl) {
        Object.defineProperty(this, '_resourceBaseUrl', {
          enumerable: false, writable: false, value: this._nativeGet('resourceBaseUrl')
        });
      }
      var subPath = path != null ? '/' + normalizePath$1('' + path) : '';
      return this._resourceBaseUrl + subPath;
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      throw new Error('tabris.app can not be disposed');
    }
  }, {
    key: 'reload',
    value: function reload(url) {
      this._nativeCall('reload', { url: url });
    }
  }, {
    key: 'close',
    value: function close() {
      this._nativeCall('close');
    }
  }, {
    key: 'registerFont',
    value: function registerFont(alias, file) {
      if (arguments.length < 2) {
        throw new Error('Not enough arguments to register a font');
      }
      if (typeof alias !== 'string') {
        throw new Error('Invalid alias: ' + toValueString(alias) + ' is not a string');
      }
      if (typeof file !== 'string') {
        throw new Error('Invalid file path: ' + toValueString(file) + ' is not a string');
      }
      this._nativeCall('registerFont', { alias: alias, file: file });
    }
  }, {
    key: '_validateCertificate',
    value: function _validateCertificate(event) {
      var hashes = this.$pinnedCerts[event.host];
      if (hashes && !hashes.some(function (hash) {
        return event.hashes.includes(hash);
      })) {
        event.preventDefault();
      }
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.App';
    }
  }, {
    key: 'id',
    get: function () {
      return this._nativeGet('appId');
    }
  }, {
    key: 'debugBuild',
    get: function () {
      return this._nativeGet('debugBuild');
    }
  }, {
    key: 'version',
    get: function () {
      return this._nativeGet('version');
    }
  }, {
    key: 'versionCode',
    get: function () {
      return this._nativeGet('versionId');
    }
  }, {
    key: '$pinnedCerts',
    get: function () {
      var certificates = this.pinnedCertificates;
      var hashes = {};
      for (var cert of certificates) {
        hashes[cert.host] = hashes[cert.host] || [];
        hashes[cert.host].push(cert.hash);
      }
      return hashes;
    }
  }]);

  return App;
}(NativeObject);

NativeObject.defineProperties(App.prototype, {
  pinnedCertificates: {
    type: {
      convert: function (certificates) {
        return Object.freeze(certificates);
      },
      encode: function (certificates) {
        // Do checks here instead of in convert to force an exception instead of a warning
        if (!Array.isArray(certificates)) {
          throw new Error('Not an Array');
        }
        for (var cert of certificates) {
          if (typeof cert.host !== 'string') {
            throw new Error('Invalid host ' + toValueString(cert.host));
          }
          if (typeof cert.hash !== 'string' || !cert.hash.startsWith('sha256/')) {
            throw new Error('Invalid hash ' + toValueString(cert.hash) + ' for pinned certificate ' + cert.host);
          }
          if (tabris.device.platform === 'iOS') {
            if (!('algorithm' in cert)) {
              throw new Error('Missing algorithm for pinned certificate ' + cert.host);
            }
            if (typeof cert.algorithm !== 'string' || CERTIFICATE_ALGORITHMS.indexOf(cert.algorithm) === -1) {
              throw new Error('Invalid algorithm ' + toValueString(cert.algorithm) + ' for pinned certificate ' + cert.host);
            }
          }
        }
        return certificates;
      }
    },
    default: Object.freeze([])
  },
  trustedCertificates: {
    type: {
      convert: function (certificates) {
        return Object.freeze(certificates);
      },
      encode: function (value) {
        // Do checks here instead of in convert to force an exception instead of a warning
        if (!Array.isArray(value)) {
          throw new Error('Not an Array');
        }
        for (var i = 0; i < value.length; i++) {
          var certificate = value[i];
          if (!(certificate instanceof ArrayBuffer)) {
            throw new Error('certificate entry ' + toValueString(certificate) + ' is not an ArrayBuffer');
          }
        }
        return value;
      }
    },
    default: Object.freeze([])
  },
  idleTimeoutEnabled: {
    type: {
      convert: function (value) {
        if (!tabris.contentView) {
          throw new Error('The device property "idleTimeoutEnabled" can only be changed in main context.');
        }
        return types.boolean.convert(value);
      }
    },
    default: true
  }
});

NativeObject.defineEvents(App.prototype, {
  foreground: { native: true },
  background: { native: true },
  pause: { native: true },
  resume: { native: true },
  terminate: { native: true },
  keyPress: { native: true },
  backNavigation: { native: true },
  certificatesReceived: { native: true }
});

function create$3() {
  return new App(true);
}

function normalizePath$1(path) {
  return path.split(/\/+/).map(function (segment) {
    if (segment === '..') {
      throw new Error('Path ' + toValueString(path) + ' must not contain ".."');
    }
    if (segment === '.') {
      return '';
    }
    return segment;
  }).filter(function (string) {
    return !!string;
  }).join('/');
}

var ERRORS = {
  EACCES: 'Permission denied',
  EEXIST: 'File exists',
  ENOENT: 'No such file or directory',
  EISDIR: 'Is a directory',
  ENOTDIR: 'Not a directory',
  ENOTEMPTY: 'Directory not empty'
};

var FileSystem = function (_NativeObject9) {
  _inherits(FileSystem, _NativeObject9);

  function FileSystem() {
    _classCallCheck(this, FileSystem);

    return _possibleConstructorReturn(this, (FileSystem.__proto__ || Object.getPrototypeOf(FileSystem)).apply(this, arguments));
  }

  _createClass(FileSystem, [{
    key: '_nativeCreate',


    /** @override */
    value: function _nativeCreate(param) {
      if (param !== true) {
        throw new Error('FileSystem can not be created');
      }
      _get(FileSystem.prototype.__proto__ || Object.getPrototypeOf(FileSystem.prototype), '_nativeCreate', this).call(this);
    }
  }, {
    key: 'readFile',
    value: function readFile(path, encoding) {
      var _arguments3 = arguments,
          _this32 = this;

      return new Promise(function (resolve, reject) {
        if (_arguments3.length < 1) {
          throw new Error('Not enough arguments to readFile');
        }
        _this32._nativeCall('readFile', {
          path: checkPath(path),
          onError: function (err) {
            return reject(createError(err, path));
          },
          onSuccess: function (data) {
            return encoding ? TextDecoder.decode(data, encoding).then(resolve, reject) : resolve(data);
          }
        });
      });
    }
  }, {
    key: 'writeFile',
    value: function writeFile(path, data, encoding) {
      var _arguments4 = arguments,
          _this33 = this;

      return new Promise(function (resolve, reject) {
        if (_arguments4.length < 2) {
          throw new Error('Not enough arguments to writeFile');
        }
        var write = function (data) {
          return _this33._nativeCall('writeFile', {
            path: checkPath(path),
            data: checkBuffer(data),
            onError: function (err) {
              return reject(createError(err, path));
            },
            onSuccess: function () {
              return resolve();
            }
          });
        };
        if (typeof data === 'string') {
          TextEncoder.encode(data, encoding || 'utf-8').then(write, reject);
        } else {
          write(data);
        }
      });
    }
  }, {
    key: 'removeFile',
    value: function removeFile(path) {
      var _arguments5 = arguments,
          _this34 = this;

      return new Promise(function (resolve, reject) {
        if (_arguments5.length < 1) {
          throw new Error('Not enough arguments to removeFile');
        }
        _this34._nativeCall('removeFile', {
          path: checkPath(path),
          onError: function (err) {
            return reject(createError(err, path));
          },
          onSuccess: function () {
            return resolve();
          }
        });
      });
    }
  }, {
    key: 'readDir',
    value: function readDir(path) {
      var _arguments6 = arguments,
          _this35 = this;

      return new Promise(function (resolve, reject) {
        if (_arguments6.length < 1) {
          throw new Error('Not enough arguments to readDir');
        }
        _this35._nativeCall('readDir', {
          path: checkPath(path),
          onError: function (err) {
            return reject(createError(err, path));
          },
          onSuccess: function (data) {
            return resolve(data);
          }
        });
      });
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      throw new Error('Cannot dispose fs object');
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.FileSystem';
    }
  }, {
    key: 'filesDir',
    get: function () {
      return this._nativeGet('filesDir');
    }
  }, {
    key: 'cacheDir',
    get: function () {
      return this._nativeGet('cacheDir');
    }
  }]);

  return FileSystem;
}(NativeObject);

function create$4() {
  return new FileSystem(true);
}

function createError(err, path) {
  var message = (ERRORS[err] || err) + ': ' + path;
  var code = err in ERRORS ? err : null;
  var error$$1 = new Error(message);
  Object.defineProperties(error$$1, {
    path: { value: path },
    code: { value: code }
  });
  return error$$1;
}

function checkPath(path) {
  try {
    return normalizePath(path);
  } catch (err) {
    throw new Error(toValueString(path) + ' is not a valid file name. ' + err.message);
  }
}

function checkBuffer(buffer) {
  if (ArrayBuffer.isView(buffer)) {
    buffer = buffer.buffer;
  }
  if (buffer instanceof Blob) {
    return getBytes(buffer);
  }
  if (!(buffer instanceof ArrayBuffer)) {
    throw new Error(toValueString(buffer) + ' is not an ArrayBuffer');
  }
  return buffer;
}

var GestureRecognizer = function (_NativeObject10) {
  _inherits(GestureRecognizer, _NativeObject10);

  function GestureRecognizer() {
    _classCallCheck(this, GestureRecognizer);

    return _possibleConstructorReturn(this, (GestureRecognizer.__proto__ || Object.getPrototypeOf(GestureRecognizer)).apply(this, arguments));
  }

  _createClass(GestureRecognizer, [{
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'gesture') {
        this._nativeListen(name, listening);
      } else {
        _get(GestureRecognizer.prototype.__proto__ || Object.getPrototypeOf(GestureRecognizer.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.GestureRecognizer';
    }
  }]);

  return GestureRecognizer;
}(NativeObject);

NativeObject.defineProperties(GestureRecognizer.prototype, {
  type: { type: types.string, default: null },
  target: { type: types.Widget, default: null },
  fingers: { type: types.natural, default: null },
  touches: { type: types.natural, default: null },
  duration: { type: types.natural, default: null },
  direction: { type: types.string, default: null }
});

var ANIMATABLE_PROPERTIES = ['opacity', 'transform'];

/** @type {PropertyDefinitions} */
var PROPERTIES = {
  properties: { default: Object.freeze({}) },
  delay: { type: types.natural, default: 0 },
  duration: { type: types.natural, default: null },
  repeat: {
    type: {
      convert: function (value) {
        if (typeof value !== 'number') {
          throw new Error(toValueString(value) + ' is not a number');
        }
        if (!(isFinite(value) || isNaN(value) || value === Infinity)) {
          throw new Error(toValueString(value) + ' is not a valid number');
        }
        return value;
      },
      encode: function (value) {
        return value === Infinity ? -1 : value;
      }
    },
    default: 1
  },
  reverse: { type: types.boolean, default: false },
  easing: {
    type: types.string,
    choice: ['linear', 'ease-in', 'ease-out', 'ease-in-out'],
    default: 'liniear'
  },
  target: { type: types.Widget, default: null }
};

var Animation = function (_NativeObject11) {
  _inherits(Animation, _NativeObject11);

  function Animation(properties) {
    _classCallCheck(this, Animation);

    var _this37 = _possibleConstructorReturn(this, (Animation.__proto__ || Object.getPrototypeOf(Animation)).call(this, properties));

    _this37._nativeListen('completed', true);
    return _this37;
  }

  _createClass(Animation, [{
    key: '_trigger',
    value: function _trigger(name, event) {
      if (name === 'completed') {
        this.target.off('dispose', this.abort, this);
        if (this._resolve) {
          this._resolve();
        }
        this.dispose();
      } else {
        _get(Animation.prototype.__proto__ || Object.getPrototypeOf(Animation.prototype), '_trigger', this).call(this, name, event);
      }
    }
  }, {
    key: 'start',
    value: function start(resolve, reject) {
      this.target.on('dispose', this.abort, this);
      Object.defineProperties(this, {
        _resolve: { enumerable: false, writable: false, value: resolve },
        _reject: { enumerable: false, writable: false, value: reject }
      });
      this._nativeCall('start');
    }
  }, {
    key: 'abort',
    value: function abort() {
      if (this._reject) {
        this._reject();
      }
      this.dispose();
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Animation';
    }
  }]);

  return Animation;
}(NativeObject);

NativeObject.defineProperties(Animation.prototype, PROPERTIES);

/**
 * @this {import('./Widget').default}
 * @param {{opacity?: number, transform?: Transformation}} properties
 * @param {AnimationOptions} options
 * @returns {Promise}
 */
function animate(properties, options) {
  var _this38 = this;

  var animatedProps = {};
  for (var property in properties) {
    if (ANIMATABLE_PROPERTIES.indexOf(property) !== -1) {
      try {
        var def = this._getPropertyDefinition(property);
        animatedProps[property] = this._convertValue(def, properties[property]);
        this._storeProperty(property, animatedProps[property]);
      } catch (ex) {
        hint(this, 'Ignored invalid animation property value for "' + property + '"');
      }
    } else {
      hint(this, 'Ignored invalid animation property "' + property + '"');
    }
  }
  for (var option in options) {
    if (!(option in PROPERTIES) && option !== 'name') {
      hint(this, 'Ignored invalid animation option "' + option + '"');
    }
  }
  return new Promise(function (resolve, reject) {
    new Animation(Object.assign({}, options, {
      target: _this38,
      properties: animatedProps
    })).start(resolve, reject);
  });
}

var LayoutData = function () {
  _createClass(LayoutData, null, [{
    key: 'from',
    value: function from(value) {
      if (value === 'stretch') {
        return LayoutData.stretch;
      }
      if (value === 'stretchX') {
        return LayoutData.stretchX;
      }
      if (value === 'stretchY') {
        return LayoutData.stretchY;
      }
      if (value === 'center') {
        return LayoutData.center;
      }
      if (!(value instanceof Object)) {
        throw new Error(toValueString(value) + ' is not an object');
      }
      if (value instanceof LayoutData) {
        return value;
      }
      if (value.constructor !== Object) {
        throw new Error(toValueString(value) + ' is not a parameter object');
      }
      return new LayoutData({
        left: has(value, 'left') ? Constraint.from(value.left) : 'auto',
        right: has(value, 'right') ? Constraint.from(value.right) : 'auto',
        top: has(value, 'top') ? Constraint.from(value.top) : 'auto',
        bottom: has(value, 'bottom') ? Constraint.from(value.bottom) : 'auto',
        centerX: has(value, 'centerX') ? normalizeNumber(value.centerX, 0) : 'auto',
        centerY: has(value, 'centerY') ? normalizeNumber(value.centerY, 0) : 'auto',
        baseline: has(value, 'baseline') ? normalizeReference(value.baseline, LayoutData.prev) : 'auto',
        width: has(value, 'width') ? normalizeNumber(value.width) : 'auto',
        height: has(value, 'height') ? normalizeNumber(value.height) : 'auto'
      });
    }
  }, {
    key: 'next',
    get: function () {
      return Constraint.next;
    }
  }, {
    key: 'prev',
    get: function () {
      return Constraint.prev;
    }
  }, {
    key: 'stretch',
    get: function () {
      if (!this._stretch) {
        Object.defineProperty(this, '_stretch', {
          enumerable: false,
          writable: false,
          value: new LayoutData({
            left: zero,
            top: zero,
            right: zero,
            bottom: zero
          })
        });
      }
      return this._stretch;
    }
  }, {
    key: 'stretchX',
    get: function () {
      if (!this._stretchX) {
        Object.defineProperty(this, '_stretchX', {
          enumerable: false,
          writable: false,
          value: new LayoutData({
            left: zero,
            right: zero
          })
        });
      }
      return this._stretchX;
    }
  }, {
    key: 'stretchY',
    get: function () {
      if (!this._stretchY) {
        Object.defineProperty(this, '_stretchY', {
          enumerable: false,
          writable: false,
          value: new LayoutData({
            top: zero,
            bottom: zero
          })
        });
      }
      return this._stretchY;
    }
  }, {
    key: 'center',
    get: function () {
      if (!this._center) {
        Object.defineProperty(this, '_center', {
          enumerable: false,
          writable: false,
          value: new LayoutData({ centerX: 0, centerY: 0 })
        });
      }
      return this._center;
    }
  }]);

  function LayoutData(parameters) {
    _classCallCheck(this, LayoutData);

    if (!(parameters instanceof Object) || parameters.constructor !== Object) {
      throw new Error(toValueString(parameters) + ' is not a parameter object');
    }
    setConstraintValue(this, parameters, 'left');
    setConstraintValue(this, parameters, 'top');
    setConstraintValue(this, parameters, 'right');
    setConstraintValue(this, parameters, 'bottom');
    setDimension$1(this, parameters, 'width');
    setDimension$1(this, parameters, 'height');
    setOffset(this, parameters, 'centerX');
    setOffset(this, parameters, 'centerY');
    setSiblingReference(this, parameters, 'baseline');
  }

  _createClass(LayoutData, [{
    key: 'toString',
    value: function toString() {
      return JSON.stringify({
        left: this.left.toString(),
        right: this.right.toString(),
        top: this.top.toString(),
        bottom: this.bottom.toString(),
        width: this.width,
        height: this.height,
        centerX: this.centerX,
        centerY: this.centerY,
        baseline: referenceToString(this.baseline)
      });
    }
  }, {
    key: 'equals',
    value: function equals(value) {
      if (!(value instanceof LayoutData)) {
        return false;
      }
      return equals$2(value.left, this.left) && equals$2(value.right, this.right) && equals$2(value.top, this.top) && equals$2(value.bottom, this.bottom) && equals$2(value.centerX, this.centerX) && equals$2(value.centerY, this.centerY) && equals$2(value.baseline, this.baseline) && equals$2(value.width, this.width) && equals$2(value.height, this.height);
    }
  }]);

  return LayoutData;
}();

function mergeLayoutData(targetValue, sourceValue) {
  var target = LayoutData.from(targetValue);
  var source = LayoutData.from(sourceValue);
  return LayoutData.from({
    left: has(source, 'left') ? source.left : target.left,
    right: has(source, 'right') ? source.right : target.right,
    top: has(source, 'top') ? source.top : target.top,
    bottom: has(source, 'bottom') ? source.bottom : target.bottom,
    centerX: has(source, 'centerX') ? source.centerX : target.centerX,
    centerY: has(source, 'centerY') ? source.centerY : target.centerY,
    baseline: has(source, 'baseline') ? source.baseline : target.baseline,
    width: has(source, 'width') ? source.width : target.width,
    height: has(source, 'height') ? source.height : target.height
  });
}

function has(layoutDataValue, prop) {
  return layoutDataValue[prop] != null && layoutDataValue[prop] !== 'auto';
}

function setConstraintValue(layoutData, parameters, property) {
  var value = property in parameters ? parameters[property] : 'auto';
  if (value === 'auto' || value instanceof Constraint) {
    return Object.defineProperty(layoutData, property, { enumerable: true, value: value });
  }
  throw new Error('Invalid ' + property + ' constraint ' + toValueString(value));
}

function setDimension$1(layoutData, parameters, property) {
  var value = property in parameters ? parameters[property] : 'auto';
  if (value !== 'auto') {
    checkNumber(value, [0, Infinity]);
  }
  Object.defineProperty(layoutData, property, { enumerable: true, value: value });
}

function setOffset(layoutData, parameters, property) {
  var value = property in parameters ? parameters[property] : 'auto';
  if (value !== 'auto') {
    checkNumber(value, [-Infinity, Infinity], 'Invalid ' + property);
  }
  Object.defineProperty(layoutData, property, { enumerable: true, value: value });
}

function setSiblingReference(layoutData, parameters, property) {
  var value = property in parameters ? parameters[property] : 'auto';
  if (value !== 'auto') {
    checkIsValidSiblingReference(value);
  }
  return Object.defineProperty(layoutData, property, { enumerable: true, value: value });
}

function equals$2(a, b) {
  if (a === b) {
    return true;
  }
  if (a instanceof Constraint && b instanceof Constraint) {
    return a.equals(b);
  }
  return false;
}

/** @type {Array<keyof LayoutData>} */
var layoutDataProps = ['left', 'right', 'top', 'bottom', 'width', 'height', 'centerX', 'centerY', 'baseline'];

var jsxShorthands = {
  center: 'layoutData',
  stretch: 'layoutData',
  stretchX: 'layoutData',
  stretchY: 'layoutData'
};

var defaultGestures = {
  tap: { type: 'tap' },
  longPress: { type: 'longPress' },
  pan: { type: 'pan' },
  panLeft: { type: 'pan', direction: 'left' },
  panRight: { type: 'pan', direction: 'right' },
  panUp: { type: 'pan', direction: 'up' },
  panDown: { type: 'pan', direction: 'down' },
  panHorizontal: { type: 'pan', direction: 'horizontal' },
  panVertical: { type: 'pan', direction: 'vertical' },
  swipeLeft: { type: 'swipe', direction: 'left' },
  swipeRight: { type: 'swipe', direction: 'right' },
  swipeUp: { type: 'swipe', direction: 'up' },
  swipeDown: { type: 'swipe', direction: 'down' }
};

/**
 * @abstract
 */

var Widget = function (_NativeObject12) {
  _inherits(Widget, _NativeObject12);

  function Widget() {
    _classCallCheck(this, Widget);

    return _possibleConstructorReturn(this, (Widget.__proto__ || Object.getPrototypeOf(Widget)).apply(this, arguments));
  }

  _createClass(Widget, [{
    key: 'appendTo',


    /**
     * @param {import('./widgets/Composite')} widget
     */
    value: function appendTo(widget) {
      this._checkDisposed();
      widget = widget instanceof WidgetCollection ? widget.first() : widget;
      if (!(widget instanceof NativeObject)) {
        throw new Error('Cannot append to non-widget ' + toValueString(widget));
      }
      this._setParent(widget);
      return this;
    }

    /**
     * @param {import('./widgets/Composite')} widget
     */

  }, {
    key: 'insertBefore',
    value: function insertBefore(widget) {
      this._checkDisposed();
      widget = widget instanceof WidgetCollection ? widget.first() : widget;
      if (!(widget instanceof NativeObject)) {
        throw new Error('Cannot insert before non-widget ' + toValueString(widget));
      }
      var parent = widget.parent();
      if (!parent) {
        throw new Error('Cannot insert before orphan ' + toValueString(widget));
      }
      var index = parent.$children.indexOf(widget);
      this._setParent(parent, index);
      return this;
    }

    /**
     * @param {import('./widgets/Composite')} widget
     */

  }, {
    key: 'insertAfter',
    value: function insertAfter(widget) {
      this._checkDisposed();
      widget = widget instanceof WidgetCollection ? widget.first() : widget;
      if (!(widget instanceof NativeObject)) {
        throw new Error('Cannot insert after non-widget ' + toValueString(widget));
      }
      var parent = widget.parent();
      if (!parent) {
        throw new Error('Cannot insert after orphan ' + toValueString(widget));
      }
      this.detach();
      var index = parent.$children.indexOf(widget);
      this._setParent(parent, index + 1);
      return this;
    }
  }, {
    key: 'detach',
    value: function detach() {
      this._checkDisposed();
      this._setParent(null);
      return this;
    }

    /**
     * @param {Selector} selector
     */

  }, {
    key: 'parent',
    value: function parent(selector) {
      if (!selector || !this._parent) {
        return this._parent || null;
      }
      var candidate = this._parent;
      var filter = getFilter(selector);
      while (candidate && !filter(candidate)) {
        candidate = candidate.parent();
      }
      return candidate;
    }

    /**
     * @param {Selector} selector
     * @returns {WidgetCollection}
     */

  }, {
    key: 'siblings',
    value: function siblings(selector) {
      var _this40 = this;

      if (!this._parent) {
        return new WidgetCollection([]);
      }
      return this._parent._children(function (widget) {
        return widget !== _this40;
      }).filter(selector);
    }

    /**
     * @param {string} value
     */

  }, {
    key: 'toString',
    value: function toString() {
      var type = this.constructor.name;
      var cidAttr = '[cid="' + this.cid + '"]';
      var id = this.id ? '#' + this.id : '';
      var classes = this.classList.length ? '.' + this.classList.join('.') : '';
      return type + cidAttr + id + classes;
    }
  }, {
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      var result = _get(Widget.prototype.__proto__ || Object.getPrototypeOf(Widget.prototype), '_getXMLAttributes', this).call(this);
      if (this.id) {
        result.push(['id', this.id]);
      }
      if (this.class) {
        result.push(['class', this.class]);
      }
      var bounds = this.bounds;
      result.push(['bounds', '{left: ' + Math.round(bounds.left) + ', top: ' + Math.round(bounds.top) + ', ' + ('width: ' + Math.round(bounds.width) + ', height: ' + Math.round(bounds.height) + '}')]);
      if (!this.enabled) {
        result.push(['enabled', 'false']);
      }
      if (!this.visible) {
        result.push(['visible', 'false']);
      }
      return result;
    }

    /**
     * @param {import('./widgets/Composite').default} parent
     * @param {number} index
     */

  }, {
    key: '_setParent',
    value: function _setParent(parent, index) {
      if (this._parent) {
        this._parent._removeChild(this);
      }
      Object.defineProperty(this, '_parent', { enumerable: false, writable: true, value: parent });
      if (this._parent) {
        this._parent._addChild(this, index);
      }
    }

    /**
     * @param {string} name
     * @param {boolean} listening
     */

  }, {
    key: '_listen',
    value: function _listen(name, listening) {
      var _this41 = this;

      if (this._isDisposed) {
        return;
      }
      if (this.gestures[name]) {
        if (listening) {
          var properties = Object.assign({ target: this }, this.gestures[name]);
          var recognizer = new GestureRecognizer(properties).on('gesture', function (event) {
            if (event.translation) {
              event.translationX = event.translation.x;
              event.translationY = event.translation.y;
            }
            if (event.velocity) {
              event.velocityX = event.velocity.x;
              event.velocityY = event.velocity.y;
            }
            _get(Widget.prototype.__proto__ || Object.getPrototypeOf(Widget.prototype), '_trigger', _this41).call(_this41, name, event);
          });
          if (!this._recognizers) {
            Object.defineProperty(this, '_recognizers', { enumerable: false, writable: false, value: {} });
          }
          this._recognizers[name] = recognizer;
          this.on('dispose', recognizer.dispose, recognizer);
        } else if (this._recognizers && name in this._recognizers) {
          this._recognizers[name].dispose();
          delete this._recognizers[name];
        }
      } else {
        _get(Widget.prototype.__proto__ || Object.getPrototypeOf(Widget.prototype), '_listen', this).call(this, name, listening);
      }
    }

    /**
     * @param {string} name
     * @param {object} event
     */

  }, {
    key: '_trigger',
    value: function _trigger(name, event) {
      if (name === 'resize') {
        return _get(Widget.prototype.__proto__ || Object.getPrototypeOf(Widget.prototype), '_trigger', this).call(this, name, types.Bounds.decode(event.bounds));
      }
      return _get(Widget.prototype.__proto__ || Object.getPrototypeOf(Widget.prototype), '_trigger', this).call(this, name, event);
    }
  }, {
    key: '_release',
    value: function _release() {
      if (this._parent) {
        this._parent._removeChild(this);
        this._parent = null;
      }
    }

    /**
     * @param {string[]} properties
     */

  }, {
    key: '_reorderProperties',
    value: function _reorderProperties(properties) {
      var layoutDataIndex = properties.indexOf('layoutData');
      if (layoutDataIndex !== -1) {
        var removed = properties.splice(layoutDataIndex, 1);
        return removed.concat(properties);
      }
      return properties;
    }
  }, {
    key: 'class',
    set: function (value) {
      if (this._isDisposed) {
        hint(this, 'Cannot set property "class" on disposed object');
        return;
      }
      Object.defineProperty(this, '_classList', {
        enumerable: true,
        writable: true,
        value: types.string.convert(value).trim().split(/\s+/)
      });
      this._triggerChangeEvent('class', this.class);
    },
    get: function () {
      if (this._isDisposed) {
        return undefined;
      }
      return this.classList.join(' ');
    }
  }, {
    key: 'layoutData',
    set: function (value) {
      var _this42 = this;

      if (this._isDisposed) {
        hint(this, 'Cannot set property "layoutData" on disposed object');
        return;
      }
      var oldLayoutData = this._layoutData;
      if (oldLayoutData && oldLayoutData.equals(value)) {
        return;
      }
      Object.defineProperty(this, '_layoutData', {
        enumerable: false,
        writable: true,
        value: /** @type {LayoutData} */value ? LayoutData.from(value) : new LayoutData({})
      });
      this._triggerChangeEvent('layoutData', this._layoutData);
      layoutDataProps.forEach(function (prop) {
        var oldValue = oldLayoutData ? oldLayoutData[prop] : 'auto';
        if (oldValue !== _this42._layoutData[prop]) {
          _this42._triggerChangeEvent(prop, _this42._layoutData[prop]);
        }
      });
    },
    get: function () {
      if (this._isDisposed) {
        return undefined;
      }
      if (!this._layoutData) {
        Object.defineProperty(this, '_layoutData', {
          enumerable: false,
          writable: true,
          value: /** @type {LayoutData} */new LayoutData({})
        });
      }
      return this._layoutData;
    }
  }, {
    key: 'classList',
    get: function () {
      if (this._isDisposed) {
        return undefined;
      }
      if (!this._classList) {
        Object.defineProperty(this, '_classList', {
          enumerable: true,
          writable: true,
          value: []
        });
      }
      return this._classList;
    }
  }, {
    key: 'data',
    get: function () {
      if (this._isDisposed) {
        return undefined;
      }
      if (!this.$data) {
        Object.defineProperty(this, '$data', {
          enumerable: false, writable: false, value: {}
        });
      }
      return this.$data;
    }
  }, {
    key: 'absoluteBounds',
    get: function () {
      if (this._isDisposed) {
        return undefined;
      }
      return types.Bounds.decode(this._nativeGet('absoluteBounds'));
    }
  }, {
    key: 'id',
    set: function (value) {
      /** @type {string} */
      var id = types.string.convert(value);
      Object.defineProperty(this, '_id', { enumerable: false, writable: false, value: id });
    },
    get: function () {
      if (this._isDisposed) {
        return undefined;
      }
      return this._id || '';
    }
  }, {
    key: 'gestures',
    set: function (gestures) {
      /** @type {typeof defaultGestures} */
      var value = Object.assign({}, defaultGestures, gestures);
      Object.defineProperty(this, '_gestures', { enumerable: false, writable: true, value: value });
    },
    get: function () {
      if (!this._gestures) {
        /** @type {typeof defaultGestures} */
        var value = Object.assign({}, defaultGestures);
        Object.defineProperty(this, '_gestures', { enumerable: false, writable: true, value: value });
      }
      return this._gestures;
    }
  }, {
    key: 'excludeFromLayout',
    set: function (value) {
      if (this._excludeFromLayout !== !!value) {
        Object.defineProperty(this, '_excludeFromLayout', { enumerable: false, writable: true, value: !!value });
      }
      if (this._parent) {
        this._parent._scheduleRenderChildren();
      }
      this._triggerChangeEvent('excludeFromLayout', this._excludeFromLayout);
    },
    get: function () {
      return !!this._excludeFromLayout;
    }
  }, {
    key: Symbol.toStringTag,
    get: function () {
      return this.constructor.name;
    }
  }]);

  return Widget;
}(NativeObject);

NativeObject.defineProperties(Widget.prototype, {
  enabled: {
    type: types.boolean,
    default: true
  },
  visible: {
    type: types.boolean,
    default: true
  },
  elevation: {
    type: types.natural,
    default: 0
  },
  bounds: {
    type: types.Bounds,
    readonly: true,
    nocache: true
  },
  background: {
    type: types.Shader,
    default: 'initial'
  },
  opacity: {
    type: types.fraction,
    default: 1
  },
  transform: {
    type: types.Transformation,
    default: Object.freeze({
      rotation: 0,
      scaleX: 1,
      scaleY: 1,
      translationX: 0,
      translationY: 0,
      translationZ: 0
    })
  },
  highlightOnTouch: {
    type: types.boolean,
    default: false
  },
  cornerRadius: {
    type: types.number,
    default: 0
  },
  padding: {
    type: types.BoxDimensions,
    default: Object.freeze({ left: 0, right: 0, top: 0, bottom: 0 })
  }
});

layoutDataProps.forEach(function (prop) {
  Object.defineProperty(Widget.prototype, prop, {
    set: function (value) {
      this.layoutData = LayoutData.from(Object.assign({}, this.layoutData, _defineProperty({}, prop, value)));
    },
    get: function () {
      return this.layoutData[prop];
    }
  });
  NativeObject.defineEvent(Widget.prototype, prop + 'Changed', true);
});

NativeObject.defineChangeEvents(Widget.prototype, ['layoutData', 'class']);

NativeObject.defineEvents(Widget.prototype, {
  tap: true,
  longPress: true,
  pan: true,
  panLeft: true,
  panRight: true,
  panUp: true,
  panDown: true,
  panHorizontal: true,
  panVertical: true,
  swipeLeft: true,
  swipeRight: true,
  swipeUp: true,
  swipeDown: true,
  touchStart: { native: true },
  touchMove: { native: true },
  touchEnd: { native: true },
  touchCancel: { native: true },
  resize: {
    native: true,
    changes: 'bounds',
    changeValue: function (_ref7) {
      var { left: left, top: top, width: width, height: height, bounds: bounds } = _ref7;
      return bounds || { left: left, top: top, width: width, height: height };
    }
  },
  addChild: true,
  removeChild: true
});

Widget.prototype.animate = animate;

Widget.prototype[JSX.jsxFactory] = createElement$1;

/** @this {import("./JsxProcessor").default} */
function createElement$1(Type, attributes) {
  var finalAttributes = this.withShorthands(attributes, jsxShorthands, mergeLayoutData);
  return this.createNativeObject(Type, finalAttributes);
}

var selectorRegex = /^(\*|([#.A-Z][A-Za-z0-9_-]+))$/;
var numberRegex$1 = /^[+-]?([0-9]+|[0-9]*\.[0-9]+)$/;
var zeroPercent = new Percent(0);

var Constraint = function () {
  _createClass(Constraint, null, [{
    key: 'from',
    value: function from(constraintValue) {
      if (constraintValue === true) {
        return zero;
      }
      if (typeof constraintValue === 'string') {
        var str = constraintValue.trim();
        if (str.indexOf(' ') !== -1) {
          return fromArray(str.split(/\s+/));
        }
        if (numberRegex$1.test(str)) {
          return new Constraint(zeroPercent, parseFloat(str));
        }
        return new Constraint(normalizeReference(str), 0);
      }
      if (Array.isArray(constraintValue)) {
        return fromArray(constraintValue);
      }
      if (typeof constraintValue === 'number') {
        if (constraintValue === 0) {
          return zero;
        }
        return new Constraint(zeroPercent, normalizeNumber(constraintValue));
      }
      if (constraintValue instanceof Widget || typeof constraintValue === 'symbol' || Percent.isValidPercentValue(constraintValue)) {
        return new Constraint(normalizeReference(constraintValue), 0);
      }
      if ('reference' in constraintValue || 'offset' in constraintValue) {
        return fromArray([constraintValue.reference || zeroPercent, constraintValue.offset || 0]);
      }
      throw new Error('Invalid constraint ' + toValueString(constraintValue));
    }
  }]);

  function Constraint(reference, offset) {
    _classCallCheck(this, Constraint);

    if (typeof reference === 'string' && !selectorRegex.test(reference)) {
      throw new Error('Invalid sibling selector ' + toValueString(reference));
    }
    if (!(reference instanceof Percent)) {
      checkIsValidSiblingReference(reference);
    }
    checkNumber(offset);
    Object.defineProperty(this, 'reference', { enumerable: true, value: reference });
    Object.defineProperty(this, 'offset', { enumerable: true, value: offset });
  }

  _createClass(Constraint, [{
    key: 'toString',
    value: function toString() {
      return referenceToString(this.reference) + ' ' + this.offset;
    }
  }, {
    key: 'toArray',
    value: function toArray() {
      return [this.reference, this.offset];
    }
  }, {
    key: 'equals',
    value: function equals(value) {
      if (!(value instanceof Constraint)) {
        return false;
      }
      if (value.offset !== this.offset) {
        return false;
      }
      if (value.reference instanceof Percent && this.reference instanceof Percent) {
        return value.reference.percent === this.reference.percent;
      }
      return value.reference === this.reference;
    }
  }]);

  return Constraint;
}();

Constraint.next = Symbol('next()');
Constraint.prev = Symbol('prev()');

function checkIsValidSiblingReference(reference) {
  if (typeof reference === 'string' && !selectorRegex.test(reference)) {
    throw new Error('Invalid sibling selector ' + toValueString(reference));
  }
  if (typeof reference !== 'string' && !(reference instanceof Widget) && reference !== Constraint.next && reference !== Constraint.prev) {
    throw new Error('Invalid constraint reference ' + toValueString(reference));
  }
}

function referenceToString(reference) {
  if (reference instanceof Percent) {
    return reference + '%';
  }
  if (reference instanceof Widget) {
    return reference.constructor.name + '[cid="' + reference.cid + '"]';
  }
  if (reference === Constraint.next) {
    return 'next()';
  }
  if (reference === Constraint.prev) {
    return 'prev()';
  }
  return reference;
}

function normalizeReference(reference, shorthand) {
  if (reference === true && shorthand !== undefined) {
    return shorthand;
  }
  if (Percent.isValidPercentValue(reference)) {
    return Percent.from(reference);
  }
  if (reference instanceof Widget || reference === Constraint.next || reference === Constraint.prev) {
    return reference;
  }
  if (typeof reference === 'string') {
    var str = reference.trim();
    if (str === 'prev()') {
      return Constraint.prev;
    }
    if (str === 'next()') {
      return Constraint.next;
    }
    if (selectorRegex.test(str)) {
      return str;
    }
  }
  throw new Error(toValueString(reference) + ' is not a percentage or widget reference');
}

function normalizeNumber(value, shorthand) {
  if (value === true && shorthand !== undefined) {
    return shorthand;
  }
  if (typeof value === 'string' && numberRegex$1.test(value)) {
    return parseFloat(value);
  }
  return value;
}

var zero = new Constraint(new Percent(0), 0);
function fromArray(array) {
  if (array.length !== 2) {
    throw new Error('Constraint array requires exactly 2 elements but has ' + array.length);
  }
  return new Constraint(normalizeReference(array[0]), normalizeNumber(array[1]));
}

var PHASE_CONSTANTS = {
  NONE: { value: 0 },
  CAPTURING_PHASE: { value: 1 },
  AT_TARGET: { value: 2 },
  BUBBLING_PHASE: { value: 3 }
};

var Event = function () {
  function Event(type, config) {
    _classCallCheck(this, Event);

    if (arguments.length < 1) {
      throw new Error('Not enough arguments to Event');
    }
    Object.defineProperties(this, {
      $timeStamp: { enumerable: false, writable: true, value: Date.now() },
      $type: { enumerable: false, writable: true, value: type || '' },
      $bubbles: { enumerable: false, writable: true, value: config && !!config.bubbles || false },
      $cancelable: { enumerable: false, writable: true, value: config && !!config.cancelable || false },
      $target: { enumerable: false, writable: true, value: null },
      $defaultPrevented: { enumerable: false, writable: true, value: false }
    });
  }

  _createClass(Event, [{
    key: 'initEvent',
    value: function initEvent(type, bubbles, cancelable) {
      if (arguments.length < 3) {
        throw new Error('Not enough arguments to initEvent');
      }
      this.$type = type + '';
      this.$bubbles = !!bubbles;
      this.$cancelable = !!cancelable;
    }
  }, {
    key: 'stopPropagation',
    value: function stopPropagation() {}
  }, {
    key: 'stopImmediatePropagation',
    value: function stopImmediatePropagation() {}
  }, {
    key: 'preventDefault',
    value: function preventDefault() {
      if (this.$cancelable) {
        this.$defaultPrevented = true;
      }
    }
  }, {
    key: 'type',
    get: function () {
      return this.$type;
    }
  }, {
    key: 'timeStamp',
    get: function () {
      return this.$timeStamp;
    }
  }, {
    key: 'bubbles',
    get: function () {
      return this.$bubbles;
    }
  }, {
    key: 'cancelable',
    get: function () {
      return this.$cancelable;
    }
  }, {
    key: 'target',
    get: function () {
      return this.$target;
    }
  }, {
    key: 'currentTarget',
    get: function () {
      return this.$target;
    }
  }, {
    key: 'defaultPrevented',
    get: function () {
      return this.$defaultPrevented;
    }
  }, {
    key: 'eventPhase',
    get: function () {
      return 0;
    }
  }, {
    key: 'isTrusted',
    get: function () {
      return false;
    }
  }]);

  return Event;
}();

Object.defineProperties(Event, PHASE_CONSTANTS);
Object.defineProperties(Event.prototype, PHASE_CONSTANTS);

function addDOMEventTargetMethods(target) {

  if (typeof target.addEventListener === 'function') {
    return;
  }

  var listeners = void 0;

  target.addEventListener = function (type, listener /*, useCapture*/) {
    if (arguments.length < 2) {
      throw new Error('Not enough arguments to addEventListener');
    }
    if (!listeners) {
      listeners = [];
    }
    if (!(type in listeners)) {
      listeners[type] = [];
    }
    if (!listeners[type].includes(listener)) {
      listeners[type].push(listener);
    }
  };

  target.removeEventListener = function (type, listener /*, useCapture*/) {
    if (arguments.length < 2) {
      throw new Error('Not enough arguments to removeEventListener');
    }
    if (listeners && type in listeners) {
      var index = listeners[type].indexOf(listener);
      if (index !== -1) {
        listeners[type].splice(index, 1);
      }
    }
  };

  target.dispatchEvent = function (event) {
    if (arguments.length < 1) {
      throw new Error('Not enough arguments to dispatchEvent');
    }
    if (!(event instanceof Event)) {
      throw new Error('Invalid event given to dispatchEvent');
    }
    event.$target = target;
    if (listeners && event.type in listeners) {
      for (var listener of listeners[event.type]) {
        listener.call(this, event);
      }
    }
    return !event.defaultPrevented;
  };
}

function defineEventHandlerProperties(target, types) {
  types.forEach(function (type) {
    return defineEventHandlerProperty(target, type);
  });
}

function defineEventHandlerProperty(target, type) {
  var handler = 'on' + type;
  var listener = null;
  Object.defineProperty(target, handler, {
    get: function () {
      return listener;
    },
    set: function (value) {
      // ignore other types, mimicks the behavior of Firefox and Chromium
      if (typeof value === 'function') {
        if (listener) {
          target.removeEventListener(type, listener);
        }
        listener = value;
        target.addEventListener(type, listener);
      }
    }
  });
}

function addDOMDocument(target) {
  var HTMLElement = function () {
    function HTMLElement(tagName) {
      _classCallCheck(this, HTMLElement);

      this.tagName = (tagName || '').toUpperCase();
      this.children = [];
    }

    _createClass(HTMLElement, [{
      key: 'setAttribute',
      value: function setAttribute() {}
    }, {
      key: 'appendChild',
      value: function appendChild(el) {
        this.children.push(el);
        handleElementInserted(this, el, target);
        return el;
      }
    }, {
      key: 'cloneNode',
      value: function cloneNode() {
        return new HTMLElement();
      }
    }, {
      key: 'lastChild',
      value: function lastChild() {
        return new HTMLElement();
      }
    }]);

    return HTMLElement;
  }();

  target.document = {
    documentElement: {},
    createDocumentFragment: function () {
      return new HTMLElement();
    },
    createElement: function (tagName) {
      return new HTMLElement(tagName);
    },

    location: { href: '' },
    readyState: 'loading',
    head: new HTMLElement('head'),
    getElementsByTagName: function (tagName) {
      return this.head.children.filter(function (node) {
        return node.tagName === tagName.toUpperCase();
      });
    },
    createEvent: function (type) {
      return new Event(type);
    }
  };

  addDOMEventTargetMethods(target.document);
  if (typeof target.location === 'undefined') {
    target.location = target.document.location;
  }

  tabris.once('start', function () {
    target.document.readyState = 'complete';
    var event = new Event('DOMContentLoaded', false, false);
    target.document.dispatchEvent(event);
  });
}

function handleElementInserted(parent, child, target) {
  if (parent.tagName === 'HEAD' && child.tagName === 'SCRIPT' && child.src) {
    var result = void 0;
    try {
      result = tabris._client.loadAndExecute(child.src, '', '');
    } catch (ex) {
      error('Error loading ' + child.src + ':', ex);
      log(ex.stack);
      if (typeof child.onerror === 'function') {
        child.onerror.call(target, ex);
      }
      return;
    }
    if (result.loadError) {
      if (typeof child.onerror === 'function') {
        child.onerror.call(target, new Error('Could not load ' + child.src));
      }
    } else if (typeof child.onload === 'function') {
      child.onload.call(target);
    }
  }
}

function addWindowTimerMethods(target) {

  if (typeof target.setTimeout === 'function') {
    return;
  }

  var idSequence = 0;

  function createTimer(fn, delay, repeat, args) {
    var id = idSequence++;
    // If tabris is not ready, create the timer on load.
    // However, clearTimeout won't work until after load.
    var create = function () {
      return tabris.app._nativeCall('startTimer', {
        id: id, delay: delay, repeat: repeat, callback: createNativeCallback(fn, target, args)
      });
    };
    if (tabris.started) {
      create();
    } else {
      tabris.once('start', create);
    }
    return id;
  }

  target.setTimeout = function (fn, delay) {
    if (arguments.length < 1) {
      throw new TypeError('Not enough arguments to setTimeout');
    }
    if (typeof fn !== 'function') {
      throw new TypeError('Illegal argument to setTimeout: not a function');
    }
    var args = Array.prototype.slice.call(arguments, 2);
    return createTimer(fn, adjustDelay(delay), false, args);
  };

  target.setInterval = function (fn, delay) {
    if (arguments.length < 1) {
      throw new TypeError('Not enough arguments to setInterval');
    }
    if (typeof fn !== 'function') {
      throw new TypeError('Illegal argument to setInterval: not a function');
    }
    var args = Array.prototype.slice.call(arguments, 2);
    return createTimer(fn, adjustDelay(delay), true, args);
  };

  target.clearTimeout = target.clearInterval = function (id) {
    return tabris.app._nativeCall('cancelTimer', { id: id });
  };
}

function adjustDelay(value) {
  return typeof value === 'number' && isFinite(value) ? Math.max(0, Math.round(value)) : 0;
}

var NativeStore = function (_NativeObject13) {
  _inherits(NativeStore, _NativeObject13);

  function NativeStore(secure) {
    _classCallCheck(this, NativeStore);

    return _possibleConstructorReturn(this, (NativeStore.__proto__ || Object.getPrototypeOf(NativeStore)).call(this, secure));
  }

  _createClass(NativeStore, [{
    key: '_nativeCreate',


    /** @override */
    value: function _nativeCreate(secure) {
      this.secure = secure;
      _get(NativeStore.prototype.__proto__ || Object.getPrototypeOf(NativeStore.prototype), '_nativeCreate', this).call(this);
    }
  }, {
    key: '_getXMLElementName',
    value: function _getXMLElementName() {
      return 'Storage';
    }
  }, {
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      return [['length', this.keys.length]];
    }
  }, {
    key: '_getXMLContent',
    value: function _getXMLContent() {
      var _this44 = this;

      return this.keys.map(function (key) {
        var value = _this44._nativeCall('get', { key: key });
        var item = key.replace(/[^a-zA-Z0-9_.:-]/g, '');
        var lines = value.split('\n');
        if (lines.length === 1) {
          return '  <' + item + '>' + value + '</' + item + '>';
        }
        return '  <' + item + '>\n' + lines.map(function (line) {
          return '    ' + line;
        }).join('\n') + '\n  </' + item + '>';
      });
    }
  }, {
    key: 'keys',
    get: function () {
      return this._nativeCall('keys');
    }
  }, {
    key: '_nativeType',
    get: function () {
      return this.secure ? 'tabris.SecureStore' : 'tabris.ClientStore';
    }
  }]);

  return NativeStore;
}(NativeObject);

var Storage = function () {
  function Storage() {
    _classCallCheck(this, Storage);

    var nativeObject = arguments[0];
    if (!(nativeObject instanceof NativeObject)) {
      throw new Error('Cannot instantiate Storage');
    }
    Object.defineProperty(this, '_nativeObject', { value: nativeObject });
  }

  // Note: key and length methods currently not supported

  _createClass(Storage, [{
    key: 'setItem',
    value: function setItem(key, value) {
      if (arguments.length < 2) {
        throw new TypeError("Not enough arguments to 'setItem'");
      }
      this._nativeObject._nativeCall('add', {
        key: encode(key),
        value: encode(value)
      });
    }
  }, {
    key: 'getItem',
    value: function getItem(key) {
      if (arguments.length < 1) {
        throw new TypeError("Not enough arguments to 'getItem'");
      }
      var result = this._nativeObject._nativeCall('get', { key: encode(key) });
      // Note: iOS can not return null, only undefined:
      return result === undefined ? null : result;
    }
  }, {
    key: 'removeItem',
    value: function removeItem(key) {
      if (arguments.length < 1) {
        throw new TypeError("Not enough arguments to 'removeItem'");
      }
      this._nativeObject._nativeCall('remove', { keys: [encode(key)] });
    }
  }, {
    key: 'clear',
    value: function clear() {
      this._nativeObject._nativeCall('clear');
    }
  }, {
    key: 'key',
    value: function key(index) {
      return this._nativeObject.keys[index] || null;
    }
  }, {
    key: toXML$$1,
    value: function () {
      return this._nativeObject[toXML$$1]();
    }
  }, {
    key: 'length',
    get: function () {
      return this._nativeObject.keys.length;
    }
  }]);

  return Storage;
}();

function encode(value) {
  return '' + value;
}

function create$5(secure) {
  return new Storage(new NativeStore(secure));
}

var Action = function (_Widget) {
  _inherits(Action, _Widget);

  function Action() {
    _classCallCheck(this, Action);

    return _possibleConstructorReturn(this, (Action.__proto__ || Object.getPrototypeOf(Action)).apply(this, arguments));
  }

  _createClass(Action, [{
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      return _get(Action.prototype.__proto__ || Object.getPrototypeOf(Action.prototype), '_getXMLAttributes', this).call(this).concat([['title', this.title]]);
    }

    /** @this {import("../JsxProcessor").default} */

  }, {
    key: JSX.jsxFactory,
    value: function (Type, attributes) {
      var children = this.getChildren(attributes);
      var normalAttributes = this.withoutChildren(attributes);
      return _get(Action.prototype.__proto__ || Object.getPrototypeOf(Action.prototype), JSX.jsxFactory, this).call(this, Type, this.withContentText(normalAttributes, children, 'title'));
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Action';
    }
  }]);

  return Action;
}(Widget);

NativeObject.defineProperties(Action.prototype, {
  image: { type: types.ImageValue, default: null },
  placement: {
    type: types.string,
    choice: ['default', 'navigation', 'overflow'],
    default: 'default'
  },
  title: { type: types.string, default: '' }
});

NativeObject.defineEvents(Action.prototype, {
  select: { native: true }
});

var Popup = function (_NativeObject14) {
  _inherits(Popup, _NativeObject14);

  function Popup() {
    _classCallCheck(this, Popup);

    return _possibleConstructorReturn(this, (Popup.__proto__ || Object.getPrototypeOf(Popup)).apply(this, arguments));
  }

  _createClass(Popup, [{
    key: 'open',
    value: function open() {
      if (this.isDisposed()) {
        throw new Error('Can not open a popup that was disposed');
      }
      this._nativeCall('open');
      return this;
    }
  }, {
    key: 'close',
    value: function close() {
      if (this._autoDispose) {
        this.dispose();
      }
      return this;
    }

    /** @this {import("../JsxProcessor").default} */

  }, {
    key: JSX.jsxFactory,
    value: function (Type, attributes) {
      return this.createNativeObject(Type, attributes);
    }
  }]);

  return Popup;
}(NativeObject);

var ActionSheet = function (_Popup) {
  _inherits(ActionSheet, _Popup);

  _createClass(ActionSheet, null, [{
    key: 'open',
    value: function open(actionSheet) {
      if (!(actionSheet instanceof ActionSheet)) {
        throw new Error('Not an ActionSheet: ' + toValueString(actionSheet));
      }
      return actionSheet.open();
    }

    /**
     * @param {Partial<ActionSheet>} properties
     */

  }]);

  function ActionSheet(properties) {
    _classCallCheck(this, ActionSheet);

    var _this47 = _possibleConstructorReturn(this, (ActionSheet.__proto__ || Object.getPrototypeOf(ActionSheet)).call(this, properties));

    Object.defineProperties(_this47, {
      _index: { enumerable: false, writable: true, value: null },
      _action: { enumerable: false, writable: true, value: null }
    });
    _this47._autoDispose = true;
    _this47._nativeListen('select', true);
    return _this47;
  }

  _createClass(ActionSheet, [{
    key: '_trigger',
    value: function _trigger(name, event) {
      if (name === 'select') {
        this._index = event.index;
        this._action = this.actions[this._index];
        _get(ActionSheet.prototype.__proto__ || Object.getPrototypeOf(ActionSheet.prototype), '_trigger', this).call(this, 'select', Object.assign(event, { action: this._action }));
      } else if (name === 'close') {
        _get(ActionSheet.prototype.__proto__ || Object.getPrototypeOf(ActionSheet.prototype), '_trigger', this).call(this, 'close', Object.assign(event, { index: this._index, action: this._action }));
        this.dispose();
      } else {
        return _get(ActionSheet.prototype.__proto__ || Object.getPrototypeOf(ActionSheet.prototype), '_trigger', this).call(this, name, event);
      }
    }

    /** @this {import("../JsxProcessor").default} */

  }, {
    key: JSX.jsxFactory,
    value: function (Type, attributes) {
      var children = this.getChildren(attributes) || [];
      var normalAttributes = this.withoutChildren(attributes);
      normalAttributes = this.withContentChildren(normalAttributes, children.filter(function (child) {
        return child instanceof Object;
      }), 'actions');
      normalAttributes = this.withContentText(normalAttributes, children.filter(function (child) {
        return !(child instanceof Object);
      }), 'message');
      return this.createNativeObject(Type, normalAttributes);
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.ActionSheet';
    }
  }]);

  return ActionSheet;
}(Popup);

NativeObject.defineProperties(ActionSheet.prototype, {
  title: { type: types.string, default: '' },
  message: { type: types.string, default: '' },
  actions: /** @type {TabrisProp<readonly ActionSheetItem[], ActionSheetItem[]>} */{
    type: {
      convert: function (value) {
        if (!Array.isArray(value)) {
          throw new Error(toValueString(value) + ' is not an array');
        }
        return Object.freeze(value.map(ActionSheetItem.from));
      },
      encode: function (value) {
        return value.map(function (action) {
          return {
            title: action.title,
            image: types.ImageValue.encode(action.image),
            style: action.style
          };
        });
      }
    },
    default: Object.freeze([])
  }
});

NativeObject.defineEvents(ActionSheet.prototype, {
  close: { native: true },
  select: { native: true }
});

var ActionSheetItem = function () {

  /**
   * @param {{title?: any, image?: any, style?: any}} param0
   */
  function ActionSheetItem() {
    var { title: title, image: image, style: style } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ActionSheetItem);

    Object.defineProperty(this, 'title', { value: types.string.convert(title), enumerable: true });
    Object.defineProperty(this, 'image', { value: types.ImageValue.convert(image), enumerable: true });
    Object.defineProperty(this, 'style', {
      value: allowOnlyValues(style || 'default', ['default', 'cancel', 'destructive'], 'style'),
      enumerable: true
    });
  }

  _createClass(ActionSheetItem, [{
    key: 'toString',
    value: function toString() {
      return this.title || '[object ActionSheetItem]';
    }

    /** @this {import("./JsxProcessor").default} */

  }, {
    key: JSX.jsxFactory,
    value: function (Type, attributes) {
      var children = this.getChildren(attributes);
      var normalAttributes = this.withoutChildren(attributes);
      return new Type(this.withContentText(normalAttributes, children, 'title'));
    }

    /**
     * @param {any} value
     */

  }], [{
    key: 'from',
    value: function from(value) {
      if (value instanceof ActionSheetItem) {
        return value;
      }
      if (value.constructor !== Object) {
        throw new Error('Can not convert a non-object to an ActionSheetItem');
      }
      try {
        return new ActionSheetItem(allowOnlyKeys(value, ['title', 'image', 'style']));
      } catch (ex) {
        throw new Error('Can not convert to an ActionSheetItem: ' + ex.message);
      }
    }
  }]);

  return ActionSheetItem;
}();

Object.defineProperty(ActionSheetItem.prototype, 'title', { value: '' });
Object.defineProperty(ActionSheetItem.prototype, 'image', {
  value: /** @type {import('./Image').default} */null
});
Object.defineProperty(ActionSheetItem.prototype, 'style', {
  value: /** @type {'default'|'cancel'|'destructive'} */'default' });

var ActivityIndicator = function (_Widget2) {
  _inherits(ActivityIndicator, _Widget2);

  function ActivityIndicator() {
    _classCallCheck(this, ActivityIndicator);

    return _possibleConstructorReturn(this, (ActivityIndicator.__proto__ || Object.getPrototypeOf(ActivityIndicator)).apply(this, arguments));
  }

  _createClass(ActivityIndicator, [{
    key: '_nativeType',
    get: function () {
      return 'tabris.ActivityIndicator';
    }
  }]);

  return ActivityIndicator;
}(Widget);

NativeObject.defineProperties(ActivityIndicator.prototype, {
  tintColor: { type: 'ColorValue', default: 'initial' }
});

var TextInput = function (_Widget3) {
  _inherits(TextInput, _Widget3);

  function TextInput() {
    _classCallCheck(this, TextInput);

    return _possibleConstructorReturn(this, (TextInput.__proto__ || Object.getPrototypeOf(TextInput)).apply(this, arguments));
  }

  _createClass(TextInput, [{
    key: '_getXMLContent',
    value: function _getXMLContent() {
      var content = _get(TextInput.prototype.__proto__ || Object.getPrototypeOf(TextInput.prototype), '_getXMLContent', this).call(this);
      if (this._shouldPrintTextAsXMLContent()) {
        content = content.concat(this.text.split('\n').map(function (line) {
          return '  ' + line;
        }));
      }
      return content;
    }
  }, {
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      var result = _get(TextInput.prototype.__proto__ || Object.getPrototypeOf(TextInput.prototype), '_getXMLAttributes', this).call(this);
      if (this.type !== 'default') {
        result.push(['type', this.type]);
      }
      if (!this._shouldPrintTextAsXMLContent()) {
        result.push(['text', this.text]);
      }
      if (this.message) {
        result.push(['message', this.message]);
      }
      if (!this.editable) {
        result.push(['editable', 'false']);
      }
      if (this.focused) {
        result.push(['focused', 'true']);
      }
      if (this.keepFocus) {
        result.push(['keepFocus', 'true']);
      }
      return result;
    }
  }, {
    key: '_shouldPrintTextAsXMLContent',
    value: function _shouldPrintTextAsXMLContent() {
      return this.text.length > 25 || this.text.indexOf('\n') !== -1;
    }

    /** @this {import("../JsxProcessor").default} */

  }, {
    key: JSX.jsxFactory,
    value: function (Type, attributes) {
      var children = this.getChildren(attributes);
      var normalAttributes = this.withoutChildren(attributes);
      return _get(TextInput.prototype.__proto__ || Object.getPrototypeOf(TextInput.prototype), JSX.jsxFactory, this).call(this, Type, this.withContentText(normalAttributes, children, 'text'));
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.TextInput';
    }
  }]);

  return TextInput;
}(Widget);

NativeObject.defineProperties(TextInput.prototype, {
  type: {
    type: types.string,
    choice: ['default', 'password', 'search', 'multiline'],
    const: true,
    default: 'default'
  },
  style: {
    type: types.string,
    choice: ['default', 'outline', 'fill', 'underline', 'none'],
    const: true,
    default: 'default'
  },
  text: { type: types.string, nocache: true },
  message: { type: types.string, default: '' },
  floatMessage: { type: types.boolean, default: true },
  editable: { type: types.boolean, default: true },
  maxChars: {
    type: {
      convert: function (value) {
        return value <= 0 ? null : types.natural.convert(value);
      } },
    default: null,
    nullable: true
  },
  keepFocus: { type: types.boolean, default: false },
  alignment: {
    type: types.string,
    choice: ['left', 'centerX', 'right'],
    default: 'left'
  },
  autoCorrect: { type: types.boolean, default: false },
  autoCapitalize: {
    type: { convert: function (v) {
        return v === true ? 'all' : v || 'none';
      } },
    choice: ['none', 'sentence', 'word', 'all'],
    default: false
  },
  keyboard: {
    type: types.string,
    choice: ['ascii', 'decimal', 'email', 'number', 'numbersAndPunctuation', 'phone', 'url', 'default'],
    default: 'default'
  },
  enterKeyType: {
    type: types.string,
    choice: ['default', 'done', 'next', 'send', 'search', 'go'],
    default: 'default'
  },
  messageColor: { type: types.ColorValue, default: 'initial' },
  focused: { type: types.boolean, nocache: true },
  borderColor: { type: types.ColorValue, default: 'initial' },
  textColor: { type: types.ColorValue, default: 'initial' },
  revealPassword: { type: types.boolean, default: false },
  cursorColor: { type: types.ColorValue, default: 'initial' },
  selection: {
    type: {
      convert: function (value, textInput) {
        if (!(value instanceof Array) || value.length !== 2) {
          throw new Error('Selection has to be a two element array with start and end position but is ' + toValueString(value));
        }
        var textLength = textInput.text.length;
        var result = value.map(function (num) {
          return types.number.convert(num);
        });
        if (result[1] > textLength || result[0] > textLength || result[1] < 0 || result[0] < 0) {
          throw new Error('The selection has to be in the range of 0 to text length [0-' + textLength + '] but is ' + value);
        }
        return Object.freeze(result);
      }
    },
    nocache: true
  },
  font: { type: types.FontValue, default: 'initial' },
  keyboardAppearanceMode: {
    type: types.string,
    choice: ['never', 'ontouch', 'onfocus'],
    default: 'onfocus'
  }
});

NativeObject.defineEvents(TextInput.prototype, {
  focus: { native: true, changes: 'focused', changeValue: function () {
      return true;
    } },
  blur: { native: true, changes: 'focused', changeValue: function () {
      return false;
    } },
  accept: { native: true },
  input: { native: true, changes: 'text' },
  select: { native: true, changes: 'selection' }
});

var layoutDataProps$1 = ['left', 'right', 'top', 'bottom', 'width', 'height', 'centerX', 'centerY', 'baseline'];

var Layout = function () {

  // eslint-disable-next-line no-unused-vars
  function Layout() {
    var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var queue = arguments[1];

    _classCallCheck(this, Layout);

    if (this.constructor === Layout) {
      throw new Error('Can not create instance of abstract class "Layout"');
    }
    Object.defineProperty(this, '_layoutQueue', {
      enumerable: false, writable: false, value: queue || LayoutQueue.instance
    });
    if (!(this._layoutQueue instanceof LayoutQueue)) {
      throw new Error('Not a LayoutQueue: ' + this._layoutQueue);
    }
    Object.defineProperties(this, {
      _handleAddChildEvent: {
        enumerable: false,
        writable: false,
        value: this._handleAddChildEvent.bind(this)
      },
      _handleRemoveChildEvent: {
        enumerable: false,
        writable: false,
        value: this._handleRemoveChildEvent.bind(this)
      },
      _handleChildPropertyChangedEvent: {
        enumerable: false,
        writable: false,
        value: this._handleChildPropertyChangedEvent.bind(this)
      },
      _getLayoutData: {
        enumerable: false,
        writable: false,
        value: this._getLayoutData.bind(this)
      },
      _renderLayoutData: {
        enumerable: false,
        writable: false,
        value: this._renderLayoutData.bind(this)
      },
      _addChild: {
        enumerable: false,
        writable: false,
        value: this._addChild.bind(this)
      },
      _removeChild: {
        enumerable: false,
        writable: false,
        value: this._removeChild.bind(this)
      }
    });
  }

  _createClass(Layout, [{
    key: 'add',
    value: function add(composite) {
      if (!composite || composite.layout !== this) {
        throw new Error('Invalid layout target ' + toValueString(composite) + '. Do not call layout.add directly.');
      }
      composite.on({
        addChild: this._handleAddChildEvent,
        removeChild: this._handleRemoveChildEvent
      });
      if (composite.$children) {
        composite.$children.forEach(this._addChild);
      }
      this._layoutQueue.add(composite);
    }
  }, {
    key: 'remove',
    value: function remove(composite) {
      composite.off({
        addChild: this._handleAddChildEvent,
        removeChild: this._handleRemoveChildEvent
      });
      if (composite.$children) {
        composite.$children.forEach(this._removeChild);
      }
    }
  }, {
    key: 'render',
    value: function render(composite) {
      var children = getChildrenInLayout(composite);
      if (!children.length) {
        return;
      }
      var allLayoutData = children.map(this._getLayoutData);
      this._renderLayoutData(children, allLayoutData);
    }
  }, {
    key: '_handleAddChildEvent',
    value: function _handleAddChildEvent(_ref8) {
      var { child: child } = _ref8;

      this._addChild(child);
      this._layoutQueue.add(child._parent);
    }
  }, {
    key: '_handleRemoveChildEvent',
    value: function _handleRemoveChildEvent(_ref9) {
      var { child: child } = _ref9;

      this._removeChild(child);
      this._layoutQueue.add(child._parent);
    }
  }, {
    key: '_addChild',
    value: function _addChild(child) {
      child.on({
        layoutDataChanged: this._handleChildPropertyChangedEvent,
        excludeFromLayoutChanged: this._handleChildPropertyChangedEvent
      });
    }
  }, {
    key: '_removeChild',
    value: function _removeChild(child) {
      child.off({
        layoutDataChanged: this._handleChildPropertyChangedEvent,
        excludeFromLayoutChanged: this._handleChildPropertyChangedEvent
      });
    }
  }, {
    key: '_handleChildPropertyChangedEvent',
    value: function _handleChildPropertyChangedEvent(_ref10) {
      var { target: target } = _ref10;

      this._layoutQueue.add(target._parent);
    }

    /**
     * @param {Array<import('./Widget').default>} children
     * @param {Array<LayoutData>} allLayoutData
     */

  }, {
    key: '_renderLayoutData',
    value: function _renderLayoutData(children, allLayoutData) {
      for (var i = 0; i < children.length; i++) {
        var rawLayoutData = this._resolveAttributes(allLayoutData[i], children[i]);
        children[i]._nativeSet('layoutData', rawLayoutData);
      }
    }

    /**
     * @param {import('./Widget').default} child
     * @param {number} index
     */
    // eslint-disable-next-line no-unused-vars

  }, {
    key: '_getLayoutData',
    value: function _getLayoutData(child, index) {
      var result = child.layoutData;
      if (result.centerX !== 'auto') {
        if (result.left !== 'auto' || result.right !== 'auto') {
          warn('Inconsistent layoutData: centerX overrides left and right.\nTarget: ' + getPath(child));
          result = makeAuto(result, 'left', 'right');
        }
      }
      if (result.baseline !== 'auto') {
        if (result.top !== 'auto' || result.bottom !== 'auto' || result.centerY !== 'auto') {
          warn('Inconsistent layoutData: baseline overrides top, bottom, and centerY.\nTarget: ' + getPath(child));
          result = makeAuto(result, 'top', 'bottom', 'centerY');
        }
      } else if (result.centerY !== 'auto') {
        if (result.top !== 'auto' || result.bottom !== 'auto') {
          warn('Inconsistent layoutData: centerY overrides top and bottom.\nTarget: ' + getPath(child));
          result = makeAuto(result, 'top', 'bottom');
        }
      }
      if (result.left !== 'auto' && result.right !== 'auto' && result.width !== 'auto') {
        warn('Inconsistent layoutData: left and right are set, ignore width.\nTarget: ' + getPath(child));
        result = makeAuto(result, 'width');
      }
      if (result.top !== 'auto' && result.bottom !== 'auto' && result.height !== 'auto') {
        warn('Inconsistent layoutData: top and bottom are set, ignore height.\nTarget: ' + getPath(child));
        result = makeAuto(result, 'height');
      }
      var property = ['left', 'top', 'right', 'bottom'].find(function (prop) {
        return result[prop].offset && result[prop].offset < 0;
      });
      if (property) {
        warn('Negative edge offsets are not supported. Setting ' + property + ' to 0.\nTarget: ' + getPath(child));
        var normalizedPropertyValue = Object.assign({}, result[property], { offset: 0 });
        result = LayoutData.from(Object.assign({}, result, _defineProperty({}, property, normalizedPropertyValue)));
      }
      return result;
    }

    /**
     * @param {LayoutData} layoutData
     * @param {import('./Widget').default} targetWidget
     */

  }, {
    key: '_resolveAttributes',
    value: function _resolveAttributes(layoutData, targetWidget) {
      var result = {};
      for (var i = 0; i < layoutDataProps$1.length; i++) {
        var prop = layoutDataProps$1[i];
        if (prop in layoutData && layoutData[prop] !== 'auto') {
          result[prop] = resolveAttribute(layoutData[prop], targetWidget);
        }
      }
      return result;
    }
  }]);

  return Layout;
}();

var ConstraintLayout = function (_Layout) {
  _inherits(ConstraintLayout, _Layout);

  function ConstraintLayout() {
    _classCallCheck(this, ConstraintLayout);

    return _possibleConstructorReturn(this, (ConstraintLayout.__proto__ || Object.getPrototypeOf(ConstraintLayout)).apply(this, arguments));
  }

  _createClass(ConstraintLayout, null, [{
    key: 'default',
    get: function () {
      if (!this._default) {
        Object.defineProperty(this, '_default', {
          enumerable: false,
          writable: true,
          configurable: true,
          value: new ConstraintLayout()
        });
      }
      return this._default;
    }
  }]);

  return ConstraintLayout;
}(Layout);

var LayoutQueue = function () {
  _createClass(LayoutQueue, null, [{
    key: 'instance',
    get: function () {
      var _this51 = this;

      if (!this._instance) {
        Object.defineProperty(this, '_instance', {
          enumerable: false,
          writable: true,
          configurable: true,
          value: new LayoutQueue()
        });
        tabris.on('layout', function () {
          return _this51._instance.flush();
        });
      }
      return this._instance;
    }
  }]);

  function LayoutQueue() {
    _classCallCheck(this, LayoutQueue);

    Object.defineProperties(this, {
      _map: { enumerable: false, writable: true, value: {} },
      _inFlush: { enumerable: false, writable: true, value: false }
    });
  }

  _createClass(LayoutQueue, [{
    key: 'add',
    value: function add(composite) {
      this._map[composite.cid] = composite;
    }
  }, {
    key: 'flush',
    value: function flush() {
      if (this._inFlush) {
        throw new Error('flush in flush');
      }
      this._inFlush = true;
      for (var cid in this._map) {
        if (!this._map[cid]._isDisposed && this._map[cid].layout) {
          this._map[cid].layout.render(this._map[cid]);
        }
      }
      this._map = {};
      this._inFlush = false;
    }
  }]);

  return LayoutQueue;
}();

function isValidConstraint(constraint) {
  if (constraint === 'auto') {
    return true;
  }
  if (constraint.reference instanceof Percent && constraint.reference.percent === 0) {
    return true;
  }
  return false;
}

function layoutWarn(child, prop, message) {
  warn('Unsupported value for "' + prop + '": ' + message + '\nTarget: ' + getPath(child));
}

function getPath(widget) {
  var path = [widget];
  var parent = widget.parent();
  while (parent) {
    path.unshift(parent);
    parent = parent.parent();
  }
  return path.join(' > ');
}

/**
 * @param {number} value1
 * @param {number} value2
 * @return {number}
 */
function maxPositive(value1, value2) {
  if (value1 < 0 || value2 < 0) {
    return 0;
  }
  return Math.max(0, Math.max(value1, value2));
}

function resolveAttribute(value, widget) {
  if (value instanceof Constraint) {
    return resolveConstraint(value, widget);
  }
  if (isNumber(value)) {
    return value;
  }
  return toCid$1(value, widget);
}

function resolveConstraint(constraint, widget) {
  if (constraint.reference instanceof Percent) {
    if (constraint.reference.percent === 0) {
      return constraint.offset;
    }
    return [constraint.reference.percent, constraint.offset];
  }
  return [toCid$1(constraint.reference, widget), constraint.offset];
}

function toCid$1(ref, widget) {
  if (ref === LayoutData.prev) {
    var children = getChildrenInLayout(getParent(widget));
    var index = children.indexOf(widget);
    if (index > 0) {
      return types.Widget.encode(children[index - 1]) || 0;
    }
    return 0;
  }
  if (ref === LayoutData.next) {
    var _children = getChildrenInLayout(getParent(widget));
    var _index = _children.indexOf(widget);
    if (_index + 1 < _children.length) {
      return types.Widget.encode(_children[_index + 1]) || 0;
    }
    return 0;
  }
  if (typeof ref === 'string') {
    var sibling = widget.siblings(ref)[0];
    return types.Widget.encode(sibling) || 0;
  }
  if (widget.siblings().toArray().includes(ref)) {
    return types.Widget.encode(ref) || 0;
  }
  return 0;
}

function isNumber(value) {
  return typeof value === 'number' && isFinite(value);
}

function getParent(widget) {
  return widget.parent() || emptyParent;
}

function makeAuto(layoutData) {
  var override = {};

  for (var _len14 = arguments.length, props = Array(_len14 > 1 ? _len14 - 1 : 0), _key14 = 1; _key14 < _len14; _key14++) {
    props[_key14 - 1] = arguments[_key14];
  }

  for (var i = 0; i < props.length; i++) {
    override[props[i]] = 'auto';
  }
  return LayoutData.from(Object.assign({}, layoutData, override));
}

function getChildrenInLayout(parent) {
  return parent.$children ? parent.$children.filter(notExcluded$1) : [];
}

function notExcluded$1(widget) {
  return !widget.excludeFromLayout;
}

var emptyParent = {
  children: function () {
    return [];
  }
};

var Composite = function (_Widget4) {
  _inherits(Composite, _Widget4);

  function Composite() {
    _classCallCheck(this, Composite);

    return _possibleConstructorReturn(this, (Composite.__proto__ || Object.getPrototypeOf(Composite)).apply(this, arguments));
  }

  _createClass(Composite, [{
    key: 'append',
    value: function append() {
      var _this53 = this;

      this._checkDisposed();
      var accept = function ( /** @type {Widget} */widget) {
        if (!(widget instanceof NativeObject)) {
          throw new Error('Cannot append non-widget ' + toValueString(widget) + ' to ' + _this53);
        }
        if (widget === _this53) {
          throw new Error('Cannot append widget ' + _this53 + ' to itself');
        }
        widget._setParent(_this53);
      };
      if (arguments[0] instanceof WidgetCollection) {
        arguments[0].toArray().forEach(accept);
      } else if (Array.isArray(arguments[0])) {
        arguments[0].forEach(accept);
      } else {
        Array.prototype.forEach.call(arguments, accept);
      }
      return this;
    }
  }, {
    key: 'find',
    value: function find(selector) {
      return new WidgetCollection(this.children(), { selector: selector, origin: this, deep: true });
    }
  }, {
    key: 'apply',
    value: function apply(sheet) {
      var scope = new WidgetCollection(asArray(this.children()).concat(this), { selector: '*', origin: this, deep: true });
      return this._apply(sheet, scope);
    }
  }, {
    key: 'children',
    value: function children(selector) {
      return this._children(selector);
    }
  }, {
    key: 'set',
    value: function set(props) {
      if ('children' in props && !(props.children instanceof Function)) {
        throw new Error('You may not override children with a non-function');
      }
      return _get(Composite.prototype.__proto__ || Object.getPrototypeOf(Composite.prototype), 'set', this).call(this, props);
    }
  }, {
    key: '_nativeCreate',
    value: function _nativeCreate(properties) {
      _get(Composite.prototype.__proto__ || Object.getPrototypeOf(Composite.prototype), '_nativeCreate', this).call(this, omit(properties || {}, ['layout']));
      this._initLayout(properties);
    }

    /**
     * @param {any} props
     */

  }, {
    key: '_initLayout',
    value: function _initLayout() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!('layout' in props)) {
        Object.defineProperty(this, '_layout', { enumerable: false, writable: false, value: ConstraintLayout.default });
      } else if (props.layout) {
        Object.defineProperty(this, '_layout', { enumerable: false, writable: false, value: props.layout });
      } else {
        Object.defineProperty(this, '_layout', { enumerable: false, writable: false, value: null });
      }
      if (this._layout) {
        this._checkLayout(this._layout);
        this._layout.add(this);
      }
    }
  }, {
    key: '_children',
    value: function _children(selector) {
      return new WidgetCollection(this.$children, { selector: selector, origin: this });
    }
  }, {
    key: '_find',
    value: function _find(selector) {
      return new WidgetCollection(this._children(), { selector: selector, origin: this, deep: true });
    }
  }, {
    key: '_apply',
    value: function _apply(sheet, scope) {
      var _this54 = this;

      if (arguments.length === 1) {
        scope = new WidgetCollection(asArray(this._children()).concat(this), { selector: '*', origin: this, deep: true });
      }
      Object.keys(sheet).map(function (key) {
        return [createSelectorArray(key, _this54), sheet[key]];
      }).sort(function (rule1, rule2) {
        return getSelectorSpecificity(rule1[0]) - getSelectorSpecificity(rule2[0]);
      }).forEach(function (rule) {
        scope.filter(rule[0]).set(rule[1]);
      });
      return this;
    }
  }, {
    key: '_acceptChild',


    // eslint-disable-next-line no-unused-vars
    value: function _acceptChild(child) {
      return true;
    }
  }, {
    key: '_checkLayout',
    value: function _checkLayout(value) {
      if (value && !(value instanceof Layout)) {
        throw new Error(toValueString(value) + ' is not an instance of Layout');
      }
    }
  }, {
    key: '_addChild',
    value: function _addChild(child, index) {
      if (!this._acceptChild(child)) {
        throw new Error(toValueString(child) + ' could not be appended to ' + this);
      }
      if (!this.$children) {
        Object.defineProperties(this, {
          $children: { enumerable: false, writable: true, value: [] }
        });
      }
      if (typeof index === 'number') {
        this.$children.splice(index, 0, child);
      } else {
        index = this.$children.push(child) - 1;
      }
      this._scheduleRenderChildren();
      _get(Composite.prototype.__proto__ || Object.getPrototypeOf(Composite.prototype), '_trigger', this).call(this, 'addChild', { child: child, index: index });
    }
  }, {
    key: '_removeChild',
    value: function _removeChild(child) {
      if (this.$children) {
        var index = this.$children.indexOf(child);
        if (index !== -1) {
          this.$children.splice(index, 1);
          this._scheduleRenderChildren();
          _get(Composite.prototype.__proto__ || Object.getPrototypeOf(Composite.prototype), '_trigger', this).call(this, 'removeChild', { child: child, index: index });
        }
      }
    }
  }, {
    key: '_release',
    value: function _release() {
      if (this.$children) {
        var children = this.$children.concat();
        for (var i = 0; i < children.length; i++) {
          children[i]._dispose(true);
        }
        this.$children = undefined;
      }
      if (this._layout) {
        this._layout.remove(this);
      }
      _get(Composite.prototype.__proto__ || Object.getPrototypeOf(Composite.prototype), '_release', this).call(this);
    }
  }, {
    key: '_getXMLContent',
    value: function _getXMLContent() {
      var content = _get(Composite.prototype.__proto__ || Object.getPrototypeOf(Composite.prototype), '_getXMLContent', this).call(this);
      for (var i = 0; i < (this.$children || []).length; ++i) {
        content.push(this.$children[i][toXML$$1]().split('\n').map(function (line) {
          return '  ' + line;
        }).join('\n'));
      }
      return content;
    }
  }, {
    key: '_scheduleRenderChildren',
    value: function _scheduleRenderChildren() {
      tabris.once('layout', this.$flushChildren, this);
    }
  }, {
    key: '$flushChildren',
    value: function $flushChildren() {
      if (this.$children) {
        this._nativeSet('children', this.$children.filter(notExcluded).map(toCid));
      }
    }

    /** @this {import("../JsxProcessor").default} */

  }, {
    key: JSX.jsxFactory,
    value: function (Type, attributes) {
      var children = this.getChildren(attributes);
      var normalAttributes = this.withoutChildren(attributes);
      var result = _get(Composite.prototype.__proto__ || Object.getPrototypeOf(Composite.prototype), JSX.jsxFactory, this).call(this, Type, normalAttributes);
      if (children && children.length) {
        result.append(children);
      }
      return result;
    }
  }, {
    key: 'layout',
    get: function () {
      return this._layout;
    },
    set: function (value) {
      hint(this, 'Can not set read-only property "layout"');
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Composite';
    }
  }]);

  return Composite;
}(Widget);

function asArray(value) {
  if (!value) {
    return [];
  }
  if (value instanceof WidgetCollection) {
    return value.toArray();
  }
  return value;
}

function toCid(widget) {
  return widget.cid;
}

function notExcluded(widget) {
  return !widget.excludeFromLayout;
}

var ContentView = function (_Composite) {
  _inherits(ContentView, _Composite);

  function ContentView() {
    _classCallCheck(this, ContentView);

    return _possibleConstructorReturn(this, (ContentView.__proto__ || Object.getPrototypeOf(ContentView)).apply(this, arguments));
  }

  _createClass(ContentView, [{
    key: '_nativeCreate',


    /** @override */
    value: function _nativeCreate(properties) {
      if (!properties || properties[creationAllowed] !== true) {
        throw new Error('ContentView can not be created');
      }
      Object.defineProperties(this, {
        _childType: { enumerable: false, writable: false, value: properties.childType },
        _phantom: { enumerable: false, writable: false, value: properties.phantom }
      });
      delete properties[creationAllowed];
      delete properties.childType;
      delete properties.phantom;
      if (this._phantom) {
        this._register();
        this._initLayout(properties);
      } else {
        _get(ContentView.prototype.__proto__ || Object.getPrototypeOf(ContentView.prototype), '_nativeCreate', this).call(this, properties);
      }
    }

    /** @override */

  }, {
    key: '_nativeSet',
    value: function _nativeSet(name, value) {
      if (!this._phantom) {
        _get(ContentView.prototype.__proto__ || Object.getPrototypeOf(ContentView.prototype), '_nativeSet', this).call(this, name, value);
      }
    }

    /** @override */

  }, {
    key: '_nativeGet',
    value: function _nativeGet(name) {
      if (!this._phantom) {
        return _get(ContentView.prototype.__proto__ || Object.getPrototypeOf(ContentView.prototype), '_nativeGet', this).call(this, name);
      }
    }

    /** @override */

  }, {
    key: '_nativeListen',
    value: function _nativeListen(event, state) {
      if (!this._phantom) {
        return _get(ContentView.prototype.__proto__ || Object.getPrototypeOf(ContentView.prototype), '_nativeListen', this).call(this, event, state);
      }
    }

    /** @override */

  }, {
    key: '_nativeCall',
    value: function _nativeCall(method, properties) {
      if (!this._phantom) {
        return _get(ContentView.prototype.__proto__ || Object.getPrototypeOf(ContentView.prototype), '_nativeCall', this).call(this, method, properties);
      }
    }

    /** @override */

  }, {
    key: '_acceptChild',
    value: function _acceptChild(child) {
      if (!this._childType) {
        return true;
      }
      return child instanceof this._childType;
    }
  }, {
    key: '_setParent',
    value: function _setParent(parent, index) {
      if (this._parent) {
        throw new Error('Parent of ContentView can not be changed');
      }
      _get(ContentView.prototype.__proto__ || Object.getPrototypeOf(ContentView.prototype), '_setParent', this).call(this, parent, index);
    }
  }, {
    key: '_dispose',
    value: function _dispose() {
      throw new Error('ContentView can not be disposed');
    }
  }]);

  return ContentView;
}(Composite);

function create$6(properties) {
  return new ContentView(Object.assign(_defineProperty({}, creationAllowed, true), properties));
}

var AlertDialog = function (_Popup2) {
  _inherits(AlertDialog, _Popup2);

  _createClass(AlertDialog, null, [{
    key: 'open',
    value: function open(value) {
      var alertDialog = void 0;
      if (value instanceof AlertDialog) {
        alertDialog = value;
      } else {
        alertDialog = new AlertDialog({ message: value, buttons: { ok: 'OK' } });
      }
      return alertDialog.open();
    }
  }]);

  function AlertDialog(properties) {
    _classCallCheck(this, AlertDialog);

    var _this56 = _possibleConstructorReturn(this, (AlertDialog.__proto__ || Object.getPrototypeOf(AlertDialog)).call(this, properties));

    _this56._nativeListen('close', true);
    _this56._autoDispose = true;
    return _this56;
  }

  _createClass(AlertDialog, [{
    key: 'open',
    value: function open() {
      if (!this.isDisposed() && this._contentView) {
        this._nativeSet('textInputs', this._contentView.children().toArray().map(function (object) {
          return object.cid;
        }));
      }
      return _get(AlertDialog.prototype.__proto__ || Object.getPrototypeOf(AlertDialog.prototype), 'open', this).call(this);
    }
  }, {
    key: '_trigger',
    value: function _trigger(name, event) {
      if (name === 'close') {
        event.button = event.button || null;
        event.texts = [];
        if (this._contentView) {
          event.texts = this._contentView.children().toArray().map(function (textInput) {
            return textInput.text;
          });
        }
        if (event.button) {
          _get(AlertDialog.prototype.__proto__ || Object.getPrototypeOf(AlertDialog.prototype), '_trigger', this).call(this, 'close' + capitalizeFirstChar(event.button), event);
        }
        _get(AlertDialog.prototype.__proto__ || Object.getPrototypeOf(AlertDialog.prototype), '_trigger', this).call(this, 'close', event);
        this.dispose();
      } else {
        return _get(AlertDialog.prototype.__proto__ || Object.getPrototypeOf(AlertDialog.prototype), '_trigger', this).call(this, name, event);
      }
    }
  }, {
    key: '_dispose',
    value: function _dispose() {
      if (!this.isDisposed() && this._contentView) {
        Composite.prototype._dispose.call(this._contentView, true);
      }
      _get(AlertDialog.prototype.__proto__ || Object.getPrototypeOf(AlertDialog.prototype), '_dispose', this).call(this);
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.AlertDialog';
    }
  }, {
    key: 'textInputs',
    get: function () {
      if (!this._contentView) {
        Object.defineProperty(this, '_contentView', {
          enumerable: false,
          writable: false,
          value: create$6({
            layout: null,
            childType: TextInput,
            phantom: true
          })
        });
      }
      return this._contentView;
    },
    set: function (value) {
      hint(this, 'Property "textInputs" can not be set, append to it instead');
    }
  }]);

  return AlertDialog;
}(Popup);

NativeObject.defineProperties(AlertDialog.prototype, {
  title: { type: types.string, default: '' },
  message: { type: types.string, default: '' },
  buttons: {
    type: {
      convert: function (value) {
        allowOnlyKeys(value, ['ok', 'cancel', 'neutral']);
        var result = {};
        if ('ok' in value) {
          result.ok = value.ok + '';
        }
        if ('cancel' in value) {
          result.cancel = value.cancel + '';
        }
        if ('neutral' in value) {
          result.neutral = value.neutral + '';
        }
        return Object.freeze(result);
      }
    },
    default: Object.freeze({})
  }
});

NativeObject.defineEvents(AlertDialog.prototype, {
  close: true,
  closeOk: true,
  closeCancel: true,
  closeNeutral: true
});

AlertDialog.prototype[JSX.jsxFactory] = createElement$2;

/** @this {import("./JsxProcessor").default} */
function createElement$2(Type, attributes) {
  var children = this.getChildren(attributes) || [];
  var normalAttributes = this.withoutChildren(attributes);
  normalAttributes = this.withContentText(normalAttributes, children.filter(function (child) {
    return !(child instanceof Object);
  }), 'message');
  var textInputs = children.filter(function (child) {
    return child instanceof Object;
  });
  var result = Popup.prototype[JSX.jsxFactory].call(this, Type, normalAttributes);
  if (children && children.length) {
    result.textInputs.append(textInputs);
  }
  return result;
}

var Button = function (_Widget5) {
  _inherits(Button, _Widget5);

  /**
   * @param {Partial<Button>=} properties
   */
  function Button(properties) {
    _classCallCheck(this, Button);

    return _possibleConstructorReturn(this, (Button.__proto__ || Object.getPrototypeOf(Button)).call(this, Object.assign({ style: 'default' }, properties)));
  }

  _createClass(Button, [{
    key: '_reorderProperties',


    /**
     * @param {string[]} properties
     */
    value: function _reorderProperties(properties) {
      var styleIndex = properties.indexOf('style');
      if (styleIndex === -1) {
        return _get(Button.prototype.__proto__ || Object.getPrototypeOf(Button.prototype), '_reorderProperties', this).call(this, properties);
      }
      return _get(Button.prototype.__proto__ || Object.getPrototypeOf(Button.prototype), '_reorderProperties', this).call(this, ['style'].concat(properties.slice(0, styleIndex)).concat(properties.slice(styleIndex + 1)));
    }
  }, {
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      return _get(Button.prototype.__proto__ || Object.getPrototypeOf(Button.prototype), '_getXMLAttributes', this).call(this).concat([['text', this.text]]);
    }

    /** @this {import("../JsxProcessor").default} */

  }, {
    key: JSX.jsxFactory,
    value: function (Type, attributes) {
      var children = this.getChildren(attributes);
      var normalAttributes = this.withoutChildren(attributes);
      return _get(Button.prototype.__proto__ || Object.getPrototypeOf(Button.prototype), JSX.jsxFactory, this).call(this, Type, this.withContentText(normalAttributes, children, 'text'));
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Button';
    }
  }]);

  return Button;
}(Widget);

NativeObject.defineProperties(Button.prototype, {
  style: {
    type: types.string,
    choice: ['default', 'elevate', 'flat', 'outline', 'text'],
    default: 'default',
    const: true
  },
  strokeColor: {
    type: {
      convert: function (value, button) {
        if (button.style !== 'outline') {
          throw new Error('The strokeColor can only be set on buttons with style "outline" but it has style ' + button.style + '.');
        }
        return types.ColorValue.convert(value);
      },

      encode: types.ColorValue.encode
    },
    default: 'initial'
  },
  strokeWidth: {
    type: {
      convert: function (value, button) {
        if (button.style !== 'outline') {
          throw new Error('The strokeWidth can only be set on buttons with style "outline" but it has style ' + button.style + '.');
        }
        return types.dimension.convert(value);
      }
    },
    nullable: true,
    default: null
  },
  alignment: {
    type: types.string,
    choice: ['left', 'right', 'centerX'],
    default: 'centerX'
  },
  autoCapitalize: {
    type: types.string,
    choice: ['default', 'none', 'all'],
    default: 'default'
  },
  image: { type: types.ImageValue, default: null },
  imageTintColor: { type: types.ColorValue, default: 'initial' },
  text: { type: types.string, default: '' },
  textColor: { type: types.ColorValue, default: 'initial' },
  font: { type: types.FontValue, default: 'initial' }
});

NativeObject.defineEvents(Button.prototype, {
  select: { native: true }
});

var ImageData = function ImageData() {
  _classCallCheck(this, ImageData);

  if (arguments.length < 2) {
    throw new TypeError('Not enough arguments to ImageData');
  }
  var array = void 0,
      width = void 0,
      height = void 0;
  if (arguments[0] instanceof Uint8ClampedArray) {
    array = checkArray(arguments[0]);
    width = checkSize(arguments[1]);
    height = arguments.length > 2 ? checkSize(arguments[2]) : array.byteLength / 4 / width;
    if (array.byteLength !== width * height * 4) {
      throw new Error('Wrong array size');
    }
  } else {
    width = checkSize(arguments[0]);
    height = checkSize(arguments[1]);
    array = new Uint8ClampedArray(width * height * 4);
  }
  Object.defineProperties(this, {
    data: { value: array },
    width: { value: width },
    height: { value: height }
  });
};

Object.defineProperty(ImageData.prototype, 'data', { value: /** @type {Uint8ClampedArray} */null });
Object.defineProperty(ImageData.prototype, 'width', { value: 0 });
Object.defineProperty(ImageData.prototype, 'height', { value: 0 });

function checkArray(array) {
  if (array.byteLength % 4 !== 0) {
    throw new Error('Illegal array length');
  }
  return array;
}

function checkSize(input) {
  var size = Math.floor(input);
  if (size <= 0 || !isFinite(size)) {
    throw new Error('Illegal size for ImageData');
  }
  return size;
}

var OPCODES = {
  arc: 1,
  arcTo: 2,
  beginPath: 3,
  bezierCurveTo: 4,
  clearRect: 5,
  closePath: 6,
  fill: 7,
  fillRect: 8,
  fillStyle: 9,
  fillText: 10,
  lineCap: 11,
  lineJoin: 12,
  lineTo: 13,
  lineWidth: 14,
  moveTo: 15,
  quadraticCurveTo: 16,
  rect: 17,
  restore: 18,
  rotate: 19,
  save: 20,
  scale: 21,
  setTransform: 22,
  stroke: 23,
  strokeRect: 24,
  strokeStyle: 25,
  strokeText: 26,
  textAlign: 27,
  textBaseline: 28,
  transform: 29,
  translate: 30,
  font: 31,
  drawImage: 32
};

var GC = function (_NativeObject15) {
  _inherits(GC, _NativeObject15);

  function GC(properties) {
    _classCallCheck(this, GC);

    var _this58 = _possibleConstructorReturn(this, (GC.__proto__ || Object.getPrototypeOf(GC)).call(this, properties));

    Object.defineProperties(_this58, {
      _operations: { enumerable: false, writable: true, value: [] },
      _doubles: { enumerable: false, writable: true, value: [] },
      _booleans: { enumerable: false, writable: true, value: [] },
      _strings: { enumerable: false, writable: true, value: [] },
      _ints: { enumerable: false, writable: true, value: [] }
    });
    var listener = function () {
      return _this58.flush();
    };
    tabris.on('flush', listener);
    _this58.on('dispose', function () {
      return tabris.off('flush', listener);
    });
    return _this58;
  }

  _createClass(GC, [{
    key: 'init',
    value: function init(properties) {
      this._nativeCall('init', properties);
    }
  }, {
    key: 'getImageData',
    value: function getImageData(x, y, width, height) {
      var array = this._nativeCall('getImageData', { x: x, y: y, width: width, height: height });
      // TODO: remove when iOS returns a typed array
      return array instanceof Uint8ClampedArray ? array : new Uint8ClampedArray(array);
    }
  }, {
    key: 'putImageData',
    value: function putImageData(imageData, x, y) {
      this._nativeCall('putImageData', {
        data: imageData.data,
        width: imageData.width,
        height: imageData.height,
        x: x,
        y: y
      });
    }
  }, {
    key: 'addOperation',
    value: function addOperation(operation) {
      var opCode = OPCODES[operation];
      if (!opCode) {
        throw new Error('Invalid operation');
      }
      this._operations.push(opCode);
    }
  }, {
    key: 'addBoolean',
    value: function addBoolean() {
      Array.prototype.push.apply(this._booleans, arguments);
    }
  }, {
    key: 'addDouble',
    value: function addDouble() {
      Array.prototype.push.apply(this._doubles, arguments);
    }
  }, {
    key: 'addInt',
    value: function addInt() {
      Array.prototype.push.apply(this._ints, arguments);
    }
  }, {
    key: 'addString',
    value: function addString() {
      Array.prototype.push.apply(this._strings, arguments);
    }
  }, {
    key: 'flush',
    value: function flush() {
      if (this._operations.length > 0) {
        this._nativeCall('draw', { packedOperations: [this._operations, this._doubles, this._booleans, this._strings, this._ints] });
        this._operations = [];
        this._doubles = [];
        this._booleans = [];
        this._strings = [];
        this._ints = [];
      }
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.GC';
    }
  }]);

  return GC;
}(NativeObject);

NativeObject.defineProperties(GC.prototype, { parent: { type: types.Widget, default: null } });

var ImageBitmap = function () {
  _createClass(ImageBitmap, null, [{
    key: 'createImageBitmap',


    /**
     * @param {Blob|ImageData|ImageBitmap|Canvas} imageSource
     */
    value: function createImageBitmap(imageSource) {
      if (arguments.length !== 1) {
        return Promise.reject(new TypeError(arguments.length + ' is not a valid argument count for any overload of createImageBitmap.'));
      }
      if (imageSource instanceof Blob) {
        return load(function (_image) {
          return _image.loadEncodedImage(getBytes(imageSource));
        });
      } else if (imageSource instanceof ImageData) {
        return load(function (_image) {
          return _image.loadImageData(imageSource.data, imageSource.width, imageSource.height);
        });
      } else if (imageSource instanceof ImageBitmap) {
        if (getNativeObject(imageSource).isDisposed()) {
          return Promise.reject(new TypeError('Can not create ImageBitmap from another closed ImageBitmap'));
        }
        return load(function (_image) {
          return _image.loadImageBitmap(getNativeObject(imageSource).cid);
        });
      } else if (imageSource instanceof Canvas) {
        if (imageSource.isDisposed()) {
          return Promise.reject(new TypeError('Can not create ImageBitmap from a disposed Canvas'));
        }
        return load(function (_image) {
          return _image.loadCanvas(imageSource);
        });
      }
      return Promise.reject(new TypeError('Argument 1 of createImageBitmap could not be converted to any of: Blob, ImageData, ImageBitmap, Canvas.'));
    }

    /**
     * @param {_ImageBitmap} nativeObject
     * @param {any} resolution
     */

  }]);

  function ImageBitmap(nativeObject, resolution) {
    _classCallCheck(this, ImageBitmap);

    if (!(nativeObject instanceof _ImageBitmap)) {
      throw new TypeError('Illegal constructor');
    }
    setNativeObject(this, nativeObject);
    Object.defineProperty(this, 'width', { value: resolution.width });
    Object.defineProperty(this, 'height', { value: resolution.height });
  }

  _createClass(ImageBitmap, [{
    key: 'close',
    value: function close() {
      if (!getNativeObject(this).isDisposed()) {
        getNativeObject(this).dispose();
      }
    }
  }]);

  return ImageBitmap;
}();

Object.defineProperty(ImageBitmap.prototype, 'width', { value: 0 });
Object.defineProperty(ImageBitmap.prototype, 'height', { value: 0 });

var _ImageBitmap = function (_NativeObject16) {
  _inherits(_ImageBitmap, _NativeObject16);

  function _ImageBitmap() {
    _classCallCheck(this, _ImageBitmap);

    return _possibleConstructorReturn(this, (_ImageBitmap.__proto__ || Object.getPrototypeOf(_ImageBitmap)).apply(this, arguments));
  }

  _createClass(_ImageBitmap, [{
    key: 'loadEncodedImage',


    /** @param {ArrayBuffer} image */
    value: function loadEncodedImage(image) {
      var _this60 = this;

      return new Promise(function (onSuccess, onError) {
        return _this60._nativeCall('loadEncodedImage', { image: image, onSuccess: onSuccess, onError: onError });
      });
    }

    /**
     *  @param {Uint8ClampedArray} imageData
     *  @param {number} width
     *  @param {number} height
     **/

  }, {
    key: 'loadImageData',
    value: function loadImageData(imageData, width, height) {
      var _this61 = this;

      return new Promise(function (onSuccess, onError) {
        return _this61._nativeCall('loadImageData', { image: imageData, width: width, height: height, onSuccess: onSuccess, onError: onError });
      });
    }

    /** @param {string} imageBitmap */

  }, {
    key: 'loadImageBitmap',
    value: function loadImageBitmap(imageBitmap) {
      var _this62 = this;

      return new Promise(function (onSuccess, onError) {
        return _this62._nativeCall('loadImageBitmap', { image: imageBitmap, onSuccess: onSuccess, onError: onError });
      });
    }

    /** @param {Canvas} canvas */

  }, {
    key: 'loadCanvas',
    value: function loadCanvas(canvas) {
      var _this63 = this;

      return new Promise(function (onSuccess, onError) {
        if (canvas._ctx) {
          canvas._ctx._gc.flush();
        }
        _this63._nativeCall('loadCanvas', { image: canvas.cid, onSuccess: onSuccess, onError: onError });
      });
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.ImageBitmap';
    }
  }]);

  return _ImageBitmap;
}(NativeObject);

Object.defineProperty(_ImageBitmap.prototype, 'wrapper', {
  value: /** @type {ImageBitmap} */null });

/**
 * @param {(nativeObject: _ImageBitmap) => Promise<any>} cb
 * @returns {Promise<ImageBitmap>}
 */
function load(cb) {
  var nativeObject = new _ImageBitmap();
  return cb(nativeObject).then(function (resolution) {
    var wrapper = new ImageBitmap(nativeObject, resolution);
    Object.defineProperty(wrapper, 'wrapper', { value: wrapper });
    return wrapper;
  }).catch(function (message) {
    nativeObject.dispose();
    throw new Error(message);
  });
}

var CanvasContext = function () {
  function CanvasContext(gc) {
    _classCallCheck(this, CanvasContext);

    Object.defineProperties(this, {
      _gc: { enumerable: false, writable: false, value: gc },
      _state: { enumerable: false, writable: true, value: createState() },
      _savedStates: { enumerable: false, writable: false, value: [] }
    });
    this.canvas = {
      width: 0,
      height: 0,
      style: {}
    };
    for (var name in properties) {
      defineProperty(this, name);
    }
  }

  _createClass(CanvasContext, [{
    key: 'measureText',
    value: function measureText(text) {
      // TODO: delegate to native function, once it is implemented (#56)
      return { width: text.length * 5 + 5 };
    }

    // ImageData operations

  }, {
    key: 'getImageData',
    value: function getImageData(x, y, width, height) {
      checkRequiredArgs(arguments, 4, 'CanvasContext.getImageData');
      this._gc.flush();
      // TODO check validity of args
      var array = this._gc.getImageData(x, y, width, height);
      return new ImageData(array, width, height);
    }
  }, {
    key: 'putImageData',
    value: function putImageData(imageData, x, y) {
      checkRequiredArgs(arguments, 3, 'CanvasContext.putImageData');
      this._gc.flush();
      this._gc.putImageData(imageData, x, y);
    }
  }, {
    key: 'createImageData',
    value: function createImageData(width, height) {
      if (arguments[0] instanceof ImageData) {
        var data = arguments[0];
        width = data.width;
        height = data.height;
      } else {
        checkRequiredArgs(arguments, 2, 'CanvasContext.createImageData');
      }
      return new ImageData(width, height);
    }
  }, {
    key: '_init',
    value: function _init(width, height) {
      this.canvas.width = width;
      this.canvas.height = height;
      this._gc.init({ width: width, height: height });
    }
  }]);

  return CanvasContext;
}();

// State operations

defineMethod('save', 0, function () {
  this._savedStates.push(Object.assign({}, this._state));
});

defineMethod('restore', 0, function () {
  this._state = this._savedStates.pop() || this._state;
});

// Path operations

defineMethod('beginPath');

defineMethod('closePath');

defineMethod('lineTo', 2, function (x, y) {
  this._gc.addDouble(x, y);
});

defineMethod('moveTo', 2, function (x, y) {
  this._gc.addDouble(x, y);
});

defineMethod('bezierCurveTo', 6, function (cp1x, cp1y, cp2x, cp2y, x, y) {
  this._gc.addDouble(cp1x, cp1y, cp2x, cp2y, x, y);
});

defineMethod('quadraticCurveTo', 4, function (cpx, cpy, x, y) {
  this._gc.addDouble(cpx, cpy, x, y);
});

defineMethod('rect', 4, function (x, y, width, height) {
  this._gc.addDouble(x, y, width, height);
});

defineMethod('arc', 5, function (x, y, radius, startAngle, endAngle, anticlockwise) {
  this._gc.addDouble(x, y, radius, startAngle, endAngle);
  this._gc.addBoolean(!!anticlockwise);
});

defineMethod('arcTo', 5, function (x1, y1, x2, y2, radius) {
  this._gc.addDouble(x1, y1, x2, y2, radius);
});

// Transformations

defineMethod('scale', 2, function (x, y) {
  this._gc.addDouble(x, y);
});

defineMethod('rotate', 1, function (angle) {
  this._gc.addDouble(angle);
});

defineMethod('translate', 2, function (x, y) {
  this._gc.addDouble(x, y);
});

defineMethod('transform', 6, function (a, b, c, d, e, f) {
  this._gc.addDouble(a, b, c, d, e, f);
});

defineMethod('setTransform', 6, function (a, b, c, d, e, f) {
  this._gc.addDouble(a, b, c, d, e, f);
});

// Drawing operations

defineMethod('clearRect', 4, function (x, y, width, height) {
  this._gc.addDouble(x, y, width, height);
});

defineMethod('fillRect', 4, function (x, y, width, height) {
  this._gc.addDouble(x, y, width, height);
});

defineMethod('strokeRect', 4, function (x, y, width, height) {
  this._gc.addDouble(x, y, width, height);
});

defineMethod('fillText', 3, function (text, x, y /* , maxWidth */) {
  this._gc.addString(text);
  this._gc.addBoolean(false, false, false);
  this._gc.addDouble(x, y);
});

defineMethod('strokeText', 3, function (text, x, y /* , maxWidth */) {
  this._gc.addString(text);
  this._gc.addBoolean(false, false, false);
  this._gc.addDouble(x, y);
});

defineMethod('fill');

defineMethod('stroke');

defineMethod('drawImage', 3, function (image, x1, y1, w1, h1, x2, y2, w2, h2) {
  if (!(image instanceof ImageBitmap)) {
    throw new TypeError('First argument of CanvasContext.drawImage must be of type ImageBitmap');
  }
  this._gc.addString(getNativeObject(image).cid);
  if (arguments.length === 9) {
    this._gc.addDouble(x1, y1, w1, h1, x2, y2, w2, h2);
  } else if (arguments.length === 5) {
    this._gc.addDouble(0, 0, image.width, image.height, x1, y1, w1, h1);
  } else if (arguments.length === 3) {
    this._gc.addDouble(0, 0, image.width, image.height, x1, y1, image.width, image.height);
  } else {
    throw new TypeError(arguments.length + ' is not a valid argument count for any overload of Canvas.drawImage.');
  }
});

CanvasContext.getContext = function (canvas, width, height) {
  if (!canvas._gc) {
    Object.defineProperty(canvas, '_gc', {
      enumerable: false,
      writable: false,
      value: new GC({ parent: canvas })
    });
  }
  if (!canvas._ctx) {
    Object.defineProperty(canvas, '_ctx', {
      enumerable: false,
      writable: false,
      value: new CanvasContext(canvas._gc)
    });
  }
  canvas._ctx._init(width, height);
  return canvas._ctx;
};

var properties = {
  lineWidth: {
    init: 1,
    encode: function (value) {
      if (!isNaN(value) && value > 0) {
        return value;
      }
      throw new Error('Invalid value ' + toValueString(value));
    },

    decode: passThrough,
    addOperations: function (value) {
      this._gc.addDouble(value);
    }
  },
  lineCap: {
    init: 'butt',
    values: toObject(['butt', 'round', 'square']),
    encode: checkValue,
    decode: passThrough,
    addOperations: function (value) {
      this._gc.addString(value);
    }
  },
  lineJoin: {
    init: 'miter',
    values: toObject(['bevel', 'miter', 'round']),
    encode: checkValue,
    decode: passThrough,
    addOperations: function (value) {
      this._gc.addString(value);
    }
  },
  fillStyle: {
    init: [0, 0, 0, 255],
    encode: function (value) {
      return Color.from(value).toArray();
    },
    decode: colorArrayToString,
    addOperations: function (value) {
      this._gc.addInt(value[0], value[1], value[2], value[3]);
    }
  },
  strokeStyle: {
    init: [0, 0, 0, 255],
    encode: function (value) {
      return Color.from(value).toArray();
    },
    decode: colorArrayToString,
    addOperations: function (value) {
      this._gc.addInt(value[0], value[1], value[2], value[3]);
    }
  },
  textAlign: {
    init: 'start',
    values: toObject(['start', 'end', 'left', 'right', 'center']),
    encode: checkValue,
    decode: passThrough,
    addOperations: function (value) {
      this._gc.addString(value);
    }
  },
  textBaseline: {
    init: 'alphabetic',
    values: toObject(['top', 'hanging', 'middle', 'alphabetic', 'ideographic', 'bottom']),
    encode: checkValue,
    decode: passThrough,
    addOperations: function (value) {
      this._gc.addString(value);
    }
  },
  font: {
    init: { family: ['sans-serif'], size: 12, weight: 'normal', style: 'normal' },
    encode: fontStringToObject,
    decode: fontObjectToString,
    addOperations: function (font) {
      this._gc.addString(font.family.join(', '), font.style, font.weight);
      this._gc.addDouble(font.size);
    }
  }
};

function passThrough(value) {
  return value;
}

function checkValue(value) {
  if (value in this.values) {
    return value;
  }
  throw new Error('Invalid value ' + toValueString(value));
}

function toObject(array) {
  var obj = {};
  array.forEach(function (name) {
    obj[name] = true;
  });
  return obj;
}

function createState() {
  var state = {};
  for (var name in properties) {
    state[name] = properties[name].init;
  }
  return state;
}

function defineMethod(name, reqArgCount, fn) {
  CanvasContext.prototype[name] = function () {
    checkRequiredArgs(arguments, reqArgCount, 'CanvasContext.' + name);
    this._gc.addOperation(name);
    if (fn) {
      fn.apply(this, arguments);
    }
  };
}

function defineProperty(context, name) {
  var prop = properties[name];
  Object.defineProperty(context, name, {
    get: function () {
      return prop.decode(context._state[name]);
    },
    set: function (value) {
      try {
        context._state[name] = prop.encode(value);
        context._gc.addOperation(name);
        prop.addOperations.call(context, context._state[name]);
      } catch (error$$1) {
        hint(context, 'Unsupported value for ' + name + ': ' + value);
      }
    }
  });
}

function checkRequiredArgs(args, nr, name) {
  if (args.length < nr) {
    throw new Error('Not enough arguments to ' + name);
  }
}

var MIME_TYPES = Object.freeze({
  'image/png': 'image/png',
  'image/jpeg': 'image/jpeg',
  'image/webp': 'image/webp'
});

var TYPE_QUALITY = Object.freeze({
  'image/png': 1,
  'image/jpeg': 0.92,
  'image/webp': 0.8
});

var Canvas = function (_Composite2) {
  _inherits(Canvas, _Composite2);

  function Canvas() {
    _classCallCheck(this, Canvas);

    return _possibleConstructorReturn(this, (Canvas.__proto__ || Object.getPrototypeOf(Canvas)).apply(this, arguments));
  }

  _createClass(Canvas, [{
    key: 'getContext',


    /**
     * @param {string} type
     * @param {number} width
     * @param {number} height
     * @returns {CanvasContext}
     */
    value: function getContext(type, width, height) {
      if (type === '2d') {
        return CanvasContext.getContext(this, width, height);
      }
      return null;
    }

    /**
     * @param {unknown=} callback
     * @param {unknown=} mimeType
     * @param {unknown=} quality
     */

  }, {
    key: 'toBlob',
    value: function toBlob(callback, mimeType, quality) {
      if (arguments.length === 0) {
        throw new TypeError('Canvas.toBlob requires at least 1 argument, but only 0 were passed');
      }
      if (!(callback instanceof Function)) {
        throw new TypeError('Argument 1 of Canvas.toBlob is not a function');
      }
      if (this._ctx) {
        this._ctx._gc.flush();
      }
      var isValidQuality = typeof quality === 'number' && !isNaN(quality) && quality >= 0 && quality <= 1;
      var validType = MIME_TYPES[typeof mimeType === 'string' ? mimeType : ''] || MIME_TYPES['image/png'];
      this._nativeCall('toBlob', {
        onSuccess: createNativeCallback(function (buffer, resultType) {
          if (!buffer) {
            callback(null);
          } else {
            var blob = new Blob([], { type: resultType });
            setBytes(blob, buffer);
            callback(blob);
          }
        }),
        mimeType: validType,
        quality: isValidQuality ? quality : TYPE_QUALITY[validType]
      });
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Canvas';
    }
  }]);

  return Canvas;
}(Composite);

var CheckBox = function (_Widget6) {
  _inherits(CheckBox, _Widget6);

  function CheckBox() {
    _classCallCheck(this, CheckBox);

    return _possibleConstructorReturn(this, (CheckBox.__proto__ || Object.getPrototypeOf(CheckBox)).apply(this, arguments));
  }

  _createClass(CheckBox, [{
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      return _get(CheckBox.prototype.__proto__ || Object.getPrototypeOf(CheckBox.prototype), '_getXMLAttributes', this).call(this).concat([['text', this.text], ['checked', this.checked]]);
    }

    /** @this {import("../JsxProcessor").default} */

  }, {
    key: JSX.jsxFactory,
    value: function (Type, attributes) {
      var children = this.getChildren(attributes);
      var normalAttributes = this.withoutChildren(attributes);
      return _get(CheckBox.prototype.__proto__ || Object.getPrototypeOf(CheckBox.prototype), JSX.jsxFactory, this).call(this, Type, this.withContentText(normalAttributes, children, 'text'));
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.CheckBox';
    }
  }]);

  return CheckBox;
}(Widget);

NativeObject.defineProperties(CheckBox.prototype, {
  text: { type: 'string', default: '' },
  checked: { type: 'boolean', nocache: true },
  textColor: { type: 'ColorValue', default: 'initial' },
  tintColor: { type: 'ColorValue', default: 'initial' },
  checkedTintColor: { type: 'ColorValue', default: 'initial' },
  font: { type: 'FontValue', default: 'initial' }
});

NativeObject.defineEvents(CheckBox.prototype, {
  select: { native: true, changes: 'checked' }
});

var CollectionView = function (_Composite3) {
  _inherits(CollectionView, _Composite3);

  /**
   * @param {Partial<CollectionView>} properties
   */
  function CollectionView(properties) {
    _classCallCheck(this, CollectionView);

    var _this66 = _possibleConstructorReturn(this, (CollectionView.__proto__ || Object.getPrototypeOf(CollectionView)).call(this));

    Object.defineProperties(_this66, {
      _needsReload: {
        enumerable: false,
        writable: true,
        value: false
      },
      _updateCell: {
        enumerable: false,
        writable: true,
        value: /** @type {(cell: Widget) => void} */function () {}
      },
      _itemCount: {
        enumerable: false,
        writable: true,
        value: /** @type {number} */0
      },
      _createCell: {
        enumerable: false,
        writable: true,
        value: /** @type {(item: any) => Widget} */function () {
          return new Composite();
        }
      },
      _cellHeight: {
        enumerable: false,
        writable: true,
        value: /** @type {number|'auto'|((item: any) => number)} */'auto'
      },
      _cellType: {
        enumerable: false,
        writable: true,
        value: /** @type {string|((item: any) => string)} */null
      },
      _cellMapping: {
        enumerable: false,
        writable: true,
        value: /** @type {Map<Widget, number>} */new Map()
      },
      _itemMapping: {
        enumerable: false,
        writable: true,
        value: /** @type {Map<number, Widget>} */new Map()
      }
    });
    _this66.set(properties || {});
    _this66._nativeListen('requestInfo', true);
    _this66._nativeListen('createCell', true);
    _this66._nativeListen('updateCell', true);
    tabris.on('flush', _this66.$flush, _this66);
    _this66.on('dispose', function () {
      return tabris.off('flush', _this66.$flush, _this66);
    });
    return _this66;
  }

  _createClass(CollectionView, [{
    key: 'load',
    value: function load(itemCount) {
      if (!isNumber$1(itemCount) || itemCount < 0) {
        throw new Error('Invalid itemCount ' + toValueString(itemCount));
      }
      this._itemCount = itemCount;
      this._needsReload = true;
    }
  }, {
    key: 'reveal',
    value: function reveal(index, options) {
      index = this.$checkIndex(index);
      if (index >= 0 && index < this.itemCount) {
        this.$flush();
        this._nativeCall('reveal', {
          index: index,
          animate: options && 'animate' in options ? !!options.animate : true
        });
      }
    }
  }, {
    key: 'refresh',
    value: function refresh(index) {
      if (arguments.length === 0) {
        this.$flush();
        this._nativeCall('refresh', { index: 0, count: this.itemCount });
        return;
      }
      index = this.$checkIndex(index);
      if (index >= 0 && index < this.itemCount) {
        this.$flush();
        this._nativeCall('refresh', { index: index, count: 1 });
      }
    }
  }, {
    key: 'insert',
    value: function insert(index) {
      var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      index = Math.min(Math.max(0, this.$checkIndex(index)), this.itemCount);
      if (!isNumber$1(count) || count <= 0) {
        throw new Error('Invalid insert count ' + toValueString(count));
      }
      this._itemCount = this.itemCount + count;
      this.$flush();
      for (var i = index; i < index + count; i++) {
        this._itemMapping.delete(i);
      }
      for (var cell of this._children()) {
        var oldIndex = this._cellMapping.get(cell);
        if (oldIndex >= index) {
          var newIndex = oldIndex + count;
          this._cellMapping.set(cell, newIndex);
          this._itemMapping.set(newIndex, cell);
        }
      }
      this._nativeCall('insert', { index: index, count: count });
    }
  }, {
    key: 'remove',
    value: function remove(index) {
      var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      index = this.$checkIndex(index);
      if (isNumber$1(count) && count >= 0) {
        count = Math.min(count, this.itemCount - index);
      } else {
        throw new Error('Invalid remove count ' + toValueString(count));
      }
      if (index >= 0 && index < this.itemCount && count > 0) {
        this._itemCount = this.itemCount - count;
        this.$flush();
        for (var i = this._itemCount; i < this.itemCount + count; i++) {
          this._itemMapping.delete(i);
        }
        for (var cell of this._children()) {
          var oldIndex = this._cellMapping.get(cell);
          if (oldIndex >= index) {
            if (oldIndex < index + count) {
              this._cellMapping.delete(cell);
              this._itemMapping.delete(oldIndex);
            } else {
              var newIndex = oldIndex - count;
              this._cellMapping.set(cell, newIndex);
              this._itemMapping.set(newIndex, cell);
            }
          }
        }
        this._nativeCall('remove', { index: index, count: count });
      }
    }

    /**
     * @param {Widget} widget
     * @returns {number}
     */

  }, {
    key: 'itemIndex',
    value: function itemIndex(widget) {
      if (!(widget instanceof Widget)) {
        throw new Error(toValueString(widget) + ' is not a widget');
      }
      var cell = widget;
      while (cell && cell.parent() !== this) {
        cell = cell.parent();
      }
      if (!cell) {
        throw new Error(toValueString(widget) + ' not a cell or child of a cell');
      }
      if (this._cellMapping.has(cell)) {
        return this._cellMapping.get(cell);
      }
      return -1;
    }

    /**
     * @param {number} index
     * @returns {Widget}
     */

  }, {
    key: 'cellByItemIndex',
    value: function cellByItemIndex(index) {
      if (!isNumber$1(index) || index < 0) {
        throw new Error(toValueString(index) + ' is not a valid index');
      }
      if (this._itemMapping.has(index)) {
        return this._itemMapping.get(index);
      }
      return null;
    }
  }, {
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'firstVisibleIndexChanged') {
        this._onoff('scroll', listening, triggerChangeFirstVisibleIndex);
      } else if (name === 'lastVisibleIndexChanged') {
        this._onoff('scroll', listening, triggerChangeLastVisibleIndex);
      } else {
        _get(CollectionView.prototype.__proto__ || Object.getPrototypeOf(CollectionView.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_trigger',
    value: function _trigger(name, event) {
      if (name === 'requestInfo') {
        var _type = resolveProperty(this, 'cellType', event.index);
        var height = resolveProperty(this, 'cellHeight', event.index, _type);
        return {
          type: encodeCellType(this, _type),
          height: encodeCellHeight(this, height)
        };
      } else if (name === 'createCell') {
        var item = this.$createCell(event.type);
        return item.cid;
      } else if (name === 'updateCell') {
        var cell = tabris._nativeObjectRegistry.find(event.widget);
        if (this._cellMapping.has(cell)) {
          this._itemMapping.delete(this._cellMapping.get(cell));
        }
        this._cellMapping.set(cell, event.index);
        this._itemMapping.set(event.index, cell);
        this.updateCell(cell, event.index);
      } else {
        return _get(CollectionView.prototype.__proto__ || Object.getPrototypeOf(CollectionView.prototype), '_trigger', this).call(this, name, event);
      }
    }
  }, {
    key: '_initLayout',
    value: function _initLayout() {}
  }, {
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      return _get(CollectionView.prototype.__proto__ || Object.getPrototypeOf(CollectionView.prototype), '_getXMLAttributes', this).call(this).concat([['itemCount', this.itemCount], ['firstVisibleIndex', this.firstVisibleIndex]]);
    }
  }, {
    key: '$checkIndex',
    value: function $checkIndex(index) {
      if (!isNumber$1(index)) {
        throw new Error(toValueString(index) + ' is not a valid index');
      }
      return index < 0 ? index + this.itemCount : index;
    }
  }, {
    key: '$flush',
    value: function $flush() {
      // Load new items if needed after all properties have been set
      // to avoid intercepting the aggregation of properties in set.
      if (this._needsReload) {
        this._needsReload = false;
        this._nativeCall('load', { itemCount: this.itemCount });
      }
    }
  }, {
    key: '$createCell',
    value: function $createCell(type) {
      var _this67 = this;

      var cell = this.createCell(decodeCellType(this, type));
      if (!(cell instanceof Widget)) {
        throw new Error('Created cell ' + toValueString(cell) + ' is not a widget');
      }
      if (cell._parent) {
        throw new Error('Created cell ' + toValueString(cell) + ' already has a parent');
      }
      cell._parent = this;
      this._addChild(cell);
      cell._setParent = function () {
        return hint(_this67, 'Cannot re-parent collection view cell');
      };
      cell.dispose = function () {
        return hint(_this67, 'Cannot dispose of collection view cell');
      };
      return cell;
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.CollectionView';
    }
  }, {
    key: 'itemCount',
    set: function (value) {
      try {
        var oldValue = this._itemCount;
        this._itemCount = types.natural.convert(value);
        // explicit requirement by tests to do this even if the value is unchanged:
        this._needsReload = true;
        if (oldValue !== this._itemCount) {
          this._triggerChangeEvent('itemCount', this._itemCount);
        }
      } catch (ex) {
        this._printPropertyWarning('itemCount', ex);
      }
    },
    get: function () {
      return this._itemCount;
    }
  }, {
    key: 'cellType',
    set: function (value) {
      if (value === null || typeof value === 'string' || value instanceof Function) {
        if (value !== this._cellType) {
          this._cellType = value;
          this._needsReload = true;
          this._triggerChangeEvent('cellType', this._itemCount);
        }
      } else {
        this._printPropertyWarning('cellType', new Error('Not a string or function'));
      }
    },
    get: function () {
      return this._cellType;
    }
  }, {
    key: 'cellHeight',
    set: function (value) {
      try {
        var oldValue = this._cellHeight;
        if (value === 'auto' || value instanceof Function) {
          this._cellHeight = value;
        } else {
          this._cellHeight = types.dimension.convert(value);
        }
        if (oldValue !== this._cellHeight) {
          this._needsReload = true;
          this._triggerChangeEvent('cellHeight', this._cellHeight);
        }
      } catch (ex) {
        this._printPropertyWarning('cellHeight', ex);
      }
    },
    get: function () {
      return this._cellHeight;
    }

    /** @type {(item: any) => Widget} */

  }, {
    key: 'createCell',
    set: function (value) {
      if (value instanceof Function) {
        if (value !== this._createCell) {
          this._createCell = value;
          this._needsReload = true;
          this._triggerChangeEvent('createCell', this._createCell);
        }
      } else {
        this._printPropertyWarning('createCell', new Error('Not a function'));
      }
    },
    get: function () {
      return this._createCell;
    }

    /** @type {(cell: Widget) => void} */

  }, {
    key: 'updateCell',
    set: function (value) {
      if (value instanceof Function) {
        if (this._updateCell !== value) {
          this._updateCell = value;
          this._needsReload = true;
          this._triggerChangeEvent('updateCell', this._updateCell);
        }
      } else {
        this._printPropertyWarning('updateCell', new Error('Not a function'));
      }
    },
    get: function () {
      return this._updateCell;
    }
  }, {
    key: 'layout',
    set: function (value) {
      if (value) {
        this._printPropertyWarning('layout', new Error('CollectionView does not support layouts'));
      }
    },
    get: function () {
      return null;
    }
  }]);

  return CollectionView;
}(Composite);

NativeObject.defineProperties(CollectionView.prototype, {
  refreshEnabled: {
    type: types.boolean,
    default: false
  },
  refreshIndicator: {
    type: types.boolean,
    nocache: true
  },
  refreshMessage: {
    type: types.string,
    default: ''
  },
  firstVisibleIndex: {
    type: types.number,
    readonly: true,
    nocache: true
  },
  lastVisibleIndex: {
    type: types.number,
    readonly: true,
    nocache: true
  },
  columnCount: {
    type: types.number,
    default: 1
  },
  scrollbarVisible: {
    type: types.boolean,
    default: true
  }
});

NativeObject.defineEvents(CollectionView.prototype, {
  refresh: { native: true },
  scroll: { native: true }
});

NativeObject.defineChangeEvents(CollectionView.prototype, ['createCell', 'cellType', 'cellHeight', 'itemCount', 'updateCell']);

function resolveProperty(ctx, name) {
  var value = ctx[name];
  if (typeof value === 'function') {
    return value.apply(null, Array.prototype.slice.call(arguments, 2));
  }
  return value;
}

function encodeCellType(ctx, type) {
  var cellTypes = ctx._cellTypes || (ctx._cellTypes = []);
  var index = cellTypes.indexOf(type);
  if (index === -1) {
    index += cellTypes.push(type);
  }
  return index;
}

function decodeCellType(ctx, type) {
  var cellTypes = ctx._cellTypes || [];
  return cellTypes[type] || null;
}

function encodeCellHeight(ctx, value) {
  if (value === 'auto') {
    return -1;
  }
  if (isNumber$1(value)) {
    return Math.max(-1, value);
  }
  hint(ctx, 'Invalid cell height: ' + value);
}

var triggerChangeFirstVisibleIndex = createDelegate('firstVisibleIndex');
var triggerChangeLastVisibleIndex = createDelegate('lastVisibleIndex');

function createDelegate(prop) {
  return function () {
    var actual = this[prop];
    if (actual !== this['_prev:' + prop]) {
      this._triggerChangeEvent(prop, actual);
    }
    this['_prev:' + prop] = actual;
  };
}

function isNumber$1(value) {
  return typeof value === 'number' && isFinite(value);
}

var Align = {
  top: 'top',
  centerY: 'centerY',
  baseline: 'baseline',
  bottom: 'bottom',
  stretchY: 'stretchY'
};

var zero$1 = new Percent(0);

var RowLayout = function (_Layout2) {
  _inherits(RowLayout, _Layout2);

  _createClass(RowLayout, null, [{
    key: 'default',
    get: function () {
      if (!this._default) {
        Object.defineProperty(this, '_default', {
          enumerable: false,
          writable: true,
          configurable: true,
          value: new RowLayout()
        });
      }
      return this._default;
    }
  }]);

  function RowLayout() {
    var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var queue = arguments[1];

    _classCallCheck(this, RowLayout);

    var _this68 = _possibleConstructorReturn(this, (RowLayout.__proto__ || Object.getPrototypeOf(RowLayout)).call(this, {}, queue));

    var align = Align[properties.alignment] || Align.top;
    Object.defineProperties(_this68, {
      _spacing: {
        enumerable: false,
        writable: false,
        value: 'spacing' in properties ? types.number.convert(properties.spacing) : 0
      },
      _alignment: {
        enumerable: false,
        writable: false,
        value: align
      },
      _layoutDataVertical: {
        enumerable: false,
        writable: false,
        value: LayoutData.from({
          top: align === Align.top || align === Align.stretchY ? 0 : 'auto',
          bottom: align === Align.bottom || align === Align.stretchY ? 0 : 'auto',
          centerY: align === Align.centerY ? 0 : 'auto',
          baseline: align === Align.baseline ? Constraint.prev : 'auto'
        })
      }
    });
    return _this68;
  }

  _createClass(RowLayout, [{
    key: '_getLayoutData',
    value: function _getLayoutData(child) {
      var result = child.layoutData;
      ['left', 'top', 'right', 'bottom'].filter(function (prop) {
        return !isValidConstraint(result[prop]);
      }).forEach(function (prop) {
        return layoutWarn(child, prop, 'RowLayout only supports "auto" and numeric offset.');
      });
      ['centerX'].filter(function (prop) {
        return result[prop] !== 'auto';
      }).forEach(function (prop) {
        return layoutWarn(child, prop, 'StackLayout only supports "auto".');
      });
      if (result.centerY !== 'auto' && (result.top !== 'auto' || result.bottom !== 'auto' || result.baseline !== 'auto')) {
        warn('Inconsistent layoutData: centerY overrides top, bottom and baseline.\nTarget: ' + getPath(child));
      } else if (result.baseline !== 'auto' && (result.top !== 'auto' || result.bottom !== 'auto')) {
        warn('Inconsistent layoutData: baseline overrides top and bottom.\nTarget: ' + getPath(child));
      }

      if (result.top !== 'auto' && result.bottom !== 'auto' && result.height !== 'auto') {
        warn('Inconsistent layoutData: left and right are set, ignore width.\nTarget: ' + getPath(child));
      }
      return result;
    }

    /**
     * @param {Array<import('./Widget').default>} children
     * @param {Array<LayoutData>} allLayoutData
     */

  }, {
    key: '_renderLayoutData',
    value: function _renderLayoutData(children, allLayoutData) {
      var stretchIndex = this._findStretchIndex(allLayoutData);
      var alignLeft = true;
      for (var i = 0; i < children.length; i++) {
        var targetLayoutData = Object.assign({}, this._layoutDataVertical);
        this._layoutY(targetLayoutData, allLayoutData, i);
        this._applyWidth(allLayoutData[i], targetLayoutData);
        if (alignLeft) {
          this._applyLeft(targetLayoutData, allLayoutData, i);
        }
        if (i === stretchIndex) {
          alignLeft = false;
          targetLayoutData.width = 'auto';
        }
        if (!alignLeft) {
          this._applyRight(targetLayoutData, allLayoutData, i);
        }
        children[i]._nativeSet('layoutData', this._resolveAttributes(targetLayoutData, children[i]));
      }
    }
  }, {
    key: '_layoutY',
    value: function _layoutY(targetLayoutData, allLayoutData, index) {
      var layoutData = allLayoutData[index];
      if (layoutData.top !== 'auto' || layoutData.bottom !== 'auto' || layoutData.centerY !== 'auto' || layoutData.baseline !== 'auto') {
        if (layoutData.centerY !== 'auto') {
          Object.assign(targetLayoutData, { top: 'auto', bottom: 'auto', baseline: 'auto', centerY: layoutData.centerY });
        } else if (layoutData.baseline !== 'auto') {
          Object.assign(targetLayoutData, { top: 'auto', bottom: 'auto', baseline: layoutData.baseline });
        } else {
          Object.assign(targetLayoutData, {
            top: layoutData.top !== 'auto' ? new Constraint(zero$1, layoutData.top.offset) : 'auto',
            bottom: layoutData.bottom !== 'auto' ? new Constraint(zero$1, layoutData.bottom.offset) : 'auto',
            centerY: 'auto',
            baseline: 'auto'
          });
        }
      } else if (index === 0 && targetLayoutData.baseline !== 'auto') {
        targetLayoutData.baseline = 'auto';
        targetLayoutData.top = 0;
      }
      if (layoutData.height !== 'auto' && (layoutData.top === 'auto' || layoutData.bottom === 'auto')) {
        targetLayoutData.height = layoutData.height;
        if (this._alignment === Align.stretchY) {
          targetLayoutData.bottom = 'auto';
        }
      }
    }
  }, {
    key: '_applyLeft',
    value: function _applyLeft(targetLayoutData, allLayoutData, index) {
      var left = allLayoutData[index].left;
      var prevLayoutData = allLayoutData[index - 1];
      var prevRight = prevLayoutData ? prevLayoutData.right : 'auto';
      var ref = prevLayoutData ? LayoutData.prev : zero$1;
      if (left === 'auto' && prevRight === 'auto') {
        targetLayoutData.left = new Constraint(ref, prevLayoutData ? this._spacing : 0);
      } else {
        targetLayoutData.left = new Constraint(ref, maxPositive(left !== 'auto' ? left.offset : 0, prevRight !== 'auto' ? prevRight.offset : 0));
      }
    }
  }, {
    key: '_applyRight',
    value: function _applyRight(targetLayoutData, allLayoutData, index) {
      var right = allLayoutData[index].right;
      var nextLayoutData = allLayoutData[index + 1];
      var nextLeft = nextLayoutData ? nextLayoutData.left : 'auto';
      var ref = nextLayoutData ? LayoutData.next : zero$1;
      if (right === 'auto' && nextLeft === 'auto') {
        targetLayoutData.right = new Constraint(ref, nextLayoutData ? this._spacing : 0);
      } else {
        targetLayoutData.right = new Constraint(ref, maxPositive(right !== 'auto' ? right.offset : 0, nextLeft !== 'auto' ? nextLeft.offset : 0));
      }
    }
  }, {
    key: '_applyWidth',
    value: function _applyWidth(layoutData, targetLayoutData) {
      if (layoutData.width !== 'auto') {
        targetLayoutData.width = layoutData.width;
      }
    }
  }, {
    key: '_findStretchIndex',
    value: function _findStretchIndex(allLayoutData) {
      for (var i = 0; i < allLayoutData.length; i++) {
        var { left: left, width: width, right: right } = allLayoutData[i];
        if (left !== 'auto' && width === 'auto' && right !== 'auto') {
          return i;
        }
      }
      return -1;
    }
  }, {
    key: 'spacing',
    get: function () {
      return this._spacing;
    }
  }, {
    key: 'alignment',
    get: function () {
      return this._alignment;
    }
  }]);

  return RowLayout;
}(Layout);

var Row = function (_Composite4) {
  _inherits(Row, _Composite4);

  function Row(properties) {
    _classCallCheck(this, Row);

    return _possibleConstructorReturn(this, (Row.__proto__ || Object.getPrototypeOf(Row)).call(this, properties));
  }

  _createClass(Row, [{
    key: '_initLayout',
    value: function _initLayout() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var layout = props.layout || RowLayout.default;
      if ('spacing' in props || 'alignment' in props) {
        layout = new RowLayout({
          spacing: 'spacing' in props ? props.spacing : layout.spacing,
          alignment: 'alignment' in props ? props.alignment : layout.alignment
        });
      }
      this._checkLayout(layout);
      Object.defineProperty(this, '_layout', { enumerable: false, writable: false, value: layout });
      this._layout.add(this);
    }
  }, {
    key: '_checkLayout',
    value: function _checkLayout(value) {
      if (!(value instanceof RowLayout)) {
        throw new Error(toValueString(value) + ' is not an instance of RowLayout');
      }
    }
  }, {
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      var result = _get(Row.prototype.__proto__ || Object.getPrototypeOf(Row.prototype), '_getXMLAttributes', this).call(this);
      result.push(['alignment', this.alignment]);
      return result;
    }
  }, {
    key: 'spacing',
    get: function () {
      return this._layout.spacing;
    }

    // prevent error due to _nativeCreate attempting to set
    ,
    set: function (value) {}
  }, {
    key: 'alignment',
    get: function () {
      return this._layout.alignment;
    }

    // prevent error due to _nativeCreate attempting to set
    ,
    set: function (value) {}
  }]);

  return Row;
}(Composite);

var Align$1 = {
  left: 'left',
  centerX: 'centerX',
  right: 'right',
  stretchX: 'stretchX'
};

var zero$2 = new Percent(0);

var StackLayout = function (_Layout3) {
  _inherits(StackLayout, _Layout3);

  _createClass(StackLayout, null, [{
    key: 'default',
    get: function () {
      if (!this._default) {
        Object.defineProperty(this, '_default', {
          enumerable: false,
          writable: true,
          configurable: true,
          value: new StackLayout()
        });
      }
      return this._default;
    }
  }]);

  function StackLayout() {
    var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var queue = arguments[1];

    _classCallCheck(this, StackLayout);

    var _this70 = _possibleConstructorReturn(this, (StackLayout.__proto__ || Object.getPrototypeOf(StackLayout)).call(this, {}, queue));

    var align = Align$1[properties.alignment] || Align$1.left;
    Object.defineProperties(_this70, {
      _spacing: {
        enumerable: false,
        writable: false,
        value: 'spacing' in properties ? types.number.convert(properties.spacing) : 0
      },
      _alignment: {
        enumerable: false,
        writable: false,
        value: align
      },
      _layoutDataHorizontal: {
        enumerable: false,
        writable: false,
        value: LayoutData.from({
          left: align === Align$1.left || align === Align$1.stretchX ? 0 : 'auto',
          right: align === Align$1.right || align === Align$1.stretchX ? 0 : 'auto',
          centerX: align === Align$1.centerX ? 0 : 'auto'
        })
      }
    });
    return _this70;
  }

  _createClass(StackLayout, [{
    key: '_getLayoutData',
    value: function _getLayoutData(child) {
      var result = child.layoutData;
      ['left', 'top', 'right', 'bottom'].filter(function (prop) {
        return !isValidConstraint(result[prop]);
      }).forEach(function (prop) {
        return layoutWarn(child, prop, 'StackLayout only supports "auto" and numeric offset.');
      });
      ['centerY', 'baseline'].filter(function (prop) {
        return result[prop] !== 'auto';
      }).forEach(function (prop) {
        return layoutWarn(child, prop, 'StackLayout only supports "auto".');
      });
      if (result.centerX !== 'auto' && (result.left !== 'auto' || result.right !== 'auto')) {
        warn('Inconsistent layoutData: centerX overrides left and right.\nTarget: ' + getPath(child));
      }
      if (result.left !== 'auto' && result.right !== 'auto' && result.width !== 'auto') {
        warn('Inconsistent layoutData: left and right are set, ignore width.\nTarget: ' + getPath(child));
      }
      return result;
    }

    /**
     * @param {Array<import('./Widget').default>} children
     * @param {Array<LayoutData>} allLayoutData
     */

  }, {
    key: '_renderLayoutData',
    value: function _renderLayoutData(children, allLayoutData) {
      var stretchIndex = this._findStretchIndex(allLayoutData);
      var alignTop = true;
      for (var i = 0; i < children.length; i++) {
        var targetLayoutData = Object.assign({}, this._layoutDataHorizontal);
        this._layoutX(allLayoutData[i], targetLayoutData);
        this._applyHeight(allLayoutData[i], targetLayoutData);
        if (alignTop) {
          this._applyTop(targetLayoutData, allLayoutData, i);
        }
        if (i === stretchIndex) {
          alignTop = false;
          targetLayoutData.height = 'auto';
        }
        if (!alignTop) {
          this._applyBottom(targetLayoutData, allLayoutData, i);
        }
        children[i]._nativeSet('layoutData', this._resolveAttributes(targetLayoutData, children[i]));
      }
    }
  }, {
    key: '_layoutX',
    value: function _layoutX(layoutData, targetLayoutData) {
      if (layoutData.left !== 'auto' || layoutData.right !== 'auto' || layoutData.centerX !== 'auto') {
        if (layoutData.centerX !== 'auto') {
          Object.assign(targetLayoutData, { left: 'auto', right: 'auto', centerX: layoutData.centerX });
        } else {
          Object.assign(targetLayoutData, {
            left: layoutData.left !== 'auto' ? new Constraint(zero$2, layoutData.left.offset) : 'auto',
            right: layoutData.right !== 'auto' ? new Constraint(zero$2, layoutData.right.offset) : 'auto',
            centerX: 'auto'
          });
        }
      }
      if (layoutData.width !== 'auto' && (layoutData.left === 'auto' || layoutData.right === 'auto')) {
        targetLayoutData.width = layoutData.width;
        if (this._alignment === Align$1.stretchX) {
          targetLayoutData.right = 'auto';
        }
      }
    }
  }, {
    key: '_applyTop',
    value: function _applyTop(targetLayoutData, allLayoutData, index) {
      var top = allLayoutData[index].top;
      var prevLayoutData = allLayoutData[index - 1];
      var prevBottom = prevLayoutData ? prevLayoutData.bottom : 'auto';
      var ref = prevLayoutData ? LayoutData.prev : zero$2;
      if (top === 'auto' && prevBottom === 'auto') {
        targetLayoutData.top = new Constraint(ref, prevLayoutData ? this._spacing : 0);
      } else {
        targetLayoutData.top = new Constraint(ref, maxPositive(top !== 'auto' ? top.offset : 0, prevBottom !== 'auto' ? prevBottom.offset : 0));
      }
    }
  }, {
    key: '_applyBottom',
    value: function _applyBottom(targetLayoutData, allLayoutData, index) {
      var bottom = allLayoutData[index].bottom;
      var nextLayoutData = allLayoutData[index + 1];
      var nextTop = nextLayoutData ? nextLayoutData.top : 'auto';
      var ref = nextLayoutData ? LayoutData.next : zero$2;
      if (bottom === 'auto' && nextTop === 'auto') {
        targetLayoutData.bottom = new Constraint(ref, nextLayoutData ? this._spacing : 0);
      } else {
        targetLayoutData.bottom = new Constraint(ref, maxPositive(bottom !== 'auto' ? bottom.offset : 0, nextTop !== 'auto' ? nextTop.offset : 0));
      }
    }
  }, {
    key: '_applyHeight',
    value: function _applyHeight(layoutData, targetLayoutData) {
      if (layoutData.height !== 'auto') {
        targetLayoutData.height = layoutData.height;
      }
    }
  }, {
    key: '_findStretchIndex',
    value: function _findStretchIndex(allLayoutData) {
      for (var i = 0; i < allLayoutData.length; i++) {
        var { top: top, height: height, bottom: bottom } = allLayoutData[i];
        if (top !== 'auto' && height === 'auto' && bottom !== 'auto') {
          return i;
        }
      }
      return -1;
    }
  }, {
    key: 'spacing',
    get: function () {
      return this._spacing;
    }
  }, {
    key: 'alignment',
    get: function () {
      return this._alignment;
    }
  }]);

  return StackLayout;
}(Layout);

var Stack = function (_Composite5) {
  _inherits(Stack, _Composite5);

  function Stack(properties) {
    _classCallCheck(this, Stack);

    return _possibleConstructorReturn(this, (Stack.__proto__ || Object.getPrototypeOf(Stack)).call(this, properties));
  }

  _createClass(Stack, [{
    key: '_initLayout',
    value: function _initLayout() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var layout = props.layout || StackLayout.default;
      if ('spacing' in props || 'alignment' in props) {
        layout = new StackLayout({
          spacing: 'spacing' in props ? props.spacing : layout.spacing,
          alignment: 'alignment' in props ? props.alignment : layout.alignment
        });
      }
      this._checkLayout(layout);
      Object.defineProperty(this, '_layout', { enumerable: false, writable: false, value: layout });
      this._layout.add(this);
    }
  }, {
    key: '_checkLayout',
    value: function _checkLayout(value) {
      if (!(value instanceof StackLayout)) {
        throw new Error(toValueString(value) + ' is not an instance of StackLayout');
      }
    }
  }, {
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      var result = _get(Stack.prototype.__proto__ || Object.getPrototypeOf(Stack.prototype), '_getXMLAttributes', this).call(this);
      result.push(['alignment', this.alignment]);
      return result;
    }
  }, {
    key: 'spacing',
    get: function () {
      return this._layout.spacing;
    }

    // prevent error due to _nativeCreate attempting to set
    ,
    set: function (value) {}
  }, {
    key: 'alignment',
    get: function () {
      return this._layout.alignment;
    }

    // prevent error due to _nativeCreate attempting to set
    ,
    set: function (value) {}
  }]);

  return Stack;
}(Composite);

var CameraView = function (_Widget7) {
  _inherits(CameraView, _Widget7);

  function CameraView() {
    _classCallCheck(this, CameraView);

    return _possibleConstructorReturn(this, (CameraView.__proto__ || Object.getPrototypeOf(CameraView)).apply(this, arguments));
  }

  _createClass(CameraView, [{
    key: '_nativeType',
    get: function () {
      return 'tabris.CameraView';
    }
  }]);

  return CameraView;
}(Widget);

NativeObject.defineProperties(CameraView.prototype, {
  camera: { type: Camera, default: null, nullable: true },
  scaleMode: {
    type: 'string',
    choice: ['fit', 'fill'],
    default: 'fit'
  }
});

var Crypto = function (_NativeObject17) {
  _inherits(Crypto, _NativeObject17);

  function Crypto() {
    _classCallCheck(this, Crypto);

    return _possibleConstructorReturn(this, (Crypto.__proto__ || Object.getPrototypeOf(Crypto)).apply(this, arguments));
  }

  _createClass(Crypto, [{
    key: 'getRandomValues',
    value: function getRandomValues(typedArray) {
      if (arguments.length === 0) {
        throw new Error('Not enough arguments to Crypto.getRandomValues');
      }
      if (!isIntArray(typedArray)) {
        throw new Error('Argument ' + toValueString(typedArray) + ' is not an accepted array type');
      }
      var byteLength = typedArray.byteLength;
      var values = new Uint8Array(this._nativeCall('getRandomValues', { byteLength: byteLength }));
      if (values.byteLength !== byteLength) {
        throw new Error('Not enough random bytes available');
      }
      new Uint8Array(typedArray.buffer).set(values);
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Crypto';
    }
  }]);

  return Crypto;
}(NativeObject);

function isIntArray(value) {
  return value instanceof Int8Array || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int16Array || value instanceof Uint16Array || value instanceof Int32Array || value instanceof Uint32Array;
}

var Drawer = function (_ContentView) {
  _inherits(Drawer, _ContentView);

  function Drawer() {
    _classCallCheck(this, Drawer);

    return _possibleConstructorReturn(this, (Drawer.__proto__ || Object.getPrototypeOf(Drawer)).apply(this, arguments));
  }

  _createClass(Drawer, [{
    key: '_nativeCreate',


    /** @override */
    value: function _nativeCreate(param) {
      if (param !== true) {
        throw new Error('Drawer can not be created');
      }
      _get(Drawer.prototype.__proto__ || Object.getPrototypeOf(Drawer.prototype), '_nativeCreate', this).call(this, _defineProperty({}, creationAllowed, true));
    }
  }, {
    key: '_setParent',
    value: function _setParent() {
      throw new Error('Parent of Drawer can not be changed');
    }
  }, {
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'open' || name === 'close') {
        this._nativeListen(name, listening);
      } else {
        _get(Drawer.prototype.__proto__ || Object.getPrototypeOf(Drawer.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_dispose',
    value: function _dispose() {
      throw new Error('Drawer can not be disposed');
    }
  }, {
    key: 'open',
    value: function open() {
      this._nativeCall('open', {});
      return this;
    }
  }, {
    key: 'close',
    value: function close() {
      this._nativeCall('close', {});
      return this;
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Drawer';
    }
  }]);

  return Drawer;
}(ContentView);

NativeObject.defineProperties(Drawer.prototype, {
  enabled: {
    type: 'boolean',
    default: false
  }
});

NativeObject.defineEvents(Drawer.prototype, {
  open: { native: true },
  close: { native: true }
});

function create$7() {
  return new Drawer(true);
}

var DateDialog = function (_Popup3) {
  _inherits(DateDialog, _Popup3);

  _createClass(DateDialog, null, [{
    key: 'open',
    value: function open(value) {
      var dateDialog = void 0;
      if (value instanceof DateDialog) {
        dateDialog = value;
      } else if (value instanceof Date) {
        dateDialog = new DateDialog({ date: value });
      } else {
        dateDialog = new DateDialog();
      }
      return dateDialog.open();
    }

    /**
     * @param {Partial<DateDialog>=} properties
     */

  }]);

  function DateDialog(properties) {
    _classCallCheck(this, DateDialog);

    var _this75 = _possibleConstructorReturn(this, (DateDialog.__proto__ || Object.getPrototypeOf(DateDialog)).call(this, properties));

    _this75._nativeListen('close', true);
    _this75._nativeListen('select', true);
    _this75._autoDispose = true;
    return _this75;
  }

  _createClass(DateDialog, [{
    key: '_trigger',
    value: function _trigger(name, event) {
      if (name === 'close') {
        this._handleCloseEvent(event);
      } else if (name === 'select') {
        event.date = new Date(event.date);
        _get(DateDialog.prototype.__proto__ || Object.getPrototypeOf(DateDialog.prototype), '_trigger', this).call(this, 'select', event);
        this._handleCloseEvent(event);
      } else {
        return _get(DateDialog.prototype.__proto__ || Object.getPrototypeOf(DateDialog.prototype), '_trigger', this).call(this, name, event);
      }
    }
  }, {
    key: '_handleCloseEvent',
    value: function _handleCloseEvent(event) {
      _get(DateDialog.prototype.__proto__ || Object.getPrototypeOf(DateDialog.prototype), '_trigger', this).call(this, 'close', event);
      this.dispose();
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.DateDialog';
    }
  }]);

  return DateDialog;
}(Popup);

NativeObject.defineProperties(DateDialog.prototype, {
  date: { type: types.Date, default: null },
  maxDate: { type: types.Date, default: null },
  minDate: { type: types.Date, default: null }
});

NativeObject.defineEvents(DateDialog.prototype, {
  select: { native: true },
  close: { native: true }
});

var File = function (_Blob) {
  _inherits(File, _Blob);

  /**
   * @param {Array} chunks
   * @param {string} name
   * @param {Object=} options
   */
  function File(chunks, name) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, File);

    if (arguments.length < 2) {
      throw new TypeError('File requires at least 2 arguments, but only ' + arguments.length + ' were passed.');
    }

    var _this76 = _possibleConstructorReturn(this, (File.__proto__ || Object.getPrototypeOf(File)).call(this, chunks, options));

    Object.defineProperty(_this76, 'name', { value: name + '' });
    var lastModified = 'lastModified' in options ? options.lastModified : Date.now();
    if (isNaN(lastModified) || !isFinite(lastModified)) {
      Object.defineProperty(_this76, 'lastModified', { value: 0 });
    } else {
      Object.defineProperty(_this76, 'lastModified', {
        value: Math.round(typeof lastModified === 'string' ? parseInt(lastModified) : 0 + lastModified)
      });
    }
    return _this76;
  }

  return File;
}(Blob);

File.prototype[Symbol.toStringTag] = 'File';
Object.defineProperty(File.prototype, 'name', { value: '' });
Object.defineProperty(File.prototype, 'lastModified', { value: 0 });

var FormData = function () {
  function FormData() {
    _classCallCheck(this, FormData);
  }

  _createClass(FormData, [{
    key: 'getAll',
    value: function getAll(name) {
      if (arguments.length === 0) {
        throw new TypeError('FormData.getAll requires at least 1 argument, but only 0 were passed');
      }
      var values = data$1(this)[name];
      return values ? values.concat() : [];
    }
  }, {
    key: 'get',
    value: function get(name) {
      if (arguments.length === 0) {
        throw new TypeError('FormData.get requires at least 1 argument, but only 0 were passed');
      }
      var values = data$1(this)[name];
      return values ? values[0] : null;
    }
  }, {
    key: 'has',
    value: function has(name) {
      if (arguments.length === 0) {
        throw new TypeError('FormData.has requires at least 1 argument, but only 0 were passed');
      }
      return !!data$1(this)[name];
    }
  }, {
    key: 'append',
    value: function append(name, value, filename) {
      if (arguments.length < 2) {
        throw new TypeError(arguments.length + ' is not a valid argument count for any overload of FormData.append.');
      }
      if (arguments.length === 3 && !(value instanceof Blob)) {
        throw new TypeError('Argument 2 of FormData.append is not an object.');
      }
      var values = data$1(this)[name] || [];
      values.push(normalize(value, filename));
      data$1(this)[name] = values;
    }
  }, {
    key: 'set',
    value: function set(name, value, filename) {
      if (arguments.length < 2) {
        throw new TypeError(arguments.length + ' is not a valid argument count for any overload of FormData.set.');
      }
      if (arguments.length === 3 && !(value instanceof Blob)) {
        throw new TypeError('Argument 2 of FormData.set is not an object.');
      }
      data$1(this)[name] = [normalize(value, filename)];
    }
  }, {
    key: 'delete',
    value: function _delete(name) {
      if (arguments.length === 0) {
        throw new TypeError('0 is not a valid argument count for any overload of FormData.delete.');
      }
      delete data$1(this)[name];
    }
  }, {
    key: 'keys',
    value: function keys() {
      var entries = this.entries();
      var next = function () {
        var { done: done, value: value } = entries.next();
        return { done: done, value: !done ? value[0] : undefined };
      };
      return _defineProperty({ next: next }, Symbol.iterator, function () {
        return this;
      });
    }
  }, {
    key: 'values',
    value: function values() {
      var entries = this.entries();
      var next = function () {
        var { done: done, value: value } = entries.next();
        return { done: done, value: !done ? value[1] : undefined };
      };
      return _defineProperty({ next: next }, Symbol.iterator, function () {
        return this;
      });
    }
  }, {
    key: Symbol.iterator,
    value: function () {
      return this.entries();
    }
  }, {
    key: 'entries',
    value: function entries() {
      var _this77 = this;

      var keys = Object.keys(data$1(this)).sort();
      var i = 0;
      var j = 0;
      var next = function () {
        if (i < keys.length) {
          var values = data$1(_this77)[keys[i]];
          if (values && j < values.length) {
            return { done: false, value: [keys[i], values[j++]] };
          } else {
            i++;
            j = 0;
            return next();
          }
        }
        return { done: true, value: undefined };
      };
      return _defineProperty({ next: next }, Symbol.iterator, function () {
        return this;
      });
    }
  }]);

  return FormData;
}();

FormData.prototype[Symbol.toStringTag] = 'FormData';

/**
 * @param {FormData} formData
 * @returns {Blob}
 */
function formDataToBlob(formData) {
  var boundary = '----tabrisformdataboundary-' + Math.round(Math.random() * 100000000) + '-yradnuobatadmrofsirbat';
  var parts = [];
  for (var [name, value] of formData) {
    parts.push('--' + boundary + '\r\n');
    if (value instanceof File) {
      parts.push('Content-Disposition: form-data; name="' + name + '"; filename="' + value.name + '"\r\n');
      parts.push('Content-Type: ' + (value.type || 'application/octet-stream') + '\r\n\r\n');
      parts.push(value);
      parts.push('\r\n');
    } else {
      parts.push('Content-Disposition: form-data; name="' + name + '"\r\n\r\n' + value + '\r\n');
    }
  }
  parts.push('--' + boundary + '--');
  return new Blob(parts, { type: 'multipart/form-data; boundary=' + boundary });
}

/**
 * @param {FormData} formData
 * @returns {{[name: string]: Array<string|File>}}
 */
function data$1(formData) {
  if (!formData[data]) {
    formData[data] = {};
  }
  return formData[data];
}

function normalize(value, filename) {
  if (value instanceof File && filename === undefined) {
    return value;
  } else if (value instanceof Blob) {
    return new File([value], filename === undefined ? 'blob' : filename);
  }
  return value + '';
}

var ImageView = function (_Widget8) {
  _inherits(ImageView, _Widget8);

  function ImageView() {
    _classCallCheck(this, ImageView);

    return _possibleConstructorReturn(this, (ImageView.__proto__ || Object.getPrototypeOf(ImageView)).apply(this, arguments));
  }

  _createClass(ImageView, [{
    key: '_beforePropertyChange',
    value: function _beforePropertyChange(name, value) {
      if (name === 'zoomEnabled' && !value) {
        this.minZoomLevel = 1;
        this.maxZoomLevel = 3;
        this.zoomLevel = 1;
      } else if (name === 'minZoomLevel' && value > this.zoomLevel) {
        this.zoomLevel = value;
      } else if (name === 'maxZoomLevel' && value < this.zoomLevel) {
        this.zoomLevel = value;
      }
    }

    /**
     * @param {string[]} properties
     */

  }, {
    key: '_reorderProperties',
    value: function _reorderProperties(properties) {
      if (properties.indexOf('maxZoomLevel') !== -1) {
        properties.unshift(properties.splice(properties.indexOf('maxZoomLevel'), 1)[0]);
      }
      if (properties.indexOf('minZoomLevel') !== -1) {
        properties.unshift(properties.splice(properties.indexOf('minZoomLevel'), 1)[0]);
      }
      if (properties.indexOf('zoomEnabled') !== -1) {
        properties.unshift(properties.splice(properties.indexOf('zoomEnabled'), 1)[0]);
      }
      return _get(ImageView.prototype.__proto__ || Object.getPrototypeOf(ImageView.prototype), '_reorderProperties', this).call(this, properties);
    }
  }, {
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      return _get(ImageView.prototype.__proto__ || Object.getPrototypeOf(ImageView.prototype), '_getXMLAttributes', this).call(this).concat([['image', (this.image || { src: '' }).src]]);
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.ImageView';
    }
  }]);

  return ImageView;
}(Widget);

NativeObject.defineProperties(ImageView.prototype, {
  image: { type: types.ImageValue, default: null },
  scaleMode: {
    type: types.string,
    choice: ['auto', 'fit', 'fill', 'stretch', 'none'],
    default: 'auto'
  },
  tintColor: { type: types.ColorValue, default: 'initial' },
  zoomEnabled: { type: types.boolean, default: false },
  zoomLevel: {
    type: {
      convert: function (value, imageView) {
        if (!imageView.zoomEnabled) {
          throw new Error('zoomLevel can not be set when zoomEnabled is false');
        }
        var num = types.number.convert(value);
        if (num < imageView.minZoomLevel) {
          throw new Error('zoomLevel can not be smaller than minZoomLevel');
        }
        if (num > imageView.maxZoomLevel) {
          throw new Error('zoomLevel can not be larger than maxZoomLevel');
        }
        return num;
      }
    },
    nocache: true
  },
  minZoomLevel: {
    type: {
      convert: function (value, imageView) {
        if (!imageView.zoomEnabled) {
          throw new Error('minZoomLevel can not be set when zoomEnabled is false');
        }
        var num = types.number.convert(value);
        if (num > imageView.maxZoomLevel) {
          throw new Error('minZoomLevel can not be larger than maxZoomLevel');
        }
        return num;
      }
    },
    default: 1.0
  },
  maxZoomLevel: {
    type: {
      convert: function (value, imageView) {
        if (!imageView.zoomEnabled) {
          throw new Error('maxZoomLevel can not be set when zoomEnabled is false');
        }
        var num = types.number.convert(value);
        if (num < imageView.minZoomLevel) {
          throw new Error('maxZoomLevel can not be smaller than minZoomLevel');
        }
        return num;
      }
    },
    default: 3.0
  }
});

NativeObject.defineEvents(ImageView.prototype, {
  load: { native: true },
  zoom: { native: true, changes: 'zoomLevel' }
});

var InactivityTimer = function (_NativeObject18) {
  _inherits(InactivityTimer, _NativeObject18);

  function InactivityTimer(properties) {
    _classCallCheck(this, InactivityTimer);

    var _this79 = _possibleConstructorReturn(this, (InactivityTimer.__proto__ || Object.getPrototypeOf(InactivityTimer)).call(this, properties));

    _this79._nativeListen('timeout', true);
    return _this79;
  }

  _createClass(InactivityTimer, [{
    key: 'start',
    value: function start() {
      this._nativeCall('start');
    }
  }, {
    key: 'cancel',
    value: function cancel() {
      this._nativeCall('cancel');
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.InactivityTimer';
    }
  }]);

  return InactivityTimer;
}(NativeObject);

NativeObject.defineProperties(InactivityTimer.prototype, {
  delay: {
    type: 'natural',
    default: 0
  }
});

NativeObject.defineEvents(InactivityTimer.prototype, {
  timeout: true
});

var SearchAction = function (_Widget9) {
  _inherits(SearchAction, _Widget9);

  function SearchAction() {
    _classCallCheck(this, SearchAction);

    return _possibleConstructorReturn(this, (SearchAction.__proto__ || Object.getPrototypeOf(SearchAction)).apply(this, arguments));
  }

  _createClass(SearchAction, [{
    key: 'open',
    value: function open() {
      this._nativeCall('open', {});
      return this;
    }
  }, {
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      var result = _get(SearchAction.prototype.__proto__ || Object.getPrototypeOf(SearchAction.prototype), '_getXMLAttributes', this).call(this).concat([['title', this.title]]);
      if (this.text) {
        result.push(['text', this.text]);
      }
      if (this.message) {
        result.push(['message', this.message]);
      }
      return result;
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.SearchAction';
    }
  }]);

  return SearchAction;
}(Widget);

NativeObject.defineProperties(SearchAction.prototype, {
  image: { type: types.ImageValue, default: null },
  placementPriority: {
    type: types.string,
    choice: ['low', 'high', 'normal'],
    default: 'normal'
  },
  title: { type: types.string, default: '' },
  proposals: {
    type: {
      convert: function (value) {
        if (!Array.isArray(value)) {
          throw new Error('Not an array');
        }
        return Object.freeze(value.map(types.string.convert));
      }
    },
    default: Object.freeze([])
  },
  text: { type: types.string, nocache: true },
  message: { type: types.string, default: '' }
});

NativeObject.defineEvents(SearchAction.prototype, {
  input: { native: true },
  accept: { native: true },
  select: { native: true }
});

var NavigationView = function (_Composite6) {
  _inherits(NavigationView, _Composite6);

  function NavigationView(properties) {
    _classCallCheck(this, NavigationView);

    var _this81 = _possibleConstructorReturn(this, (NavigationView.__proto__ || Object.getPrototypeOf(NavigationView)).call(this, properties));

    _this81._nativeListen('backNavigation', true);
    return _this81;
  }

  _createClass(NavigationView, [{
    key: '_initLayout',
    value: function _initLayout() {
      Object.defineProperty(this, '_layout', { enumerable: false, writable: false, value: null });
    }
  }, {
    key: '_acceptChild',
    value: function _acceptChild(child) {
      return child instanceof Page || child instanceof Action || child instanceof SearchAction;
    }
  }, {
    key: '_addChild',
    value: function _addChild(child, index) {
      var isTopPage = child instanceof Page && typeof index !== 'number' || index === this.pages().length;
      if (isTopPage) {
        this.$triggerDisappear();
      }
      _get(NavigationView.prototype.__proto__ || Object.getPrototypeOf(NavigationView.prototype), '_addChild', this).call(this, child, index);
      if (isTopPage) {
        this.$triggerAppear();
      }
    }
  }, {
    key: '_removeChild',
    value: function _removeChild(child) {
      var isTopPage = child instanceof Page && child === this.pages().last();
      if (isTopPage) {
        this.$triggerDisappear();
      }
      _get(NavigationView.prototype.__proto__ || Object.getPrototypeOf(NavigationView.prototype), '_removeChild', this).call(this, child);
      if (isTopPage) {
        this.$triggerAppear();
      }
    }
  }, {
    key: '$handleBackNavigation',
    value: function $handleBackNavigation() {
      this.$pop(this.pages().last());
    }
  }, {
    key: '$pop',
    value: function $pop(page) {
      if (page && page.autoDispose) {
        page.dispose();
      } else if (page) {
        page._setParent(null);
      }
    }
  }, {
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'toolbarHeightChanged') {
        this._nativeListen(name, listening);
      } else {
        _get(NavigationView.prototype.__proto__ || Object.getPrototypeOf(NavigationView.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_trigger',
    value: function _trigger(name, event) {
      if (name === 'backNavigation') {
        this.$handleBackNavigation();
      } else if (name === 'toolbarHeightChanged') {
        this._triggerChangeEvent('toolbarHeight', event.toolbarHeight);
      } else {
        return _get(NavigationView.prototype.__proto__ || Object.getPrototypeOf(NavigationView.prototype), '_trigger', this).call(this, name, event);
      }
    }
  }, {
    key: '$triggerAppear',
    value: function $triggerAppear() {
      var topPage = this.pages().last();
      if (topPage) {
        topPage.$trigger('appear');
      }
    }
  }, {
    key: '$triggerDisappear',
    value: function $triggerDisappear() {
      var topPage = this.pages().last();
      if (topPage) {
        topPage.$trigger('disappear');
      }
    }
  }, {
    key: 'pages',
    value: function pages(selector) {
      return this.children(selector).filter(function (child) {
        return child instanceof Page;
      });
    }
  }, {
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      var result = _get(NavigationView.prototype.__proto__ || Object.getPrototypeOf(NavigationView.prototype), '_getXMLAttributes', this).call(this);
      if (!this.drawerActionVisible) {
        result.push(['drawerActionVisible', 'false']);
      }
      if (!this.toolbarVisible) {
        result.push(['toolbarVisible', 'false']);
      }
      return result;
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.NavigationView';
    }
  }]);

  return NavigationView;
}(Composite);

NativeObject.defineProperties(NavigationView.prototype, {
  drawerActionVisible: { type: types.boolean, default: false },
  toolbarVisible: { type: types.boolean, default: true },
  toolbarColor: { type: types.ColorValue, default: null },
  toolbarHeight: { readonly: true },
  titleTextColor: { type: types.ColorValue, default: null },
  actionColor: { type: types.ColorValue, default: null },
  actionTextColor: { type: types.ColorValue, default: null },
  pageAnimation: {
    type: types.string,
    choice: ['default', 'none'],
    default: 'default'
  }
});

NativeObject.defineEvents(NavigationView.prototype, {
  backNavigation: true
});

var Page = function (_Composite7) {
  _inherits(Page, _Composite7);

  function Page() {
    _classCallCheck(this, Page);

    return _possibleConstructorReturn(this, (Page.__proto__ || Object.getPrototypeOf(Page)).apply(this, arguments));
  }

  _createClass(Page, [{
    key: 'insertBefore',


    /** @returns {never} */
    value: function insertBefore() {
      throw new Error('insertBefore not supported on Page');
    }

    /** @returns {never} */

  }, {
    key: 'insertAfter',
    value: function insertAfter() {
      throw new Error('insertAfter not supported on Page');
    }
  }, {
    key: '_setParent',
    value: function _setParent(parent, index) {
      if (parent && !(parent instanceof NavigationView)) {
        throw new Error('Page could not be appended to ' + toValueString(parent));
      }
      _get(Page.prototype.__proto__ || Object.getPrototypeOf(Page.prototype), '_setParent', this).call(this, parent, index);
    }
  }, {
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      return _get(Page.prototype.__proto__ || Object.getPrototypeOf(Page.prototype), '_getXMLAttributes', this).call(this).concat([['title', this.title]]);
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Page';
    }
  }]);

  return Page;
}(Composite);

NativeObject.defineProperties(Page.prototype, {
  image: { type: 'ImageValue', default: null },
  title: { type: 'string', default: '' },
  autoDispose: { type: 'boolean', default: true }
});

NativeObject.defineEvents(Page.prototype, {
  appear: true,
  disappear: true
});

var Picker = function (_Widget10) {
  _inherits(Picker, _Widget10);

  /**
   * @param {Partial<Picker>} properties
   */
  function Picker(properties) {
    _classCallCheck(this, Picker);

    var _this83 = _possibleConstructorReturn(this, (Picker.__proto__ || Object.getPrototypeOf(Picker)).call(this, pick(properties, ['style'])));

    Object.defineProperties(_this83, {
      _itemCount: { enumerable: false, writable: true, value: 0 },
      _itemText: { enumerable: false, writable: true, value: function () {
          return '';
        } }
    });
    _this83.set(omit(properties, ['style']));
    tabris.on('flush', _this83.$flush, _this83);
    _this83.on('dispose', function () {
      return tabris.off('flush', _this83.$flush, _this83);
    });
    return _this83;
  }

  _createClass(Picker, [{
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      return _get(Picker.prototype.__proto__ || Object.getPrototypeOf(Picker.prototype), '_getXMLAttributes', this).call(this).concat([['itemCount', this.itemCount], ['selectionIndex', this.selectionIndex]]);
    }
  }, {
    key: '$flush',
    value: function $flush() {
      if (this.$needsUpdateItems) {
        var items = new Array(this.itemCount);
        for (var index = 0; index < items.length; index++) {
          items[index] = this.itemText(index) + '';
        }
        this._nativeSet('items', items);
        tabris._nativeBridge.flush();
        this.$needsUpdateItems = false;
      }
      if (this.$newSelectionIndex >= -1) {
        this._nativeSet('selectionIndex', this.$newSelectionIndex);
        this._triggerChangeEvent('selectionIndex', this.$newSelectionIndex);
        tabris._nativeBridge.flush();
        this.$newSelectionIndex = undefined;
      }
    }
  }, {
    key: '_trigger',
    value: function _trigger(name, event) {
      if (name === 'select') {
        return _get(Picker.prototype.__proto__ || Object.getPrototypeOf(Picker.prototype), '_trigger', this).call(this, 'select', { index: event.selectionIndex });
      }
      return _get(Picker.prototype.__proto__ || Object.getPrototypeOf(Picker.prototype), '_trigger', this).call(this, name, event);
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Picker';
    }
  }, {
    key: 'itemCount',
    set: function (value) {
      try {
        var oldValue = this._itemCount;
        this._itemCount = types.natural.convert(value);
        if (this._itemCount !== oldValue) {
          Object.defineProperty(this, '$needsUpdateItems', { enumerable: false, writable: true, value: true });
          this._triggerChangeEvent('itemCount');
        }
      } catch (ex) {
        this._printPropertyWarning('itemCount', ex);
      }
    },
    get: function () {
      return this._itemCount;
    }
  }, {
    key: 'itemText',
    set: function (value) {
      try {
        if (!(value instanceof Function)) {
          throw new Error('Not a Function');
        }
        var oldValue = this._itemText;
        this._itemText = value;
        if (this._itemText !== oldValue) {
          Object.defineProperty(this, '$needsUpdateItems', {
            enumerable: false, writable: true, value: true
          });
          this._triggerChangeEvent('itemText');
        }
      } catch (ex) {
        this._printPropertyWarning('itemText', ex);
      }
    },
    get: function () {
      return this._itemText;
    }
  }, {
    key: 'selectionIndex',
    set: function (value) {
      try {
        var oldValue = this.$newSelectionIndex;
        this.$newSelectionIndex = types.integer.convert(value);
        if (this.$newSelectionIndex !== oldValue) {
          this._triggerChangeEvent('selectionIndex');
        }
      } catch (ex) {
        this._printPropertyWarning('selectionIndex', ex);
      }
    },
    get: function () {
      return this.$newSelectionIndex >= -1 ? this.$newSelectionIndex : this._nativeGet('selectionIndex');
    }
  }]);

  return Picker;
}(Widget);

NativeObject.defineProperties(Picker.prototype, {
  style: {
    type: types.string,
    choice: ['default', 'outline', 'fill', 'underline', 'none'],
    const: true,
    default: 'default'
  },
  message: { type: types.string, default: '' },
  floatMessage: { type: types.boolean, default: true },
  borderColor: { type: types.ColorValue, default: null },
  textColor: { type: types.ColorValue, default: null },
  font: { type: types.FontValue, default: null }
});

NativeObject.defineChangeEvents(Picker.prototype, ['selectionIndex', 'itemText', 'itemCount']);

NativeObject.defineEvents(Picker.prototype, {
  select: {
    native: true,
    changes: 'selectionIndex',
    changeValue: function (ev) {
      return 'index' in ev ? ev.index : ev.selectionIndex;
    }
  }
});

var Pbkdf2 = function (_NativeObject19) {
  _inherits(Pbkdf2, _NativeObject19);

  function Pbkdf2(properties) {
    _classCallCheck(this, Pbkdf2);

    var _this84 = _possibleConstructorReturn(this, (Pbkdf2.__proto__ || Object.getPrototypeOf(Pbkdf2)).call(this, properties));

    _this84._nativeListen('done', true);
    return _this84;
  }

  _createClass(Pbkdf2, [{
    key: 'start',
    value: function start(parameters) {
      this._nativeCall('start', parameters);
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.pkcs5.Pbkdf2';
    }
  }]);

  return Pbkdf2;
}(NativeObject);

var Pkcs5 = function () {
  function Pkcs5() {
    _classCallCheck(this, Pkcs5);
  }

  _createClass(Pkcs5, [{
    key: 'pbkdf2',
    value: function pbkdf2(password, salt, iterationCount, keySize) {
      var _arguments7 = arguments;

      return new Promise(function (resolve) {
        if (_arguments7.length < 4) {
          throw new Error('Not enough arguments to pbkdf2');
        }
        if (typeof password !== 'string') {
          throw new Error('Invalid type for password in pbkdf2');
        }
        if (!(salt instanceof Uint8Array)) {
          throw new Error('Invalid type for salt in pbkdf2');
        }
        if (typeof iterationCount !== 'number' || iterationCount <= 0) {
          throw new Error('Invalid number for iterationCount in pbkdf2');
        }
        if (typeof keySize !== 'number' || keySize <= 0) {
          throw new Error('Invalid number for keySize in pbkdf2');
        }
        var pbkdf2 = new Pbkdf2();
        pbkdf2.on('done', function (event) {
          pbkdf2.dispose();
          resolve(event.key);
        });
        // TODO: transfer salt as typed array once iOS 9 support is discontinued
        pbkdf2.start({ password: password, salt: toArray(salt), iterationCount: iterationCount, keySize: keySize });
      });
    }
  }]);

  return Pkcs5;
}();

function toArray(typedArray) {
  var array = new Array(typedArray.length);
  for (var i = 0; i < typedArray.length; i++) {
    array[i] = typedArray[i];
  }
  return array;
}

var ProgressEvent = function (_Event) {
  _inherits(ProgressEvent, _Event);

  function ProgressEvent(type, config) {
    _classCallCheck(this, ProgressEvent);

    if (arguments.length < 1) {
      throw new Error('Not enough arguments to ProgressEvent');
    }

    var _this85 = _possibleConstructorReturn(this, (ProgressEvent.__proto__ || Object.getPrototypeOf(ProgressEvent)).call(this, type, config));

    Object.defineProperties(_this85, {
      $lengthComputable: { enumerable: false, writable: true, value: config && config.lengthComputable || false },
      $loaded: { enumerable: false, writable: true, value: config && config.loaded || 0 },
      $total: { enumerable: false, writable: true, value: config && config.total || 0 }
    });
    return _this85;
  }

  _createClass(ProgressEvent, [{
    key: 'lengthComputable',
    get: function () {
      return this.$lengthComputable;
    }
  }, {
    key: 'loaded',
    get: function () {
      return this.$loaded;
    }
  }, {
    key: 'total',
    get: function () {
      return this.$total;
    }
  }]);

  return ProgressEvent;
}(Event);

var ProgressBar = function (_Widget11) {
  _inherits(ProgressBar, _Widget11);

  function ProgressBar() {
    _classCallCheck(this, ProgressBar);

    return _possibleConstructorReturn(this, (ProgressBar.__proto__ || Object.getPrototypeOf(ProgressBar)).apply(this, arguments));
  }

  _createClass(ProgressBar, [{
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      return _get(ProgressBar.prototype.__proto__ || Object.getPrototypeOf(ProgressBar.prototype), '_getXMLAttributes', this).call(this).concat([['selection', this.selection], ['minimum', this.minimum], ['maximum', this.maximum]]);
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.ProgressBar';
    }
  }]);

  return ProgressBar;
}(Widget);

NativeObject.defineProperties(ProgressBar.prototype, {
  minimum: { type: types.integer, default: 0 },
  maximum: { type: types.integer, default: 100 },
  tintColor: { type: types.ColorValue, default: null },
  selection: { type: types.integer, default: 0 },
  state: {
    type: types.string,
    choice: ['normal', 'paused', 'error'],
    default: 'normal'
  }
});

var Popover = function (_Popup4) {
  _inherits(Popover, _Popup4);

  _createClass(Popover, null, [{
    key: 'open',
    value: function open(value) {
      var popover = void 0;
      if (value instanceof Popover) {
        popover = value;
      } else {
        throw new Error('Not a Popover: ' + typeof value);
      }
      return popover.open();
    }

    /**
     * @param {Partial<Popover>=} properties
     */

  }]);

  function Popover(properties) {
    _classCallCheck(this, Popover);

    var _this87 = _possibleConstructorReturn(this, (Popover.__proto__ || Object.getPrototypeOf(Popover)).call(this, properties));

    Object.defineProperty(_this87, 'contentView', { value: create$6() });
    _this87._nativeListen('close', true);
    _this87._autoDispose = true;
    _this87._nativeSet('contentView', _this87.contentView.cid);
    return _this87;
  }

  _createClass(Popover, [{
    key: '_trigger',
    value: function _trigger(name, event) {
      if (name === 'close') {
        _get(Popover.prototype.__proto__ || Object.getPrototypeOf(Popover.prototype), '_trigger', this).call(this, 'close', event);
        this.dispose();
      } else {
        return _get(Popover.prototype.__proto__ || Object.getPrototypeOf(Popover.prototype), '_trigger', this).call(this, name, event);
      }
    }
  }, {
    key: '_dispose',
    value: function _dispose() {
      if (!this.isDisposed()) {
        Composite.prototype._dispose.call(this.contentView);
      }
      _get(Popover.prototype.__proto__ || Object.getPrototypeOf(Popover.prototype), '_dispose', this).call(this);
    }

    /** @this {import("../JsxProcessor").default} */

  }, {
    key: JSX.jsxFactory,
    value: function (Type, attributes) {
      var children = this.getChildren(attributes);
      var normalAttributes = this.withoutChildren(attributes);
      var result = _get(Popover.prototype.__proto__ || Object.getPrototypeOf(Popover.prototype), JSX.jsxFactory, this).call(this, Type, normalAttributes);
      if (children && children.length) {
        result.contentView.append(children);
      }
      return result;
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Popover';
    }
  }]);

  return Popover;
}(Popup);

NativeObject.defineProperties(Popover.prototype, {
  anchor: { type: 'Widget', default: null },
  width: { type: 'dimension', nocache: true, nullable: true },
  height: { type: 'dimension', nocache: true, nullable: true }
});

NativeObject.defineEvents(Popover.prototype, {
  close: {}
});

var NavigationBar = function (_NativeObject20) {
  _inherits(NavigationBar, _NativeObject20);

  function NavigationBar() {
    _classCallCheck(this, NavigationBar);

    return _possibleConstructorReturn(this, (NavigationBar.__proto__ || Object.getPrototypeOf(NavigationBar)).apply(this, arguments));
  }

  _createClass(NavigationBar, [{
    key: '_nativeCreate',


    /** @override */
    value: function _nativeCreate(param) {
      if (param !== true) {
        throw new Error('NavigationBar can not be created');
      }
      _get(NavigationBar.prototype.__proto__ || Object.getPrototypeOf(NavigationBar.prototype), '_nativeCreate', this).call(this);
    }
  }, {
    key: '_setParent',
    value: function _setParent() {
      throw new Error('Parent of NavigationBar can not be changed');
    }
  }, {
    key: '_dispose',
    value: function _dispose() {
      throw new Error('NavigationBar can not be disposed');
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.NavigationBar';
    }
  }]);

  return NavigationBar;
}(NativeObject);

NativeObject.defineProperties(NavigationBar.prototype, {
  theme: {
    type: types.string,
    choice: ['default', 'light', 'dark'],
    default: 'default'
  },
  displayMode: {
    type: types.string,
    choice: ['default', 'float', 'hide'],
    default: 'default'
  },
  height: {
    type: types.number,
    readonly: true,
    nocache: true
  },
  background: {
    type: types.ColorValue,
    nocache: true
  }
});

function create$8() {
  return new NavigationBar(true);
}

var RadioButton = function (_Widget12) {
  _inherits(RadioButton, _Widget12);

  function RadioButton() {
    _classCallCheck(this, RadioButton);

    return _possibleConstructorReturn(this, (RadioButton.__proto__ || Object.getPrototypeOf(RadioButton)).apply(this, arguments));
  }

  _createClass(RadioButton, [{
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      return _get(RadioButton.prototype.__proto__ || Object.getPrototypeOf(RadioButton.prototype), '_getXMLAttributes', this).call(this).concat([['text', this.text], ['checked', this.checked]]);
    }

    /** @this {import("../JsxProcessor").default} */

  }, {
    key: JSX.jsxFactory,
    value: function (Type, attributes) {
      var children = this.getChildren(attributes);
      var normalAttributes = this.withoutChildren(attributes);
      return _get(RadioButton.prototype.__proto__ || Object.getPrototypeOf(RadioButton.prototype), JSX.jsxFactory, this).call(this, Type, this.withContentText(normalAttributes, children, 'text'));
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.RadioButton';
    }
  }]);

  return RadioButton;
}(Widget);

NativeObject.defineProperties(RadioButton.prototype, {
  text: { type: 'string', default: '' },
  checked: { type: 'boolean', nocache: true },
  textColor: { type: 'ColorValue', default: 'initial' },
  tintColor: { type: 'ColorValue', default: 'initial' },
  checkedTintColor: { type: 'ColorValue', default: 'initial' },
  font: { type: 'FontValue', default: 'initial' }
});

NativeObject.defineEvents(RadioButton.prototype, {
  select: { native: true, changes: 'checked' }
});

var RefreshComposite = function (_Composite8) {
  _inherits(RefreshComposite, _Composite8);

  function RefreshComposite() {
    _classCallCheck(this, RefreshComposite);

    return _possibleConstructorReturn(this, (RefreshComposite.__proto__ || Object.getPrototypeOf(RefreshComposite)).apply(this, arguments));
  }

  _createClass(RefreshComposite, [{
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'refresh') {
        this._nativeListen(name, listening);
      } else {
        _get(RefreshComposite.prototype.__proto__ || Object.getPrototypeOf(RefreshComposite.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.RefreshComposite';
    }
  }]);

  return RefreshComposite;
}(Composite);

NativeObject.defineProperties(RefreshComposite.prototype, {

  refreshEnabled: {
    type: 'boolean',
    default: true
  },
  refreshIndicator: {
    type: 'boolean',
    nocache: true
  },
  refreshMessage: {
    type: 'string',
    default: ''
  }

});

NativeObject.defineEvents(RefreshComposite.prototype, {
  refresh: { native: true }
});

var ScrollView = function (_Composite9) {
  _inherits(ScrollView, _Composite9);

  function ScrollView() {
    _classCallCheck(this, ScrollView);

    return _possibleConstructorReturn(this, (ScrollView.__proto__ || Object.getPrototypeOf(ScrollView)).apply(this, arguments));
  }

  _createClass(ScrollView, [{
    key: 'scrollToY',
    value: function scrollToY(offset, options) {
      this._nativeCall('scrollToY', {
        offset: offset,
        animate: options && 'animate' in options ? !!options.animate : true
      });
      return this;
    }
  }, {
    key: 'scrollToX',
    value: function scrollToX(offset, options) {
      this._nativeCall('scrollToX', {
        offset: offset,
        animate: options && 'animate' in options ? !!options.animate : true
      });
      return this;
    }
  }, {
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'scrollXStateChanged') {
        this._nativeListen('scrollXStateChanged', listening);
      } else if (name === 'scrollYStateChanged') {
        this._nativeListen('scrollYStateChanged', listening);
      } else {
        _get(ScrollView.prototype.__proto__ || Object.getPrototypeOf(ScrollView.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      var offset = this.direction === 'vertical' ? 'offsetY' : 'offsetX';
      return _get(ScrollView.prototype.__proto__ || Object.getPrototypeOf(ScrollView.prototype), '_getXMLAttributes', this).call(this).concat([['direction', this.direction], [offset, this[offset]]]);
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.ScrollView';
    }
  }]);

  return ScrollView;
}(Composite);

NativeObject.defineProperties(ScrollView.prototype, {
  direction: {
    type: types.string,
    choice: ['horizontal', 'vertical'],
    default: 'vertical',
    const: true
  },
  offsetX: { type: types.number, nocache: true, readonly: true },
  offsetY: { type: types.number, nocache: true, readonly: true },
  scrollbarVisible: { type: types.boolean, default: true },
  scrollXState: { type: types.string, nocache: true, readonly: true },
  scrollYState: { type: types.string, nocache: true, readonly: true }
});

NativeObject.defineEvents(ScrollView.prototype, {
  scrollX: { native: true, changes: 'offsetX', changeValue: 'offset' },
  scrollY: { native: true, changes: 'offsetY', changeValue: 'offset' }
});

var SizeMeasurement = function (_NativeObject21) {
  _inherits(SizeMeasurement, _NativeObject21);

  function SizeMeasurement() {
    _classCallCheck(this, SizeMeasurement);

    return _possibleConstructorReturn(this, (SizeMeasurement.__proto__ || Object.getPrototypeOf(SizeMeasurement)).apply(this, arguments));
  }

  _createClass(SizeMeasurement, [{
    key: '_nativeCreate',


    /** @override */
    value: function _nativeCreate(param) {
      if (param !== true) {
        throw new Error('SizeMeasurement can not be created');
      }
      _get(SizeMeasurement.prototype.__proto__ || Object.getPrototypeOf(SizeMeasurement.prototype), '_nativeCreate', this).call(this);
    }
  }, {
    key: 'measureTexts',
    value: function measureTexts(configs) {
      var _arguments8 = arguments,
          _this93 = this;

      return new Promise(function (resolve, reject) {
        if (_arguments8.length < 1) {
          throw new Error('Not enough arguments to measure texts');
        }
        if (!Array.isArray(configs)) {
          throw new Error('The text measurement configs have to be an array');
        }
        _this93._nativeCall('measureTexts', {
          configs: _this93._createTextMeasureConfigs(configs),
          onResult: function (result) {
            return resolve(result);
          },
          onError: function (error) {
            return reject(new Error(error));
          }
        });
      });
    }
  }, {
    key: 'measureTextsSync',
    value: function measureTextsSync(configs) {
      if (arguments.length < 1) {
        throw new Error('Not enough arguments to measure texts');
      }
      if (!Array.isArray(configs)) {
        throw new Error('The text measurement configs have to be an array');
      }
      return this._nativeCall('measureTextsSync', {
        configs: this._createTextMeasureConfigs(configs)
      });
    }
  }, {
    key: '_createTextMeasureConfigs',
    value: function _createTextMeasureConfigs(configs) {
      return configs.map(function (config) {
        return {
          text: checkText(config.text),
          font: checkFont(config.font),
          markupEnabled: !!config.markupEnabled,
          maxWidth: 'maxWidth' in config ? types.dimension.convert(config.maxWidth) : undefined
        };
      });
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      throw new Error('Cannot dispose sizeMeasurement object');
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.SizeMeasurement';
    }
  }]);

  return SizeMeasurement;
}(NativeObject);

function checkText(text) {
  if (!text) {
    throw new Error('A text measurement configuration has to provide a "text" value');
  }
  return text;
}

function checkFont(fontValue) {
  var font = Font.from(fontValue);
  if (!font.size) {
    throw new Error('A text measurement configuration has to provide a font size via the "font" property');
  }
  return font;
}

function create$9() {
  return new SizeMeasurement(true);
}

var Slider = function (_Widget13) {
  _inherits(Slider, _Widget13);

  function Slider() {
    _classCallCheck(this, Slider);

    return _possibleConstructorReturn(this, (Slider.__proto__ || Object.getPrototypeOf(Slider)).apply(this, arguments));
  }

  _createClass(Slider, [{
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      return _get(Slider.prototype.__proto__ || Object.getPrototypeOf(Slider.prototype), '_getXMLAttributes', this).call(this).concat([['selection', this.selection], ['minimum', this.minimum], ['maximum', this.maximum]]);
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Slider';
    }
  }]);

  return Slider;
}(Widget);

NativeObject.defineProperties(Slider.prototype, {
  minimum: { type: 'integer', default: 0 },
  maximum: { type: 'integer', default: 100 },
  selection: { type: 'integer', nocache: true },
  tintColor: { type: 'ColorValue', default: 'initial' }
});

NativeObject.defineEvents(Slider.prototype, {
  select: { native: true, changes: 'selection' }
});

var StatusBar = function (_NativeObject22) {
  _inherits(StatusBar, _NativeObject22);

  function StatusBar() {
    _classCallCheck(this, StatusBar);

    return _possibleConstructorReturn(this, (StatusBar.__proto__ || Object.getPrototypeOf(StatusBar)).apply(this, arguments));
  }

  _createClass(StatusBar, [{
    key: '_nativeCreate',


    /** @override */
    value: function _nativeCreate(param) {
      if (param !== true) {
        throw new Error('StatusBar can not be created');
      }
      _get(StatusBar.prototype.__proto__ || Object.getPrototypeOf(StatusBar.prototype), '_nativeCreate', this).call(this);
    }
  }, {
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'tap') {
        this._nativeListen(name, listening);
      } else {
        _get(StatusBar.prototype.__proto__ || Object.getPrototypeOf(StatusBar.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_setParent',
    value: function _setParent() {
      throw new Error('Parent of StatusBar can not be changed');
    }
  }, {
    key: '_dispose',
    value: function _dispose() {
      throw new Error('StatusBar can not be disposed');
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.StatusBar';
    }
  }]);

  return StatusBar;
}(NativeObject);

NativeObject.defineProperties(StatusBar.prototype, {
  theme: {
    type: types.string,
    choice: ['default', 'light', 'dark'],
    default: 'default'
  },
  displayMode: {
    type: types.string,
    choice: ['default', 'float', 'hide'],
    default: 'default'
  },
  height: {
    type: types.number,
    readonly: true,
    nocache: true
  },
  background: { type: types.ColorValue, nocache: true }
});

NativeObject.defineEvents(StatusBar.prototype, {
  tap: true
});

function create$10() {
  return new StatusBar(true);
}

var Switch = function (_Widget14) {
  _inherits(Switch, _Widget14);

  function Switch() {
    _classCallCheck(this, Switch);

    return _possibleConstructorReturn(this, (Switch.__proto__ || Object.getPrototypeOf(Switch)).apply(this, arguments));
  }

  _createClass(Switch, [{
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      return _get(Switch.prototype.__proto__ || Object.getPrototypeOf(Switch.prototype), '_getXMLAttributes', this).call(this).concat([['text', this.text], ['checked', this.checked]]);
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Switch';
    }
  }]);

  return Switch;
}(Widget);

NativeObject.defineProperties(Switch.prototype, {
  checked: { type: 'boolean', nocache: true },
  thumbOnColor: { type: 'ColorValue', default: 'initial' },
  thumbOffColor: { type: 'ColorValue', default: 'initial' },
  trackOnColor: { type: 'ColorValue', default: 'initial' },
  trackOffColor: { type: 'ColorValue', default: 'initial' }
});

NativeObject.defineEvents(Switch.prototype, {
  select: { native: true, changes: 'checked' }
});

var TabFolder = function (_Composite10) {
  _inherits(TabFolder, _Composite10);

  /**
   * @param {Partial<TabFolder>=} properties
   */
  function TabFolder(properties) {
    _classCallCheck(this, TabFolder);

    var _this97 = _possibleConstructorReturn(this, (TabFolder.__proto__ || Object.getPrototypeOf(TabFolder)).call(this, properties));

    Object.defineProperty(_this97, '$previousSelection', {
      enumerable: false, writable: true, value: undefined
    });
    _this97._nativeListen('select', true);
    return _this97;
  }

  _createClass(TabFolder, [{
    key: '_scheduleRenderChildren',
    value: function _scheduleRenderChildren() {
      // Skip the queue mechanism to avoid tab selection-before-appended issue
      this.$flushChildren();
    }
  }, {
    key: '_nativeListen',
    value: function _nativeListen(event, state) {
      if (event === 'select' && !state) {
        return;
      }
      _get(TabFolder.prototype.__proto__ || Object.getPrototypeOf(TabFolder.prototype), '_nativeListen', this).call(this, event, state);
    }
  }, {
    key: '_initLayout',
    value: function _initLayout() {
      Object.defineProperty(this, '_layout', { enumerable: false, writable: false, value: null });
    }
  }, {
    key: '_acceptChild',
    value: function _acceptChild(child) {
      return child instanceof Tab;
    }
  }, {
    key: '_addChild',
    value: function _addChild(child, index) {
      _get(TabFolder.prototype.__proto__ || Object.getPrototypeOf(TabFolder.prototype), '_addChild', this).call(this, child, index);
      if (this.$children.indexOf(child) === 0) {
        child.$trigger('appear');
        this.$previousSelection = child;
      }
    }
  }, {
    key: '_removeChild',
    value: function _removeChild(child) {
      if (!this._inDispose) {
        var childIndex = this.$children.indexOf(child);
        var rightNeighbor = this.$children[childIndex + 1];
        var leftNeighbor = this.$children[childIndex - 1];
        var newSelection = rightNeighbor || leftNeighbor;
        if (newSelection) {
          this.selection = newSelection;
        } else {
          this._triggerChangeEvent('selection', null);
        }
      }
      _get(TabFolder.prototype.__proto__ || Object.getPrototypeOf(TabFolder.prototype), '_removeChild', this).call(this, child);
    }
  }, {
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'selectionIndexChanged') {
        this._onoff('selectionChanged', listening, this.$triggerSelectionIndexChanged);
      } else {
        _get(TabFolder.prototype.__proto__ || Object.getPrototypeOf(TabFolder.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_trigger',
    value: function _trigger(name, event) {
      if (name === 'select') {
        var selection = tabris._nativeObjectRegistry.find(event.selection);
        var result = _get(TabFolder.prototype.__proto__ || Object.getPrototypeOf(TabFolder.prototype), '_trigger', this).call(this, 'select', { selection: selection });
        selection._trigger('select');
        if (this.$previousSelection === selection) {
          selection._trigger('reselect');
        }
        this._triggerChangeEvent('selection', selection);
        return result;
      }
      if (name === 'scroll') {
        var _selection = event.selection ? tabris._nativeObjectRegistry.find(event.selection) : null;
        return _get(TabFolder.prototype.__proto__ || Object.getPrototypeOf(TabFolder.prototype), '_trigger', this).call(this, 'scroll', { selection: _selection, offset: event.offset });
      }
      return _get(TabFolder.prototype.__proto__ || Object.getPrototypeOf(TabFolder.prototype), '_trigger', this).call(this, name, event);
    }
  }, {
    key: '_triggerChangeEvent',
    value: function _triggerChangeEvent(name, value) {
      if (name === 'selection') {
        if (this.$previousSelection !== value) {
          _get(TabFolder.prototype.__proto__ || Object.getPrototypeOf(TabFolder.prototype), '_triggerChangeEvent', this).call(this, name, value);
          if (this.$previousSelection) {
            this.$previousSelection._trigger('disappear');
          }
          if (value) {
            value._trigger('appear');
          }
          this.$previousSelection = value;
        }
      } else {
        _get(TabFolder.prototype.__proto__ || Object.getPrototypeOf(TabFolder.prototype), '_triggerChangeEvent', this).call(this, name, value);
      }
    }
  }, {
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      var tab = this.selection;
      return _get(TabFolder.prototype.__proto__ || Object.getPrototypeOf(TabFolder.prototype), '_getXMLAttributes', this).call(this).concat([['selection', tab ? tab.toString() : '']]);
    }
  }, {
    key: '$triggerSelectionIndexChanged',
    value: function $triggerSelectionIndexChanged(_ref14) {
      var { value: tab } = _ref14;

      _get(TabFolder.prototype.__proto__ || Object.getPrototypeOf(TabFolder.prototype), '_triggerChangeEvent', this).call(this, 'selectionIndex', this._children().indexOf(tab));
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.TabFolder';
    }
  }, {
    key: 'selectionIndex',
    set: function (index) {
      var children = this._children();
      if (!children[index]) {
        hint(this, 'Can not set selectionIndex to ' + index + ', value out of bounds');
        return;
      }
      this.selection = children[index];
    },
    get: function () {
      return this._children().indexOf(this.selection);
    }
  }]);

  return TabFolder;
}(Composite);

NativeObject.defineProperties(TabFolder.prototype, {
  paging: { type: types.boolean, default: false },
  tabBarLocation: {
    choice: ['top', 'bottom', 'hidden', 'auto'],
    default: 'auto',
    const: true
  },
  tabMode: {
    type: types.string,
    choice: ['fixed', 'scrollable'],
    default: 'fixed',
    const: true
  },
  selection: {
    type: {
      convert: function (value, tabFolder) {
        var tab = types.Widget.convert(value);
        if (!tab || !(tab instanceof Tab) || tabFolder._children().indexOf(tab) < 0) {
          throw new Error('Can not set selection to ' + toValueString(value));
        }
        return tab;
      },

      encode: types.Widget.encode,
      decode: function (value, tabFolder) {
        if (!tabFolder._children().length) {
          return null;
        }
        return types.Widget.decode(value);
      }
    },
    nocache: true
  },
  tabTintColor: { type: types.ColorValue, default: 'initial' },
  selectedTabTintColor: { type: types.ColorValue, default: 'initial' },
  tabBarBackground: { type: types.ColorValue, default: 'initial' },
  tabBarElevation: { type: types.number, nocache: true },
  selectedTabIndicatorTintColor: { type: types.ColorValue, default: 'initial' }
});

NativeObject.defineChangeEvents(TabFolder.prototype, ['selectionIndex']);

NativeObject.defineEvents(TabFolder.prototype, {
  scroll: { native: true },
  select: { native: true }
});

TabFolder.prototype[JSX.jsxFactory] = createElement$3;

/** @this {import("../JsxProcessor").default} */
function createElement$3(Type, attributes) {
  var result = Composite.prototype[JSX.jsxFactory].call(this, Type, omit(attributes, ['selection', 'selectionIndex']));
  result.set(pick(attributes, ['selection', 'selectionIndex']));
  return result;
}

var Tab = function (_Composite11) {
  _inherits(Tab, _Composite11);

  function Tab() {
    _classCallCheck(this, Tab);

    return _possibleConstructorReturn(this, (Tab.__proto__ || Object.getPrototypeOf(Tab)).apply(this, arguments));
  }

  _createClass(Tab, [{
    key: '_setParent',
    value: function _setParent(parent, index) {
      if (parent && !(parent instanceof TabFolder)) {
        throw new Error('Tab could not be appended to ' + toValueString(parent));
      }
      _get(Tab.prototype.__proto__ || Object.getPrototypeOf(Tab.prototype), '_setParent', this).call(this, parent, index);
    }
  }, {
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      return _get(Tab.prototype.__proto__ || Object.getPrototypeOf(Tab.prototype), '_getXMLAttributes', this).call(this).concat([['title', this.title]]);
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Tab';
    }
  }]);

  return Tab;
}(Composite);

NativeObject.defineProperties(Tab.prototype, {
  title: { type: 'string', default: '' },
  image: { type: 'ImageValue', default: null },
  selectedImage: { type: 'ImageValue', default: null },
  badge: { type: 'natural', default: 0 },
  badgeColor: { type: 'ColorValue', default: 'initial' }
});

NativeObject.defineEvents(Tab.prototype, {
  disappear: true,
  appear: true,
  select: true,
  reselect: true
});

var TextView = function (_Widget15) {
  _inherits(TextView, _Widget15);

  function TextView() {
    _classCallCheck(this, TextView);

    return _possibleConstructorReturn(this, (TextView.__proto__ || Object.getPrototypeOf(TextView)).apply(this, arguments));
  }

  _createClass(TextView, [{
    key: '_getXMLContent',
    value: function _getXMLContent() {
      var content = _get(TextView.prototype.__proto__ || Object.getPrototypeOf(TextView.prototype), '_getXMLContent', this).call(this);
      if (this._shouldPrintTextAsXMLContent()) {
        content = content.concat(this.text.split('\n').map(function (line) {
          return '  ' + line;
        }));
      }
      return content;
    }
  }, {
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      var result = _get(TextView.prototype.__proto__ || Object.getPrototypeOf(TextView.prototype), '_getXMLAttributes', this).call(this);
      if (this.markupEnabled) {
        result.push(['markupEnabled', 'true']);
      }
      if (!this._shouldPrintTextAsXMLContent()) {
        result.push(['text', this.text]);
      }
      return result;
    }
  }, {
    key: '_shouldPrintTextAsXMLContent',
    value: function _shouldPrintTextAsXMLContent() {
      return this.markupEnabled || this.text.length > 25 || this.text.indexOf('\n') !== -1;
    }
  }, {
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'tapLink') {
        this._nativeListen(name, listening);
      } else {
        _get(TextView.prototype.__proto__ || Object.getPrototypeOf(TextView.prototype), '_listen', this).call(this, name, listening);
      }
    }

    /** @this {import("../JsxProcessor").default} */

  }, {
    key: JSX.jsxFactory,
    value: function (Type, attributes) {
      var children = this.getChildren(attributes);
      var normalAttributes = this.withoutChildren(attributes);
      return _get(TextView.prototype.__proto__ || Object.getPrototypeOf(TextView.prototype), JSX.jsxFactory, this).call(this, Type, this.withContentText(normalAttributes, children, 'text', attributes ? attributes.markupEnabled : false));
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.TextView';
    }
  }]);

  return TextView;
}(Widget);

NativeObject.defineProperties(TextView.prototype, {
  alignment: {
    type: types.string,
    choice: ['left', 'right', 'centerX'],
    default: 'left'
  },
  markupEnabled: { type: types.boolean, default: false },
  lineSpacing: { type: types.number, default: 1 },
  selectable: { type: types.boolean, default: false },
  maxLines: {
    type: {
      convert: function (value) {
        return value <= 0 ? null : types.natural.convert(value);
      } },
    default: null,
    nullable: true
  },
  text: { type: types.string, default: '' },
  textColor: { type: types.ColorValue, default: 'initial' },
  font: { type: types.FontValue, default: 'initial' }
});

NativeObject.defineEvents(TextView.prototype, {
  tapLink: { native: true }
});

var TimeDialog = function (_Popup5) {
  _inherits(TimeDialog, _Popup5);

  _createClass(TimeDialog, null, [{
    key: 'open',
    value: function open(value) {
      var timeDialog = void 0;
      if (value instanceof TimeDialog) {
        timeDialog = value;
      } else if (value instanceof Date) {
        timeDialog = new TimeDialog({ date: value });
      } else {
        timeDialog = new TimeDialog();
      }
      return timeDialog.open();
    }

    /**
     * @param {Partial<TimeDialog>=} properties
     */

  }]);

  function TimeDialog(properties) {
    _classCallCheck(this, TimeDialog);

    var _this100 = _possibleConstructorReturn(this, (TimeDialog.__proto__ || Object.getPrototypeOf(TimeDialog)).call(this, properties));

    _this100._nativeListen('close', true);
    _this100._nativeListen('select', true);
    _this100._autoDispose = true;
    return _this100;
  }

  _createClass(TimeDialog, [{
    key: '_trigger',
    value: function _trigger(name, event) {
      if (name === 'close') {
        this._handleCloseEvent(event);
      } else if (name === 'select') {
        event.date = new Date(event.date);
        _get(TimeDialog.prototype.__proto__ || Object.getPrototypeOf(TimeDialog.prototype), '_trigger', this).call(this, 'select', event);
        this._handleCloseEvent(event);
      } else {
        return _get(TimeDialog.prototype.__proto__ || Object.getPrototypeOf(TimeDialog.prototype), '_trigger', this).call(this, name, event);
      }
    }
  }, {
    key: '_handleCloseEvent',
    value: function _handleCloseEvent(event) {
      _get(TimeDialog.prototype.__proto__ || Object.getPrototypeOf(TimeDialog.prototype), '_trigger', this).call(this, 'close', event);
      this.dispose();
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.TimeDialog';
    }
  }]);

  return TimeDialog;
}(Popup);

NativeObject.defineProperties(TimeDialog.prototype, {
  date: { type: types.Date, default: null }
});

NativeObject.defineEvents(TimeDialog.prototype, {
  select: { native: true },
  close: { native: true }
});

var ToggleButton = function (_Widget16) {
  _inherits(ToggleButton, _Widget16);

  function ToggleButton() {
    _classCallCheck(this, ToggleButton);

    return _possibleConstructorReturn(this, (ToggleButton.__proto__ || Object.getPrototypeOf(ToggleButton)).apply(this, arguments));
  }

  _createClass(ToggleButton, [{
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      return _get(ToggleButton.prototype.__proto__ || Object.getPrototypeOf(ToggleButton.prototype), '_getXMLAttributes', this).call(this).concat([['text', this.text], ['checked', this.checked]]);
    }

    /** @this {import("../JsxProcessor").default} */

  }, {
    key: JSX.jsxFactory,
    value: function (Type, attributes) {
      var children = this.getChildren(attributes);
      var normalAttributes = this.withoutChildren(attributes);
      return _get(ToggleButton.prototype.__proto__ || Object.getPrototypeOf(ToggleButton.prototype), JSX.jsxFactory, this).call(this, Type, this.withContentText(normalAttributes, children, 'text'));
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.ToggleButton';
    }
  }]);

  return ToggleButton;
}(Widget);

NativeObject.defineProperties(ToggleButton.prototype, {
  text: { type: types.string, default: '' },
  image: { type: types.ImageValue, default: null },
  checked: { type: types.boolean, nocache: true },
  alignment: {
    type: types.string,
    choice: ['left', 'right', 'centerX'],
    default: 'centerX'
  },
  textColor: { type: types.ColorValue, default: 'initial' },
  font: { type: types.FontValue, default: 'initial' }
});

NativeObject.defineEvents(ToggleButton.prototype, {
  select: { native: true, changes: 'checked' }
});

var Video = function (_Widget17) {
  _inherits(Video, _Widget17);

  function Video() {
    _classCallCheck(this, Video);

    return _possibleConstructorReturn(this, (Video.__proto__ || Object.getPrototypeOf(Video)).apply(this, arguments));
  }

  _createClass(Video, [{
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'stateChanged' || name === 'speedChanged') {
        this._nativeListen(name, listening);
      } else {
        _get(Video.prototype.__proto__ || Object.getPrototypeOf(Video.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_trigger',
    value: function _trigger(name, event) {
      if (name === 'stateChanged') {
        return this._triggerChangeEvent('state', event.state);
      } else if (name === 'speedChanged') {
        return this._triggerChangeEvent('speed', event.speed);
      }
      return _get(Video.prototype.__proto__ || Object.getPrototypeOf(Video.prototype), '_trigger', this).call(this, name, event);
    }
  }, {
    key: 'pause',
    value: function pause() {
      this._nativeCall('pause');
    }
  }, {
    key: 'play',
    value: function play(speed) {
      this._nativeCall('play', {
        speed: arguments.length > 0 ? types.number.convert(speed) : 1
      });
    }
  }, {
    key: 'seek',
    value: function seek(position) {
      this._nativeCall('seek', { position: types.number.convert(position) });
    }
  }, {
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      var result = _get(Video.prototype.__proto__ || Object.getPrototypeOf(Video.prototype), '_getXMLAttributes', this).call(this);
      if (this.url) {
        result.push(['url', this.url]);
      }
      result.push(['state', this.state]);
      if (this.state === 'play') {
        result.push(['speed', this.speed]);
      }
      if (this.state !== 'empty') {
        result.push(['position', this.position]);
      }
      if (this.duration) {
        result.push(['duration', this.duration]);
      }
      return result;
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Video';
    }
  }]);

  return Video;
}(Widget);

NativeObject.defineProperties(Video.prototype, {
  url: { type: 'string', default: '' },
  controlsVisible: { type: 'boolean', default: true },
  autoPlay: { type: 'boolean', default: true },
  speed: { readonly: true, nocache: true },
  position: { readonly: true, nocache: true },
  duration: { readonly: true, nocache: true },
  state: { readonly: true, nocache: true }
});

var EVENT_TYPES = ['navigate', 'load', 'download', 'message'];

var WebView = function (_Widget18) {
  _inherits(WebView, _Widget18);

  function WebView() {
    _classCallCheck(this, WebView);

    return _possibleConstructorReturn(this, (WebView.__proto__ || Object.getPrototypeOf(WebView)).apply(this, arguments));
  }

  _createClass(WebView, [{
    key: '_listen',
    value: function _listen(name, listening) {
      if (EVENT_TYPES.includes(name)) {
        this._nativeListen(name, listening);
      } else {
        _get(WebView.prototype.__proto__ || Object.getPrototypeOf(WebView.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: 'postMessage',
    value: function postMessage(data, targetOrigin) {
      this._nativeCall('postMessage', {
        data: data,
        origin: targetOrigin
      });
      return this;
    }
  }, {
    key: 'goBack',
    value: function goBack() {
      this._nativeCall('goBack');
    }
  }, {
    key: 'goForward',
    value: function goForward() {
      this._nativeCall('goForward');
    }
  }, {
    key: '_loadData',
    value: function _loadData(data, mimeType) {
      this._nativeCall('loadData', { data: data, mimeType: mimeType });
    }
  }, {
    key: '_getXMLContent',
    value: function _getXMLContent() {
      var content = _get(WebView.prototype.__proto__ || Object.getPrototypeOf(WebView.prototype), '_getXMLContent', this).call(this);
      if (this.html) {
        content = content.concat(this.html.split('\n').map(function (line) {
          return '  ' + line;
        }));
      }
      return content;
    }
  }, {
    key: '_getXMLAttributes',
    value: function _getXMLAttributes() {
      var result = _get(WebView.prototype.__proto__ || Object.getPrototypeOf(WebView.prototype), '_getXMLAttributes', this).call(this);
      if (this.url) {
        result.push(['url', this.url]);
      }
      return result;
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.WebView';
    }
  }]);

  return WebView;
}(Widget);

NativeObject.defineProperties(WebView.prototype, {
  url: { type: 'string', nocache: true },
  html: { type: 'string', nocache: true },
  headers: { type: 'any', default: Object.freeze({}) },
  canGoBack: { type: 'boolean', readonly: true, nocache: true },
  canGoForward: { type: 'boolean', readonly: true, nocache: true },
  initScript: { type: 'string', default: null, nullable: true }
});

NativeObject.defineEvents(WebView.prototype, {
  load: { native: true },
  message: { native: true }
});

var CONNECTING = 0;
var OPEN = 1;
var CLOSING = 2;
var CLOSED = 3;
var CONSTANTS = {
  CONNECTING: { value: CONNECTING },
  OPEN: { value: OPEN },
  CLOSING: { value: CLOSING },
  CLOSED: { value: CLOSED }
};
var EVENT_TYPES$1 = ['open', 'message', 'close', 'error'];

var _WebSocket = function (_NativeObject23) {
  _inherits(_WebSocket, _NativeObject23);

  function _WebSocket(properties) {
    _classCallCheck(this, _WebSocket);

    var _this104 = _possibleConstructorReturn(this, (_WebSocket.__proto__ || Object.getPrototypeOf(_WebSocket)).call(this, properties));

    EVENT_TYPES$1.forEach(function (type) {
      return _this104._nativeListen(type, true);
    });
    return _this104;
  }

  _createClass(_WebSocket, [{
    key: '_nativeType',
    get: function () {
      return 'tabris.WebSocket';
    }
  }]);

  return _WebSocket;
}(NativeObject);

NativeObject.defineProperties(_WebSocket.prototype, {
  url: { type: 'string', default: '' },
  protocol: { type: 'any', default: '' },
  binaryType: { type: 'string', default: 'blob' },
  bufferedAmount: { type: 'number', nocache: true }
});

var WebSocket = function () {
  function WebSocket(url, protocol) {
    _classCallCheck(this, WebSocket);

    if (typeof url !== 'string') {
      throw new Error('WebSocket url ' + toValueString(url) + ' is not a string');
    }
    var scheme = extractScheme(url);
    if (!(scheme === 'ws' || scheme === 'wss')) {
      throw new Error("The WebSocket url has to have a scheme of 'ws' or 'wss' but is '" + scheme + "'");
    }
    if (typeof protocol !== 'string' && !Array.isArray(protocol)) {
      throw new Error('The WebSocket protocol has too be a string or an array of strings');
    }
    var protocols = Array.isArray(protocol) ? protocol : [protocol];
    this.url = url;
    this.readyState = CONNECTING;
    this.protocol = '';
    this.extensions = '';
    addDOMEventTargetMethods(this);
    defineEventHandlerProperties(this, EVENT_TYPES$1);
    Object.defineProperty(this, '_nativeObject', {
      enumerable: false, writable: false, value: this.$createProxy(url, protocols)
    });
  }

  _createClass(WebSocket, [{
    key: '$createProxy',
    value: function $createProxy(url, protocols) {
      var _this105 = this;

      return new _WebSocket({
        url: url,
        protocol: protocols
      }).on('open', function (event) {
        _this105.readyState = OPEN;
        _this105.protocol = event.protocol;
        _this105.extensions = event.extensions;
        _this105.dispatchEvent(Object.assign(new Event('open'), omit(event, ['target', 'type', 'timeStamp'])));
      }).on('message', function (event) {
        if (_this105.readyState === OPEN) {
          _this105.dispatchEvent(Object.assign(new Event('message'), omit(event, ['target', 'type', 'timeStamp'])));
        }
      }).on('close', function (event) {
        _this105.readyState = CLOSED;
        _this105.dispatchEvent(Object.assign(new Event('close'), omit(event, ['target', 'type', 'timeStamp'])));
      }).on('error', function (event) {
        _this105.readyState = CLOSED;
        _this105.dispatchEvent(Object.assign(new Event('error'), omit(event, ['target', 'type', 'timeStamp'])));
      });
    }
  }, {
    key: 'send',
    value: function send(data) {
      if (this.readyState === CONNECTING) {
        throw new Error("Can not 'send' WebSocket message when WebSocket state is CONNECTING");
      }
      if (typeof data === 'string') {
        this._nativeObject._nativeCall('send', { data: data });
      } else if (isReadable(data)) {
        this._nativeObject._nativeCall('send', { data: read(data) });
      } else {
        throw new Error('Data of type ' + typeof data + " is not supported in WebSocket 'send' operation");
      }
    }
  }, {
    key: 'close',
    value: function close(code, reason) {
      if (code && (typeof code !== 'number' || !(typeof code === 'number' && (code === 1000 || code >= 3000 && code <= 4999)))) {
        throw new Error('A given close code has to be either 1000 or in the range 3000 - 4999 inclusive');
      }
      if (reason && getStringByteSize(reason) > 123) {
        throw new Error('The close reason can not be larger than 123 utf-8 bytes');
      }
      if (this.readyState !== CLOSING && this.readyState !== CLOSED) {
        this.readyState = CLOSING;
        var _properties = {};
        if (code) {
          _properties.code = code;
        }
        if (reason) {
          _properties.reason = reason;
        }
        this._nativeObject._nativeCall('close', _properties);
      }
    }
  }, {
    key: 'binaryType',
    set: function (binaryType) {
      this._nativeObject.binaryType = binaryType;
    },
    get: function () {
      return this._nativeObject.binaryType;
    }
  }, {
    key: 'bufferedAmount',
    set: function (bufferedAmount) {
      hint(this, 'Can not set read-only property "bufferedAmount"');
    },
    get: function () {
      return this._nativeObject.bufferedAmount;
    }
  }]);

  return WebSocket;
}();

Object.defineProperties(WebSocket, CONSTANTS);
Object.defineProperties(WebSocket.prototype, CONSTANTS);

function getStringByteSize(input) {
  var len = 0;
  // TODO: workaround for https://github.com/babel/babili/issues/430
  if (!input.length) {
    return 0;
  }
  for (var i = 0; i < input.length; i++) {
    var code = input.charCodeAt(i);
    if (code <= 0x7f) {
      len += 1;
    } else if (code <= 0x7ff) {
      len += 2;
    } else if (code >= 0xd800 && code <= 0xdfff) {
      // Surrogate pair: These take 4 bytes in UTF-8 and 2 chars in UCS-2
      // (Assume next char is the other [valid] half and just skip it)
      len += 4;
      i++;
    } else if (code < 0xffff) {
      len += 3;
    } else {
      len += 4;
    }
  }
  return len;
}

function extractScheme(url) {
  var match = /^(\S+?):/.exec(url);
  return match ? match[1] : null;
}

var EVENT_TYPES$2 = ['message', 'error', 'messageerror'];

var _Worker = function (_NativeObject24) {
  _inherits(_Worker, _NativeObject24);

  function _Worker() {
    _classCallCheck(this, _Worker);

    return _possibleConstructorReturn(this, (_Worker.__proto__ || Object.getPrototypeOf(_Worker)).apply(this, arguments));
  }

  _createClass(_Worker, [{
    key: '_nativeType',
    get: function () {
      return 'tabris.Worker';
    }
  }]);

  return _Worker;
}(NativeObject);

NativeObject.defineProperty(_Worker.prototype, 'scriptPath', { type: 'string', default: '' });
NativeObject.defineEvents(_Worker.prototype, {
  message: { native: true },
  error: { native: true },
  messageError: true
});

var Worker = function () {
  function Worker(scriptPath) {
    _classCallCheck(this, Worker);

    if (typeof scriptPath !== 'string') {
      throw new Error('The Worker script path has to be of type string');
    }
    addDOMEventTargetMethods(this);
    defineEventHandlerProperties(this, EVENT_TYPES$2);
    Object.defineProperty(this, '_nativeObject', {
      enumerable: false, writable: false, value: this.$createProxy({ scriptPath: scriptPath })
    });
  }

  _createClass(Worker, [{
    key: '$createProxy',
    value: function $createProxy(scriptPath) {
      var _this107 = this;

      return new _Worker(scriptPath).onMessage(function (event) {
        _this107.dispatchEvent(Object.assign(new Event('message'), omit(event, ['target', 'type', 'timeStamp'])));
      }).onError(function (event) {
        _this107.dispatchEvent(Object.assign(new Event('error'), omit(event, ['target', 'type', 'timeStamp'])));
      }).onMessageError(function (event) {
        _this107.dispatchEvent(Object.assign(new Event('messageerror'), omit(event, ['target', 'type', 'timeStamp'])));
      });
    }
  }, {
    key: 'postMessage',
    value: function postMessage(message, transferList) {
      this._validateMessage(message);
      this._nativeObject._nativeCall('postMessage', { message: message, transferList: transferList });
    }
  }, {
    key: '_validateMessage',
    value: function _validateMessage(message) {
      if (!this._isValidMessage(message)) {
        this.dispatchEvent(Object.assign(new Event('messageerror')));
      } else {
        if (message instanceof Array) {
          for (var i = 0; i < message.length; i++) {
            this._validateMessage(message[i]);
          }
        } else if (typeof message === 'object') {
          for (var property in message) {
            if (message.hasOwnProperty(property)) {
              this._validateMessage(message[property]);
            }
          }
        }
      }
    }
  }, {
    key: '_isValidMessage',
    value: function _isValidMessage(message) {
      return message === undefined || message === null || typeof message === 'string' || typeof message === 'number' || typeof message === 'boolean' || message && (message.constructor === Object || message.constructor === Array || message.constructor === DataView || message.constructor === ArrayBuffer || message.constructor === ImageData);
    }
  }, {
    key: 'terminate',
    value: function terminate() {
      this._nativeObject._nativeCall('terminate');
    }
  }]);

  return Worker;
}();

var HttpRequest = function (_NativeObject25) {
  _inherits(HttpRequest, _NativeObject25);

  function HttpRequest() {
    _classCallCheck(this, HttpRequest);

    var _this108 = _possibleConstructorReturn(this, (HttpRequest.__proto__ || Object.getPrototypeOf(HttpRequest)).call(this));

    _this108._nativeListen('stateChanged', true);
    _this108._nativeListen('downloadProgress', true);
    _this108._nativeListen('uploadProgress', true);
    return _this108;
  }

  _createClass(HttpRequest, [{
    key: 'abort',
    value: function abort() {
      this._nativeCall('abort', {});
    }
  }, {
    key: 'send',
    value: function send(config) {
      this._nativeCall('send', config);
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.HttpRequest';
    }
  }]);

  return HttpRequest;
}(NativeObject);

// XHR Spec: https://xhr.spec.whatwg.org/

var UNSENT = 0;
var OPENED = 1;
var HEADERS_RECEIVED = 2;
var LOADING = 3;
var DONE = 4;

var EVENT_TYPES$3 = ['loadstart', 'readystatechange', 'load', 'loadend', 'progress', 'timeout', 'abort', 'error'];
var UPLOAD_EVENT_TYPES = ['progress', 'loadstart', 'load', 'loadend', 'timeout', 'abort', 'error'];

var SUPPORTED_SCHEMES = ['http', 'https', 'file'];

var XMLHttpRequest = function () {
  function XMLHttpRequest() {
    _classCallCheck(this, XMLHttpRequest);

    Object.defineProperties(this, {
      $authorRequestHeaders: { enumerable: false, writable: true, value: {} },
      $timeout: { enumerable: false, writable: true, value: 0 },
      $status: { enumerable: false, writable: true, value: 0 },
      $statusText: { enumerable: false, writable: true, value: '' },
      $responseHeaders: { enumerable: false, writable: true, value: '' },
      $readyState: { enumerable: false, writable: true, value: UNSENT },
      $responseData: { enumerable: false, writable: true, value: '' },
      $withCredentials: { enumerable: false, writable: true, value: false },
      $responseType: { enumerable: false, writable: true, value: '' },
      $sendInvoked: { enumerable: false, writable: true, value: false },
      $isSynchronous: { enumerable: false, writable: true, value: false },
      $error: { enumerable: false, writable: true, value: false },
      $uploadComplete: { enumerable: false, writable: true, value: false },
      upload: { value: {} }
    });
    defineEventHandlerProperties(this, EVENT_TYPES$3);
    defineEventHandlerProperties(this.upload, UPLOAD_EVENT_TYPES);
    addDOMEventTargetMethods(this);
    addDOMEventTargetMethods(this.upload);
  }

  _createClass(XMLHttpRequest, [{
    key: 'open',
    value: function open(method, url, async) {
      var parsedUrl = {};
      // (2), (3), (4): we don't implement the 'settings' object
      validateRequiredOpenArgs(method, url);
      parsedUrl.source = url; // (8), (9): experimental non-standard parsing implementation:
      // regex taken from http://stackoverflow.com/a/19709846:
      parsedUrl.isRelative = !new RegExp('^(?:[a-z]+:)?//', 'i').test(url);
      if (typeof async === 'undefined') {
        // (10)
        async = true;
      }
      if (!async) {
        throw new Error('Only asynchronous request supported.');
      }
      // (12): superfluous as we don't support synchronous requests
      // TODO: (13) - should we call 'abort' to the nativeObject? We'd need to move the creation of the nativeObject
      // to the open() function
      this.$requestMethod = method; // (14)
      this.$requestUrl = parsedUrl;
      this.$isSynchronous = !async;
      this.$authorRequestHeaders = {};
      this.$sendInvoked = false;
      this.$responseData = null;
      if (this.$readyState !== OPENED) {
        // (15)
        this.$readyState = OPENED;
        dispatchEvent('readystatechange', this);
      }
    }
  }, {
    key: 'send',
    value: function send(data) {
      var _this109 = this;

      this.$nativeObject = new HttpRequest().on('stateChanged', function (event) {
        return handleStateChange(event, _this109);
      }).on('downloadProgress', function (event) {
        return dispatchProgressEvent('progress', _this109, event);
      }).on('uploadProgress', function (event) {
        return dispatchProgressEvent('progress', _this109.upload, event);
      });
      if (this.$readyState !== OPENED) {
        // (1)
        throw new Error("InvalidStateError: Object's state must be 'OPENED', failed to execute 'send'");
      }
      if (this.$sendInvoked) {
        // (2)
        throw new Error("InvalidStateError: 'send' invoked, failed to execute 'send'");
      }
      if (['GET', 'HEAD'].indexOf(this.$requestMethod) > -1) {
        // (3)
        data = null;
      }
      if (data instanceof FormData) {
        data = formDataToBlob(data);
      }
      this.$requestBody = data && getBytes(data) ? getBytes(data) : data; // (4)
      if (data instanceof Blob && Object.keys(this.$authorRequestHeaders).map(function (str) {
        return str.toLowerCase();
      }).indexOf('content-type') === -1) {
        this.$authorRequestHeaders['Content-Type'] = data.type;
      }
      // TODO: support encoding and mimetype for string response types
      // (5): no storage mutex
      this.$error = this.$uploadComplete = false; // (6), see (8)
      if (!data) {
        // (7)
        this.$uploadComplete = true;
      }
      // (8): uploadEvents is relevant for the "force preflight flag", but this logic is handled by
      // the client
      // Basic access authentication
      this.$sendInvoked = true; // (9.1)
      dispatchProgressEvent('loadstart', this); // (9.2)
      if (!this.$uploadComplete) {
        dispatchProgressEvent('loadstart', this.upload); // (9.3)
      }
      // (10): only handling the same origin case
      this.$nativeObject.send({ // request URL fetch
        url: this.$requestUrl.source,
        method: this.$requestMethod,
        timeout: this.timeout,
        headers: this.$authorRequestHeaders,
        data: this.$requestBody,
        responseType: this.$responseType
      });
    }
  }, {
    key: 'abort',
    value: function abort() {
      if (this.$nativeObject) {
        this.$nativeObject.abort(); // (1)
      }
      if (!([UNSENT, OPENED].indexOf(this.$readyState) > -1 && !this.$sendInvoked || this.$readyState === DONE)) {
        // send() interrupted
        // (2.1), (2.2): setting readyState DONE with sendInvoked true or false seems to be an
        // internal state which doesn't affect the behavior and thus cannot be tested
        dispatchEvent('readystatechange', this); // (2.3)
        if (!this.$uploadComplete) {
          this.$uploadComplete = true; // (2.4.1)
          dispatchAbortProgressEvents(this.upload); // (2.4.2), (2.4.3), (2.4.4)
        }
        dispatchAbortProgressEvents(this); // (2.5), (2.6), (2.7)
      }
      this.$readyState = UNSENT; // (3)
    }
  }, {
    key: 'setRequestHeader',
    value: function setRequestHeader(header, value) {
      // #dom-xmlhttprequest-setrequestheader
      if (this.$readyState !== OPENED) {
        // (1)
        throw new Error('InvalidStateError: ' + "Object's state must be 'OPENED', failed to execute 'setRequestHeader'");
      }
      if (this.$sendInvoked) {
        // (2)
        throw new Error('InvalidStateError: ' + "cannot set request header if 'send()' invoked and request not completed");
      }
      if (!validHttpToken(header)) {
        // (3)
        throw new TypeError("Invalid HTTP header name, failed to execute 'open'");
      }
      if (!isValidHttpHeaderValue(value)) {
        // (4)
        throw new TypeError("Invalid HTTP header value, failed to execute 'open'");
      }
      // (5) (No headers are filtered out as this restriction does not apply to native apps)
      if (header in this.$authorRequestHeaders) {
        // (6):
        this.$authorRequestHeaders[header] = this.$authorRequestHeaders[header] + ', ' + value; // (7)
      } else {
        this.$authorRequestHeaders[header] = value; // (8)
      }
    }
  }, {
    key: 'getResponseHeader',
    value: function getResponseHeader(header) {
      // #the-getresponseheader()-method
      if ([UNSENT, OPENED].indexOf(this.readyState) > -1) {
        // (1)
        return null;
      }
      if (this.$error) {
        // (2)
        return null;
      }
      // (3) (No headers are filtered out as this restriction does not apply to native apps)
      for (var key in this.$responseHeaders) {
        // (4), (5)
        if (key.toLowerCase() === header.toLowerCase()) {
          return this.$responseHeaders[key];
        }
      }
      return null; // (6)
    }
  }, {
    key: 'getAllResponseHeaders',
    value: function getAllResponseHeaders() {
      // #the-getallresponseheaders()-method
      if ([UNSENT, OPENED].indexOf(this.readyState) > -1) {
        // (1)
        return '';
      }
      if (this.$error) {
        // (2)
        return '';
      }
      var result = [];
      for (var key in this.$responseHeaders) {
        result.push(key + ': ' + this.$responseHeaders[key]);
      }
      return result.join('\r\n');
    }
  }, {
    key: 'readyState',
    get: function () {
      return this.$readyState;
    }
  }, {
    key: 'timeout',
    get: function () {
      return this.$timeout;
    },
    set: function (value) {
      // (1): superfluous, as we don't support synchronous requests
      if (!isNaN(value)) {
        // (2)
        this.$timeout = Math.round(value);
      }
    }
  }, {
    key: 'responseText',
    get: function () {
      // 1. If responseType is not the empty string or "text", throw an InvalidStateError exception.
      if (this.$responseType !== '' && this.$responseType !== 'text') {
        throw new Error('XHR responseText not accessible for non-text responseType');
      }
      // 2. If state is not loading or done, return the empty string.
      if (this.$readyState !== LOADING && this.$readyState !== DONE) {
        return '';
      }
      // 3. Return the text response.
      return this.$responseData || '';
    }
  }, {
    key: 'response',
    get: function () {
      // If responseType is the empty string or "text"
      if (this.$responseType === '' || this.$responseType === 'string') {
        // 1. If state is not loading or done, return the empty string.
        if (this.$readyState !== LOADING && this.$readyState !== DONE) {
          return '';
        }
        // 2. Return the text response.
        return this.$responseData || '';
      }
      // Otherwise
      // 1. If state is not done, return null.
      if (this.$readyState !== DONE) {
        return null;
      }
      // 2. If responseType is "arraybuffer"
      // Return the arraybuffer response.
      return this.$responseData;
    }
  }, {
    key: 'responseType',
    get: function () {
      return this.$responseType;
    },
    set: function (value) {
      // 1. (concurrency related, skip)
      // 2. If state is loading or done, throw an InvalidStateError exception.
      if (this.$readyState === LOADING || this.$readyState === DONE) {
        throw new Error('The response type cannot be set when state is LOADING or DONE.');
      }
      // 3. (concurrency related, skip)
      // 4. Set the responseType attribute's value to the given value.
      // mimicking Chromium and Firefox behaviour when setting a not allowed responseType:
      if (['arraybuffer', 'blob', 'document', 'json', 'text'].indexOf(value) < 0) {
        return;
      }
      // currently only the response types 'text' and 'arraybuffer' are supported
      if (['blob', 'document', 'json'].indexOf(value) > -1) {
        throw new Error("Unsupported responseType, only 'text' and 'arraybuffer' are supported");
      }
      this.$responseType = value;
    }
  }, {
    key: 'status',
    get: function () {
      if ([OPENED, UNSENT].indexOf(this.$readyState) > -1) {
        return 0;
      }
      if (this.$error) {
        return 0;
      }
      return this.$status;
    }
  }, {
    key: 'statusText',
    get: function () {
      if ([OPENED, UNSENT].indexOf(this.$readyState) > -1) {
        return '';
      }
      if (this.$error) {
        return '';
      }
      return this.$statusText;
    }
  }, {
    key: 'withCredentials',
    get: function () {
      return this.$withCredentials;
    },
    set: function (value) {
      if (this.$readyState !== UNSENT && this.$readyState !== OPENED) {
        throw new Error("InvalidStateError: state must be 'UNSENT' or 'OPENED' when setting withCredentials");
      }
      if (this.$sendInvoked) {
        throw new Error("InvalidStateError: 'send' invoked, failed to set 'withCredentials'");
      }
      // (3): superfluous as we don't support synchronous requests
      // mimicking Chromium and Firefox behaviour when setting a non-boolean value:
      if (typeof value === 'boolean') {
        this.$withCredentials = value; // (4)
      }
    }
  }]);

  return XMLHttpRequest;
}();

Object.defineProperties(XMLHttpRequest.prototype, {
  UNSENT: { value: UNSENT },
  OPENED: { value: OPENED },
  HEADERS_RECEIVED: { value: HEADERS_RECEIVED },
  LOADING: { value: LOADING },
  DONE: { value: DONE }
});

function handleStateChange(event, xhr) {
  // Note: we supply lengthComputable, loaded and total only with the "progress" event types
  switch (event.state) {
    case 'headers':
      xhr.$readyState = HEADERS_RECEIVED;
      xhr.$status = event.code;
      xhr.$statusText = event.message;
      xhr.$responseHeaders = event.headers;
      dispatchEvent('readystatechange', xhr);
      xhr.$uploadComplete = true; // #make-upload-progress-notifications
      dispatchFinishedProgressEvents(xhr.upload);
      break;
    case 'loading':
      xhr.$readyState = LOADING;
      dispatchEvent('readystatechange', xhr);
      break;
    case 'finished':
      // TODO create response based on responseType
      xhr.$responseData = event.response;
      xhr.$readyState = DONE;
      dispatchEvent('readystatechange', xhr);
      dispatchFinishedProgressEvents(xhr);
      dispatchFinishedProgressEvents(xhr.upload);
      xhr.$nativeObject.dispose();
      xhr.$nativeObject = null;
      break;
    case 'error':
      handleRequestError('error', xhr);
      break;
    case 'timeout':
      handleRequestError('timeout', xhr);
      break;
    case 'abort':
      handleRequestError('abort', xhr);
      break;
  }
}

function handleRequestError(type, xhr) {
  xhr.$error = true; // (1*) (#terminate-the-request)
  xhr.$readyState = DONE; // (1)
  // (2): superfluous as we don't support synchronous requests
  dispatchEvent('readystatechange', xhr); // (3)
  dispatchErrorProgressEvents(type, xhr);
  if (!xhr.$uploadComplete) {
    xhr.$uploadComplete = true;
    dispatchErrorProgressEvents(type, xhr.upload);
  }
  xhr.$nativeObject.dispose();
  xhr.$nativeObject = null;
}

function validateRequiredOpenArgs(method, url) {
  if (!method) {
    throw new TypeError("Method argument should be specified to execute 'open'");
  }
  if (!url) {
    throw new TypeError("URL argument should be specified to execute 'open'");
  }
  validateMethod(method);
  validateUrl(url);
}

function validateMethod(method) {
  if (!validHttpToken(method)) {
    throw new TypeError("Invalid HTTP method, failed to execute 'open'");
  }
  // (6):
  var tokens = ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT', 'TRACE', 'TRACK'];
  var uppercaseMethod = method.toUpperCase();
  if (tokens.indexOf(uppercaseMethod) >= 0) {
    method = uppercaseMethod;
  }
  var forbiddenTokens = ['CONNECT', 'TRACE', 'TRACK']; // (7)
  if (forbiddenTokens.indexOf(method) >= 0) {
    throw new Error('SecurityError: \'' + method + '\' HTTP method is not secure, failed to execute \'open\'');
  }
}

function validHttpToken(httpToken) {
  // RFC-compliant validation for HTTP tokens ported from Chromium:
  // https://chromium.googlesource.com/chromium/blink.git/+/master/Source/platform/network/HTTPParsers.cpp
  var forbiddenCharacters = ['(', ')', '<', '>', '@', ',', ';', ':', '\\', '"', '/', '[', ']', '?', '=', '{', '}'];
  return !(/[^\x21-\x7E]/.test(httpToken) || forbiddenCharacters.indexOf(httpToken) >= 0);
}

function isValidHttpHeaderValue(value) {
  // non-RFC compliant validation for HTTP header values ported from Chromium:
  // https://chromium.googlesource.com/chromium/blink.git/+/master/Source/platform/network/HTTPParsers.cpp
  // Regex for Latin-1 characters based on: http://www.ic.unicamp.br/~stolfi/EXPORT/www/ISO-8859-1-Encoding.html
  return (/^[\x09\x0A\x0D\x20-\x7E\xA0-\xFF]*$/.test(value) && value.indexOf('\n') < 0 && value.indexOf('\r') < 0
  );
}

function validateUrl(url) {
  // TODO: rewrite (8),(9)
  var scheme = extractScheme$1(url);
  if (scheme && SUPPORTED_SCHEMES.indexOf(scheme) === -1) {
    throw new SyntaxError("Unsupported URL scheme, failed to execute 'open'");
  }
}

function extractScheme$1(url) {
  var match = /^(\S+?):/.exec(url);
  return match ? match[1] : null;
}

function dispatchEvent(type, target) {
  target.dispatchEvent(new Event(type));
}

function dispatchProgressEvent(type, target, config) {
  target.dispatchEvent(new ProgressEvent(type, config));
}

function dispatchAbortProgressEvents(target) {
  dispatchProgressEvent('progress', target);
  dispatchProgressEvent('abort', target);
  dispatchProgressEvent('loadend', target);
}

function dispatchErrorProgressEvents(type, target) {
  dispatchProgressEvent('progress', target);
  dispatchProgressEvent(type, target);
  dispatchProgressEvent('loadend', target);
}

function dispatchFinishedProgressEvents(target) {
  // Note: progress event is dispatched separately by the downloadProgress/uploadProgress callbacks
  dispatchProgressEvent('load', target);
  dispatchProgressEvent('loadend', target);
}

/**
 * @param {any=} param
 * @param {Array=} arr
 * @returns {any}
 */
function $(param) {
  if (typeof param === 'number') {
    // @ts-ignore
    return tabris._nativeObjectRegistry.find('$' + param);
  }
  if (typeof param === 'string' || param instanceof Function || arguments.length === 0) {
    // @ts-ignore
    return tabris.contentView.find(param || '*');
  }
  if (!(param instanceof Object)) {
    return '' + param;
  }
  if (!Object.keys(param).length) {
    return new WidgetCollection();
  }
  if (Object.keys(param).length > 1 || !('children' in param)) {
    throw new Error('$ does not support attributes');
  }
  var flat = normalizeChildren(param.children);
  if (flat.some(function (entry) {
    return entry instanceof Widget;
  })) {
    var result = [];
    var str = [];
    flat.forEach(function (entry) {
      if (entry instanceof Widget) {
        if (str.length) {
          result.push(new TextView({ text: joinTextContent(str, false) }));
          str = [];
        }
        result.push(entry);
      } else {
        str.push(entry);
      }
    });
    if (str.length) {
      result.push(new TextView({ text: joinTextContent(str, false) }));
    }
    return new WidgetCollection(result);
  }
  return joinTextContent(flat, false);
}

/**
 * Original work Copyright (c) 2014-2016 GitHub, Inc.
 * Implementation based on https://github.com/github/fetch
 */

var Headers = function () {
  function Headers(headers) {
    var _this110 = this;

    _classCallCheck(this, Headers);

    Object.defineProperties(this, {
      $map: { enumerable: false, writable: true, value: {} }
    });
    if (headers instanceof Headers) {
      headers.forEach(function (value, name) {
        return _this110.append(name, value);
      });
    } else if (Array.isArray(headers)) {
      headers.forEach(function (header) {
        return _this110.append(header[0], header[1]);
      });
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function (name) {
        return _this110.append(name, headers[name]);
      });
    }
  }

  _createClass(Headers, [{
    key: 'append',
    value: function append(name, value) {
      name = normalizeName(name);
      var oldValue = this.$map[name];
      this.$map[name] = oldValue ? oldValue + ',' + value : '' + value;
    }
  }, {
    key: 'delete',
    value: function _delete(name) {
      delete this.$map[normalizeName(name)];
    }
  }, {
    key: 'get',
    value: function get(name) {
      name = normalizeName(name);
      return this.has(name) ? this.$map[name] : null;
    }
  }, {
    key: 'has',
    value: function has(name) {
      return this.$map.hasOwnProperty(normalizeName(name));
    }
  }, {
    key: 'set',
    value: function set(name, value) {
      this.$map[normalizeName(name)] = '' + value;
    }
  }, {
    key: 'forEach',
    value: function forEach(callback, thisArg) {
      for (var name in this.$map) {
        if (this.$map.hasOwnProperty(name)) {
          callback.call(thisArg, this.$map[name], name, this);
        }
      }
    }
  }, {
    key: 'keys',
    value: function keys() {
      var items = [];
      this.forEach(function (value, name) {
        return items.push(name);
      });
      return iteratorFor(items);
    }
  }, {
    key: 'values',
    value: function values() {
      var items = [];
      this.forEach(function (value) {
        return items.push(value);
      });
      return iteratorFor(items);
    }
  }, {
    key: 'entries',
    value: function entries() {
      var items = [];
      this.forEach(function (value, name) {
        return items.push([name, value]);
      });
      return iteratorFor(items);
    }
  }, {
    key: iteratorSymbol(),
    value: function () {
      return this.entries();
    }
  }]);

  return Headers;
}();

function normalizeName(name) {
  name = '' + name;
  if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
    throw new TypeError('Invalid character in header field name');
  }
  return name.toLowerCase();
}

function iteratorFor(items) {
  var iterator = {
    next: function () {
      var value = items.shift();
      return { done: value === undefined, value: value };
    }
  };
  iterator[iteratorSymbol()] = function () {
    return iterator;
  };
  return iterator;
}

// TODO replace when ES6 iterator is available on all platforms
function iteratorSymbol() {
  return 'Symbol' in global && 'iterator' in global.Symbol ? global.Symbol.iterator : '@@iterator';
}

/**
 * Original work Copyright (c) 2014-2016 GitHub, Inc.
 * Implementation based on https://github.com/github/fetch
 */

var Body = function () {
  function Body() {
    _classCallCheck(this, Body);

    Object.defineProperties(this, {
      $bodyUsed: { enumerable: false, writable: true, value: false }
    });
  }

  _createClass(Body, [{
    key: '_initBody',
    value: function _initBody(body) {
      Object.defineProperty(this, '_bodyInit', {
        enumerable: false, writable: false, value: body
      });
      if (!body) {
        Object.defineProperty(this, '_bodyText', {
          enumerable: false, writable: false, value: ''
        });
      } else if (typeof body === 'string') {
        Object.defineProperty(this, '_bodyText', {
          enumerable: false, writable: false, value: body
        });
      } else if (isReadable(body)) {
        Object.defineProperty(this, '_bodyBuffer', {
          enumerable: false, writable: false, value: read(body)
        });
      } else {
        throw new Error('unsupported BodyInit type');
      }
    }
  }, {
    key: 'text',
    value: function text() {
      return this.$consumed() || Promise.resolve(this._bodyBuffer ? TextDecoder.decode(this._bodyBuffer, this._encoding) : this._bodyText);
    }
  }, {
    key: 'json',
    value: function json() {
      return this.text().then(JSON.parse);
    }
  }, {
    key: 'blob',
    value: function blob() {
      return this.arrayBuffer().then(function (buffer) {
        return new Blob([buffer]);
      });
    }
  }, {
    key: 'arrayBuffer',
    value: function arrayBuffer() {
      return this.$consumed() || Promise.resolve(this._bodyBuffer.slice(0));
    }
  }, {
    key: '$consumed',
    value: function $consumed() {
      if (this.$bodyUsed) {
        return Promise.reject(new TypeError('Already read'));
      }
      this.$bodyUsed = true;
    }
  }, {
    key: 'bodyUsed',
    get: function () {
      return !!this.$bodyUsed;
    }
  }, {
    key: '_encoding',
    get: function () {}
  }]);

  return Body;
}();

/**
 * Original work Copyright (c) 2014-2016 GitHub, Inc.
 * Implementation based on https://github.com/github/fetch
 */
// HTTP methods whose capitalization should be normalized


var METHODS = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

var Request = function (_Body) {
  _inherits(Request, _Body);

  function Request(input) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Request);

    var _this111 = _possibleConstructorReturn(this, (Request.__proto__ || Object.getPrototypeOf(Request)).call(this));

    var body = options.body;
    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read');
      }
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.$bodyUsed = true;
      }
    } else {
      input = {
        url: input
      };
    }
    Object.defineProperties(_this111, {
      url: { value: '' + input.url },
      method: { value: normalizeMethod(options.method || input.method || 'GET') },
      headers: { value: new Headers(options.headers || input.headers || {}) },
      credentials: { value: options.credentials || input.credentials || 'omit' },
      mode: { value: options.mode || input.mode || null },
      referrer: { value: '' },
      timeout: { value: options.timeout || 0 }
    });
    if ((_this111.method === 'GET' || _this111.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests');
    }
    if (body instanceof FormData) {
      body = formDataToBlob(body);
    }
    if (body instanceof Blob && !_this111.headers.has('Content-Type')) {
      _this111.headers.set('Content-Type', body.type);
    }
    _this111._initBody(body);
    return _this111;
  }

  _createClass(Request, [{
    key: 'clone',
    value: function clone() {
      return new Request(this, {
        body: this._bodyInit
      });
    }
  }]);

  return Request;
}(Body);

function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return METHODS.includes(upcased) ? upcased : method;
}

/**
 * Original work Copyright (c) 2014-2016 GitHub, Inc.
 * Implementation based on https://github.com/github/fetch
 */
var REDIRECT_STATUSES = [301, 302, 303, 307, 308];

var Response = function (_Body2) {
  _inherits(Response, _Body2);

  function Response(bodyInit) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Response);

    var _this112 = _possibleConstructorReturn(this, (Response.__proto__ || Object.getPrototypeOf(Response)).call(this));

    Object.defineProperties(_this112, {
      url: { value: options.url || '' },
      type: { value: options._type || 'default' },
      status: { value: 'status' in options ? options.status : 200 },
      statusText: { value: 'statusText' in options ? options.statusText : 'OK' },
      headers: { value: new Headers(options.headers) }
    });
    _this112._initBody(bodyInit);
    return _this112;
  }

  _createClass(Response, [{
    key: 'clone',
    value: function clone() {
      return new Response(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new Headers(this.headers),
        url: this.url
      });
    }
  }, {
    key: 'ok',
    get: function () {
      return this.status >= 200 && this.status < 300;
    }
  }, {
    key: '_encoding',
    get: function () {
      var contentType = this.headers.get('content-type') || '';
      var parameters = contentType.split(';').slice(1);
      for (var param of parameters) {
        var match = /charset=(\S+)/i.exec(param.trim());
        if (match) {
          return match[1].toLowerCase();
        }
      }
      return null;
    }
  }], [{
    key: 'error',
    value: function error() {
      return new Response(null, { status: 0, statusText: '', _type: 'error' });
    }
  }, {
    key: 'redirect',
    value: function redirect(url, status) {
      if (!REDIRECT_STATUSES.includes(status)) {
        throw new RangeError('Invalid status code');
      }
      return new Response(null, { status: status, headers: { location: url } });
    }
  }]);

  return Response;
}(Body);

/**
 * Original work Copyright (c) 2014-2016 GitHub, Inc.
 * Implementation based on https://github.com/github/fetch
 */


function fetch(input, init) {
  return new Promise(function (resolve, reject) {
    var request = new Request(input, init);
    var hr = new HttpRequest();
    var options = {};
    hr.on('stateChanged', function (event) {
      switch (event.state) {
        case 'headers':
          options.status = event.code;
          options.statusText = event.message;
          options.headers = new Headers(event.headers);
          break;
        case 'finished':
          options.url = options.headers.get('X-Request-URL') || request.url;
          resolve(new Response(event.response, options));
          hr.dispose();
          break;
        case 'error':
          reject(new TypeError('Network request failed'));
          hr.dispose();
          break;
        case 'timeout':
          reject(new TypeError('Network request timed out'));
          hr.dispose();
          break;
        case 'abort':
          reject(new TypeError('Network request aborted'));
          hr.dispose();
          break;
      }
    });
    hr.send({
      url: request.url,
      method: request.method,
      responseType: 'arraybuffer',
      data: typeof request._bodyInit === 'undefined' ? null : request._bodyBuffer || request._bodyInit,
      headers: encodeHeaders(request.headers),
      timeout: request.timeout
    });
  });
}

function encodeHeaders(headers) {
  var map = {};
  headers.forEach(function (value, name) {
    return map[name] = value;
  });
  return map;
}

if (global.tabris && global.tabris.version) {
  throw new Error('tabris module already loaded. Ensure the module is installed only once.');
}

var tabrisMain = Object.assign(new Tabris(), {
  Action: Action,
  ActionSheet: ActionSheet,
  ActionSheetItem: ActionSheetItem,
  ActivityIndicator: ActivityIndicator,
  AlertDialog: AlertDialog,
  App: App,
  Button: Button,
  Blob: Blob,
  Canvas: Canvas,
  ChangeListeners: ChangeListeners,
  CheckBox: CheckBox,
  CollectionView: CollectionView,
  Color: Color,
  ConstraintLayout: ConstraintLayout,
  Camera: Camera,
  CameraView: CameraView,
  Composite: Composite,
  Constraint: Constraint,
  Console: Console,
  ContentView: ContentView,
  Crypto: Crypto,
  DateDialog: DateDialog,
  Device: Device,
  Drawer: Drawer,
  Event: Event,
  EventObject: EventObject,
  FileSystem: FileSystem,
  File: File,
  FormData: FormData,
  Font: Font,
  Image: Image,
  ImageData: ImageData,
  ImageBitmap: ImageBitmap,
  ImageView: ImageView,
  InactivityTimer: InactivityTimer,
  JsxProcessor: JsxProcessor,
  JSX: JSX,
  Layout: Layout,
  LayoutData: LayoutData,
  Listeners: Listeners,
  LinearGradient: LinearGradient,
  NativeObject: NativeObject,
  NavigationView: NavigationView,
  NavigationBar: NavigationBar,
  Popover: Popover,
  Page: Page,
  Percent: Percent,
  Permission: Permission,
  Picker: Picker,
  Printer: Printer,
  ProgressBar: ProgressBar,
  ProgressEvent: ProgressEvent,
  RadioButton: RadioButton,
  RefreshComposite: RefreshComposite,
  RowLayout: RowLayout,
  Row: Row,
  ScrollView: ScrollView,
  SearchAction: SearchAction,
  SizeMeasurement: SizeMeasurement,
  Slider: Slider,
  Storage: Storage,
  StackLayout: StackLayout,
  Stack: Stack,
  StatusBar: StatusBar,
  Switch: Switch,
  Tab: Tab,
  TabFolder: TabFolder,
  TextInput: TextInput,
  TextView: TextView,
  TimeDialog: TimeDialog,
  ToggleButton: ToggleButton,
  Video: Video,
  WebSocket: WebSocket,
  WebView: WebView,
  Widget: Widget,
  WidgetCollection: WidgetCollection,
  $: $,
  XMLHttpRequest: XMLHttpRequest,
  Worker: Worker,
  fetch: fetch,
  format: format,
  Headers: Headers,
  Request: Request,
  Response: Response
});

/** @typedef {typeof tabrisMain} TabrisMain */

// @ts-ignore
module.exports = tabrisMain;
global.tabris = tabrisMain;
global.tabris.tabris = tabrisMain;

Object.assign(global, {
  Blob: Blob,
  File: File,
  FormData: FormData,
  Crypto: Crypto,
  ImageData: ImageData,
  ImageBitmap: ImageBitmap,
  ProgressEvent: ProgressEvent,
  Storage: Storage,
  WebSocket: WebSocket,
  XMLHttpRequest: XMLHttpRequest,
  fetch: fetch,
  Headers: Headers,
  Request: Request,
  Response: Response,
  Worker: Worker,
  $: $,
  createImageBitmap: ImageBitmap.createImageBitmap
});

tabrisMain.on('start', function (options) {
  patchError(Error);
  tabris.$app = create$3();
  checkVersion(tabris.version, tabris.app._nativeGet('tabrisJsVersion'));
  if (!options || !options.headless) {
    tabris.$contentView = create$6();
    tabris._nativeSet('contentView', tabris.contentView.cid);
    tabris.$drawer = create$7();
    tabris.$navigationBar = create$8();
    tabris.$statusBar = create$10();
    tabris.$printer = create$1();
    tabris.$permission = create$2();
    tabris.JSX.install(createJsxProcessor());
  }
  tabris.$sizeMeasurement = create$9();
  tabris.$device = create();
  tabris.$fs = create$4();
  publishDeviceProperties(tabris.device, global);
  tabris.$localStorage = create$5();
  if (tabris.device.platform === 'iOS') {
    tabris.$secureStorage = create$5(true);
  } else {
    tabris.$secureStorage = {};
  }
  tabris.$crypto = new Crypto();
  if (global.console['print']) {
    global.console = createConsole(global.console);
  }
  tabris.$pkcs5 = new Pkcs5();
  global.localStorage = tabrisMain.localStorage;
  global.secureStorage = tabrisMain.secureStorage;
  global.crypto = tabrisMain.crypto;
  global.JSX = tabrisMain.JSX;
});
addDOMDocument(global);
addDOMEventTargetMethods(global);
addWindowTimerMethods(global);
