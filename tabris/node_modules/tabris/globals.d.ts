declare class Crypto {

  getRandomValues(
    typedArray: Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array
  ): void;

}

declare var crypto: Crypto;
interface EventInit {
  bubbles?: boolean;
  cancelable?: boolean;
}

interface Event {
  readonly bubbles: boolean;
  readonly cancelable: boolean;
  readonly currentTarget: EventTarget;
  readonly defaultPrevented: boolean;
  readonly eventPhase: number;
  readonly isTrusted: boolean;
  readonly target: EventTarget;
  readonly timeStamp: number;
  readonly type: string;
  initEvent(eventTypeArg: string, canBubbleArg: boolean, cancelableArg: boolean): void;
  preventDefault(): void;
  stopImmediatePropagation(): void;
  stopPropagation(): void;
  readonly AT_TARGET: number;
  readonly BUBBLING_PHASE: number;
  readonly CAPTURING_PHASE: number;
}

declare var Event: {
  prototype: Event;
  new(typeArg: string, eventInitDict?: EventInit): Event;
  readonly AT_TARGET: number;
  readonly BUBBLING_PHASE: number;
  readonly CAPTURING_PHASE: number;
}

interface EventListener {
  (evt: Event): void;
}

interface EventTarget {
  addEventListener(type: string, listener?: EventListener, useCapture?: boolean): void;
  dispatchEvent(evt: Event): boolean;
  removeEventListener(type: string, listener?: EventListener, useCapture?: boolean): void;
}

declare var EventTarget: {
  prototype: EventTarget;
  new(): EventTarget;
}

interface ProgressEventInit extends EventInit {
  lengthComputable?: boolean;
  loaded?: number;
  total?: number;
}

interface ProgressEvent extends Event {
  readonly lengthComputable: boolean;
  readonly loaded: number;
  readonly total: number;
  initProgressEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, lengthComputableArg: boolean, loadedArg: number, totalArg: number): void;
}

declare var ProgressEvent: {
  prototype: ProgressEvent;
  new(type: string, eventInitDict?: ProgressEventInit): ProgressEvent;
}

interface ErrorEventInit extends EventInit {
  message?: string;
  filename?: string;
  lineno?: number;
  colno?: number;
  error?: any;
}

interface ErrorEvent extends Event {
  readonly colno: number;
  readonly error: any;
  readonly filename: string;
  readonly lineno: number;
  readonly message: string;
  initErrorEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, messageArg: string, filenameArg: string, linenoArg: number): void;
}

declare var ErrorEvent: {
  prototype: ErrorEvent;
  new(type: string, errorEventInitDict?: ErrorEventInit): ErrorEvent;
}

interface CloseEventInit extends EventInit {
  wasClean?: boolean;
  code?: number;
  reason?: string;
}

interface CloseEvent extends Event {
  readonly code: number;
  readonly reason: string;
  readonly wasClean: boolean;
  initCloseEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, wasCleanArg: boolean, codeArg: number, reasonArg: string): void;
}

declare var CloseEvent: {
  prototype: CloseEvent;
  new(typeArg: string, eventInitDict?: CloseEventInit): CloseEvent;
}


interface MessageEventInit extends EventInit {
  lastEventId?: string;
  channel?: string;
  data?: any;
  origin?: string;
  source?: any;
  ports?: MessagePort[];
}

interface MessageEvent extends Event {
  readonly data: any;
  readonly origin: string;
  readonly ports: any;
  readonly source: any;
  initMessageEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, dataArg: any, originArg: string, lastEventIdArg: string, sourceArg: any): void;
}

declare var MessageEvent: {
  prototype: MessageEvent;
  new(type: string, eventInitDict?: MessageEventInit): MessageEvent;
}

declare var MessageEvent: {
  prototype: MessageEvent;
  new(type: string, eventInitDict?: MessageEventInit): MessageEvent;
}

interface MessagePortEventMap {
  "message": MessageEvent;
}

interface MessagePort extends EventTarget {
  onmessage: (this: MessagePort, ev: MessageEvent) => any;
  close(): void;
  postMessage(message?: any, transfer?: any[]): void;
  start(): void;
  addEventListener<K extends keyof MessagePortEventMap>(type: K, listener: (this: MessagePort, ev: MessagePortEventMap[K]) => any, useCapture?: boolean): void;
}

declare var MessagePort: {
  prototype: MessagePort;
  new(): MessagePort;
}


interface CordovaPlugins {}

interface Navigator {}

interface Document {}

interface Cordova {
  plugins: CordovaPlugins;
}

interface Window {
  plugins: CordovaPlugins;
  cordova: Cordova;
  navigator: Navigator;
  window: Window;
  document: Document;
}

declare var navigator: Navigator;
declare var window: Window;
declare var document: Document;
declare var plugins: CordovaPlugins;
declare var cordova: Cordova;

/**
 * Represents pixel data of a `Canvas` widget.
 */
declare class ImageData {

  constructor(data: Uint8ClampedArray, width: number, height?: number);
  constructor(width: number, height: number);

  /**
   * A one-dimensional array containing the data in RGBA order, with integer values between 0 and 255 (inclusive).
   */
  readonly data: Uint8ClampedArray;

  /**
   * The actual height of the ImageData, in pixels.
   */
  readonly width: number;

  /**
   * The actual height of the ImageData, in pixels.
   */
  readonly height: number;

}
declare namespace JSX {

  type JsxFactory = (
    this: tabris.JsxProcessor,
    type: {new (...args: any[]): any },
    attributes: object
  ) => Element;

  type Element = any;

  const jsxFactory: unique symbol;
  const jsxType: unique symbol;

  function createElement(type: Function|string, attributes: object, ...children: Array<ElementClass>): ElementClass;

  function install(jsxProcessor: tabris.JsxProcessor): void;

  interface ElementClass {
    jsxAttributes?: object;
    [JSX.jsxFactory]: JsxFactory;
  }

  interface ElementAttributesProperty {
    jsxAttributes: any;
  }

  interface ElementChildrenAttribute {
    children?: any;
  }

  interface IntrinsicElements {
    br: {children?: never};
    b: {children?: string|string[]};
    span: {children?: string|string[]};
    big: {children?: string|string[]};
    i: {children?: string|string[]};
    small: {children?: string|string[]};
    strong: {children?: string|string[]};
    ins: {children?: string|string[]};
    del: {children?: string|string[]};
    a: {href?: string, children?: string|string[]};
  }

}

declare var secureStorage: Storage;
declare var device: tabris.Device;
declare var createImageBitmap: typeof tabris.ImageBitmap.createImageBitmap;
declare var __dirname: string;
declare var __filename: string;
declare var module: tabris.Module;
declare var exports: object;
declare var require: (request: string) => object;
interface WebSocketEventMap {
    "close": CloseEvent;
    "error": Event;
    "message": MessageEvent;
    "open": Event;
}

interface WebSocket extends EventTarget {
    binaryType: string;
    readonly bufferedAmount: number;
    readonly extensions: string;
    onclose: (this: WebSocket, ev: CloseEvent) => any;
    onerror: (this: WebSocket, ev: Event) => any;
    onmessage: (this: WebSocket, ev: MessageEvent) => any;
    onopen: (this: WebSocket, ev: Event) => any;
    readonly protocol: string;
    readonly readyState: number;
    readonly url: string;
    close(code?: number, reason?: string): void;
    send(data: any): void;
    readonly CLOSED: number;
    readonly CLOSING: number;
    readonly CONNECTING: number;
    readonly OPEN: number;
    addEventListener<K extends keyof WebSocketEventMap>(type: K, listener: (this: WebSocket, ev: WebSocketEventMap[K]) => any, useCapture?: boolean): void;
}

declare var WebSocket: {
    prototype: WebSocket;
    new(url: string, protocols?: string | string[]): WebSocket;
    readonly CLOSED: number;
    readonly CLOSING: number;
    readonly CONNECTING: number;
    readonly OPEN: number;
}

interface WorkerEventMap {
    "message": MessageEvent;
    "error": Event;
    "messageerror": Event;
}

interface Worker extends EventTarget {
    onerror: (this: Worker, ev: Event) => any;
    onmessageerror: (this: Worker, ev: Event) => any;
    onmessage: (this: Worker, ev: MessageEvent) => any;
    onopen: (this: Worker, ev: Event) => any;
    readonly protocol: string;
    readonly readyState: number;
    readonly url: string;
    postMessage(data: any, transferList?: Array<any>): void;
    terminate(): void;
    addEventListener<K extends keyof WorkerEventMap>(type: K, listener: (this: Worker, ev: WorkerEventMap[K]) => any, useCapture?: boolean): void;
}

declare var Worker: {
    prototype: Worker;
    new(scriptPath: string): Worker;
};

interface XMLHttpRequestEventTarget {
    onabort: (this: XMLHttpRequestEventTarget, ev: Event) => any;
    onerror: (this: XMLHttpRequestEventTarget, ev: ErrorEvent) => any;
    onload: (this: XMLHttpRequestEventTarget, ev: Event) => any;
    onloadend: (this: XMLHttpRequestEventTarget, ev: ProgressEvent) => any;
    onloadstart: (this: XMLHttpRequestEventTarget, ev: Event) => any;
    onprogress: (this: XMLHttpRequestEventTarget, ev: ProgressEvent) => any;
    ontimeout: (this: XMLHttpRequestEventTarget, ev: ProgressEvent) => any;
    addEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestEventTarget, ev: XMLHttpRequestEventTargetEventMap[K]) => any, useCapture?: boolean): void;
    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;
}

interface XMLHttpRequestEventTargetEventMap {
    "abort": Event;
    "error": ErrorEvent;
    "load": Event;
    "loadend": ProgressEvent;
    "loadstart": Event;
    "progress": ProgressEvent;
    "timeout": ProgressEvent;
}

interface XMLHttpRequestEventMap extends XMLHttpRequestEventTargetEventMap {
    "readystatechange": Event;
}


interface XMLHttpRequest extends EventTarget, XMLHttpRequestEventTarget {
    onreadystatechange: (this: XMLHttpRequest, ev: Event) => any;
    readonly readyState: number;
    readonly response: any;
    readonly responseText: string;
    responseType: 'text' | 'arraybuffer' | '';
    readonly status: number;
    readonly statusText: string;
    timeout: number;
    readonly upload: XMLHttpRequestUpload;
    withCredentials: boolean;
    abort(): void;
    getAllResponseHeaders(): string;
    getResponseHeader(header: string): string | null;
    open(method: string, url: string, async?: boolean, user?: string, password?: string): void;
    send(data?: string | ArrayBuffer | Blob | FormData): void;
    setRequestHeader(header: string, value: string): void;
    readonly DONE: number;
    readonly HEADERS_RECEIVED: number;
    readonly LOADING: number;
    readonly OPENED: number;
    readonly UNSENT: number;
    addEventListener<K extends keyof XMLHttpRequestEventMap>(type: K, listener: (this: XMLHttpRequest, ev: XMLHttpRequestEventMap[K]) => any, useCapture?: boolean): void;
    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;
}

declare var XMLHttpRequest: {
    prototype: XMLHttpRequest;
    new(): XMLHttpRequest;
    readonly DONE: number;
    readonly HEADERS_RECEIVED: number;
    readonly LOADING: number;
    readonly OPENED: number;
    readonly UNSENT: number;
}

interface XMLHttpRequestUpload extends EventTarget, XMLHttpRequestEventTarget {
    addEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestUpload, ev: XMLHttpRequestEventTargetEventMap[K]) => any, useCapture?: boolean): void;
    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;
}

declare var XMLHttpRequestUpload: {
    prototype: XMLHttpRequestUpload;
    new(): XMLHttpRequestUpload;
}


// $


/**
 * A shortcut to [`tabris.contentView.find()`](./Composite.md#findselector). Returns a collection
 * containing all descendants of contentView that match the given selector. This does *not* include any
 * widgets in the drawer, a popover, or encapsulated in a custom component.
 * @param selector A selector expression or a predicate function to filter the results.
 */
declare function $<Result extends tabris.Widget = tabris.Widget>(selector?: tabris.Selector<tabris.Widget, Result>): tabris.WidgetCollection<Result>;

/**
 * A JSX stateless functional component that groups all given widgets in a WidgetCollection
 * @param attributes This parameter needs to be null since <$> does not support any attributes
 * @param children The widgets to be included in the resulting WidgetCollection instance.
 */
declare function $(attributes: {children: tabris.JSXChildren<tabris.Widget>}|null, children: tabris.JSXChildren<tabris.Widget>): tabris.WidgetCollection<tabris.Widget>;

/**
 * A JSX stateless functional component that joins any given content in to a single string.
 * @param attributes This parameter needs to be null since <$> does not support any attributes.
 * @param children The content of the resulting string.
 */
declare function $(attributes: {children: string|number|boolean|Array<null|string|number|boolean>}|null, children: string|number|boolean|Array<null|string|number|boolean>): string;

/**
 * Returns the non-disposed `NativeObject` instance (e.g. a widget) associated with the given cid
 * number. The number can be obtained via the [cid](./NativeObject.md#cid) property. Example: If the cid
 * of an object is `'$23'` it can be obtained by `$(23)`. The cid is visible in the log when passing a
 * NativeObject to any log method, e.g. [`console.log(widget)`](./console.md#logvalues), or
 * [`console.dirxml(widget)`](./console.md#dirxmlobject). The native object may then be obtained using
 * the developer console or the interactive console feature for the tabris CLI serve command.
 * This feature is meant for debugging purposes only. **Using it in production code is dangerous since
 * it allows interfering with the internals of the framework or encapsulated components.** Also, the
 * `cid` of a NativeObject is not stable, meaning it can change each time the code is executed.
 * @param cidNumber The cid number is the trailing part of the [cid](./NativeObject.md#cid) property string.
 */
declare function $(cidNumber: number): tabris.NativeObject;

// Blob

/**
 * Represents raw data of a given type.
 */
declare class Blob {

  public constructor(blobParts?: any[], options?: {type?: string});

  /**
   * Reads the blob data into an ArrayBuffer and returns it in a promise. Each call creates a new
   * in-memory copy of the data.
   */
  arrayBuffer(): Promise<ArrayBuffer>;

  /**
   * Decodes the blob data as a string and returns it in a promise.
   */
  text(): Promise<string>;

  /**
   * Size of the blob data in bytes
   * @constant
   */
  readonly size: number;

  /**
   * The MIME type of the blob data
   * @constant
   */
  readonly type: string;
}

// Console

/**
 * The console object provides access to the [debugging console](../debug.md).
 */
declare class Console {

  private constructor();

  /**
   * Outputs an error message to the console if the first argument is false.
   * @param expression Any boolean expression. If the assertion is false, the error message is written to the console.
   * @param values A list of JavaScript values to output.
   */
  assert(expression: boolean, ...values: any[]): void;

  /**
   * Logs the number of times that this particular call to count() has been called.
   * @param label If supplied, count() outputs the number of times it has been called with that label.
   */
  count(label?: string): void;

  /**
   * Resets the counter.
   * @param label If label supplied, this function resets the count associated with that particular label.
   */
  countReset(label?: string): void;

  /**
   * Outputs a debug message to the console.
   * @param values A list of JavaScript values to output.
   */
  debug(...values: any[]): void;

  /**
   * XML tree representation of a given object, if available. Supported types include all widgets and
   * `localStorage`. 
   * *The output is NOT JSX, it is a human-readable summary that displays XML-conforming string
   * representations of some select property values.
   * @param object A JavaScript object
   */
  dirxml(object: any): void;

  /**
   * Outputs an error message to the console.
   * @param values A list of JavaScript values to output.
   */
  error(...values: any[]): void;

  /**
   * Creates a new inline group in the console output. This indents following console messages by an
   * additional spaces, until console.groupEnd() is called.
   * @param values A list of JavaScript values to output.
   */
  group(...values: any[]): void;

  /**
   * Exits the current inline group in the console.
   */
  groupEnd(): void;

  /**
   * Exits the current inline group in the console.
   */
  groupEnd(): void;

  /**
   * Outputs an info message to the console.
   * @param values A list of JavaScript values to output.
   */
  info(...values: any[]): void;

  /**
   * Outputs a message to the console.
   * @param values A list of JavaScript values to output
   */
  log(...values: any[]): void;

  /**
   * Prints a stack trace in a platform-independent format. Framework internals are omitted.
   * Source maps are supported when side-loading code via the tabris CLI.
   */
  trace(): void;

  /**
   * Outputs a warning message to the console.
   * @param values A list of JavaScript values to output.
   */
  warn(...values: any[]): void;
}

declare var console: Console;

// File

/**
 * Represents raw data of a given type and name.
 */
declare class File extends Blob {

  public constructor(blobParts: any[], name: string, options?: {type?: string, lastModified?: number});

  /**
   * Unix timestamp of the last known modification of the file
   * @constant
   */
  readonly lastModified: number;

  /**
   * The name or path of the file
   * @constant
   */
  readonly name: string;
}

// FormData

/**
 * FormData provides a way to construct a set of key/value pairs which can then be sent using fetch() or
 * XMLHttpRequest. It uses the same format a HTML form would use if the encoding type were set to
 * `multipart/form-data`.
 */
declare class FormData {

  public constructor();


  [Symbol.iterator](): IterableIterator<[string, string | File]>;

  /**
   * Adds a string value associated with a given key. Any existing values for that key will be retained.
   * @param key
   * @param value
   */
  append(key: string, value: string): void;

  /**
   * Adds binary data associated with a given key. Will be stored as an instance of `File` with its `name`
   * set to the given `filename` parameter. If no `filename` is given and the value is not already a named
   * `File` instance it will default to `'blob'`. Any existing values for that key will be retained.
   * @param key
   * @param value
   * @param filename
   */
  append(key: string, value: Blob | File, filename?: string): void;

  /**
   * Removes all values associated with a given key.
   * @param key
   */
  delete(key: string): void;


  entries(): IterableIterator<[string, string | File]>;

  /**
   * Returns the first value associated with a given key.
   * @param key
   */
  get(key: string): string | File | null;

  /**
   * Returns all the values associated with a given key.
   * @param key
   */
  getAll(key: string): string[];

  /**
   * Returns true if there are any values associated with a given key.
   * @param key
   */
  has(key: string): boolean;


  keys(): IterableIterator<string>;

  /**
   * Adds a string value associated with a given key. Any existing values for that key will be replaced.
   * @param key
   * @param value
   */
  set(key: string, value: string): void;

  /**
   * Adds binary data associated with a given key. Will be stored as an instance of `File` with its `name`
   * set to the given `filename` parameter. If no `filename` is given and the value is not already a named
   * `File` instance it will default to `'blob'`. Any existing values for that key will be replaced.
   * @param key
   * @param value
   * @param filename
   */
  set(key: string, value: Blob | File, filename?: string): void;


  values(): IterableIterator<string | File>;
}

// Headers

/**
 * Represents a set of HTTP headers as used by `fetch()`.
 */
declare class Headers {

  public constructor(headers?: Headers | Array<[string, string]> | {[header: string]: string});


  [Symbol.iterator](): IterableIterator<[string, string]>;

  /**
   * Adds a value to a given header. Any existing values for that header will be retained.
   * @param name
   * @param value
   */
  append(name: string, value: string): void;

  /**
   * Removes all values associated with a given header.
   * @param name
   */
  delete(name: string): void;


  entries(): IterableIterator<[string, string]>;


  forEach(callback: ((value:string, name:string) => void)): void;

  /**
   * Returns the first value associated with a given header.
   * @param name
   */
  get(name: string): string | null;

  /**
   * Returns all values associated with a given header.
   * @param name
   */
  getAll(name: string): string[];

  /**
   * Returns true if there are any values associated with a given header.
   * @param name
   */
  has(name: string): boolean;


  keys(): IterableIterator<string>;

  /**
   * Adds a string value associated with a given header. Any existing values for that header will be
   * replaced.
   * @param name
   * @param value
   */
  set(name: string, value: string): void;


  values(): IterableIterator<string>;
}

// Request

/**
 * Represents an HTTP Request as used by `fetch()`.
 */
declare class Request {

  public constructor(input: string | Request, init?: RequestInit);


  arrayBuffer(): Promise<ArrayBuffer>;


  blob(): Promise<Blob>;


  clone(): Request;


  json(): Promise<any>;


  json<T>(): Promise<T>;


  text(): Promise<string>;


  readonly bodyUsed: boolean;


  readonly cash: 'default' | 'force-cache' | 'no-cache' | 'no-store' | 'only-if-cached' | 'reload';


  readonly context: 'audio' | 'beacon' | 'cspreport' | 'download' | 'embed' | 'eventsource' | 'favicon' | 'fetch' | 'font' | 'form' | 'frame' | 'hyperlink' | 'iframe' | 'image' | 'imageset' | 'import' | 'internal' | 'location' | 'manifest' | 'object' | 'ping' | 'plugin' | 'prefetch' | 'script' | 'serviceworker' | 'sharedworker' | 'style' | 'subresource' | 'track' | 'video' | 'worker' | 'xmlhttprequest' | 'xslt';


  readonly credentials: 'include' | 'omit' | 'same-origin';


  readonly headers: Headers;


  readonly method: string;


  readonly mode: 'cors' | 'no-cors' | 'same-origin';


  readonly referrer: string;


  readonly url: string;
}

// RequestInit

declare interface RequestInit {

  /**
   * The body of the request. GET or HEAD requests can not have a body.
   */
  body?: Blob | FormData | string;


  cache?: 'default' | 'force-cache' | 'no-cache' | 'no-store' | 'only-if-cached' | 'reload';


  credentials?: 'include' | 'omit' | 'same-origin';

  /**
   * The headers to add to the request.
   */
  headers?: Headers | Array<[string, string]> | {[header: string]: string};

  /**
   * The request method, e.g., `'GET'`, `'POST'`.
   */
  method?: string;


  mode?: 'cors' | 'no-cors' | 'same-origin';
}

// Response

/**
 * Represents an HTTP Response as used by `fetch()`.
 */
declare class Response {

  public constructor(body?: Blob | FormData | string, init?: ResponseInit);


  arrayBuffer(): Promise<ArrayBuffer>;


  blob(): Promise<Blob>;


  clone(): Response;


  json(): Promise<any>;


  json<T>(): Promise<T>;


  text(): Promise<string>;


  static error(): Response;


  static redirect(url: string, status: number): Response;


  readonly bodyUsed: boolean;


  readonly headers: Headers;


  readonly ok: boolean;


  readonly status: number;


  readonly statusText: string;


  readonly type: 'basic' | 'cors' | 'default' | 'error' | 'opaque';


  readonly url: string;
}

// ResponseInit

declare interface ResponseInit {


  headers?: Headers | Array<[string, string]> | {[header: string]: string};


  status?: number;


  statusText?: string;
}

// fetch



declare function fetch(url: string | Request, init?: RequestInit): Promise<Response>;

// Storage

/**
 * The `localStorage` object allows storing key-value pairs in a persistent store. Both keys and values
 * are stored as strings.
 * On iOS, there is an additional object `secureStorage` available in the global scope. This is a
 * drop-in replacement for `localStorage` that keeps data in the encrypted iOS Keychain.
 * The `localStorage` is only meant to store relatively short strings. To store larger amounts of data
 * it is recommended to use the [FileSystem](./fs.html) API.
 */
declare class Storage {

  private constructor();

  /**
   * Remove all key/value pairs from the storage.
   */
  clear(): void;

  /**
   * Retrieves the value associated with the given key.
   * @param key
   */
  getItem(key: string): string | null;

  /**
   * Returns the name of the key at the given index in the storage. The order of keys is platform
   * dependent, you should not rely on it to be deterministic
   * @param index
   */
  key(index: number): string;

  /**
   * Removes the given key/value pair from the storage.
   * @param key
   */
  removeItem(key: string): void;

  /**
   * Stores a string value using the given key.
   * @param key
   * @param value
   */
  setItem(key: string, value: string): void;

  /**
   * The number of items in the storage.
   * @constant
   */
  readonly length: number;
}

declare var localStorage: Storage;

// Timer


/**
 * Cancels the running interval associated with the given ID. When given an invalid ID, nothing happens.
 * @param id The ID that was returned by `setInterval`.
 */
declare function clearInterval(id: any): void;

/**
 * Cancels the running timeout associated with the given ID. When given an invalid ID, nothing happens.
 * @param id The ID that was returned by `setTimeout`.
 */
declare function clearTimeout(id: any): void;

/**
 * Calls the given function repeatedly, each times waiting the given delay. The actual delay may be
 * slightly longer than the given one.
 * @param callback The function to call.
 * @param delay The delay in milliseconds.
 * @param params One or more values passed on to the callback.
 */
declare function setInterval(callback: Function, delay?: number, ...params: any[]): any;

/**
 * Calls the given function with `param` (and all following parameters) after the specified delay. The
 * actual delay may be slightly longer than the given one.
 * @param callback The function to call.
 * @param delay The delay in milliseconds.
 * @param params One or more values passed on to the callback.
 */
declare function setTimeout(callback: Function, delay?: number, ...params: any[]): any;

